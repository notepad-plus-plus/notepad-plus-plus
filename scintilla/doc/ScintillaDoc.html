<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator"
    content="HTML Tidy for Windows (vers 1st August 2002), see www.w3.org" />
    <meta name="generator" content="SciTE" />
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

    <title>Scintilla and SciTE</title>

    <style type="text/css">
<!--
/*<![CDATA[*/
    CODE { font-weight: bold; font-family: Consolas,Bitstream Vera Sans Mono,Courier New,monospace; }
    A:visited { color: blue; }
    A:hover { text-decoration: underline ! important; }
    A.message { text-decoration: none; font-weight: bold; font-family: Consolas,Bitstream Vera Sans Mono,Courier New,monospace; }
    A.toc { text-decoration: none; }
    A.jump { text-decoration: none; }
/*]]>*/
-->
    </style>
  </head>

  <body bgcolor="#FFFFFF" text="#000000">
    <table bgcolor="#000000" width="100%" cellspacing="0" cellpadding="0" border="0"
    summary="Banner">
      <tr>
        <td><img src="SciTEIco.png" border="3" height="64" width="64" alt="Scintilla icon" /></td>

        <td><a href="index.html"
        style="color:white;text-decoration:none;font-size:200%">Scintilla</a></td>
      </tr>
    </table>

    <h1>Scintilla Documentation</h1>

    <p>Last edited 28/April/2009 NH</p>

    <p>There is <a class="jump" href="Design.html">an overview of the internal design of
    Scintilla</a>.<br />
     <a class="jump" href="ScintillaUsage.html">Some notes on using Scintilla</a>.<br />
     <a class="jump" href="Steps.html">How to use the Scintilla Edit Control on Windows</a>.<br />
     <a class="jump" href="http://www.scintilla.org/dmapp.zip">A simple sample using Scintilla from
    C++ on Windows</a>.<br />
     <a class="jump" href="http://www.scintilla.org/SciTry.vb">A simple sample using Scintilla from
    Visual Basic</a>.<br />
     <a class="jump" href="http://www.scintilla.org/bait.zip">Bait is a tiny sample using Scintilla
     on GTK+</a>.<br />
     <a class="jump" href="Lexer.txt">A detailed description of how to write a lexer, including a
    discussion of folding</a>.<br />
     <a class="jump" href="http://sphere.sourceforge.net/flik/docs/scintilla-container_lexer.html">
     How to implement a lexer in the container</a>.<br />
     <a class="jump" href="http://sphere.sourceforge.net/flik/docs/scintilla-folding.html">
     How to implement folding</a>.<br />
     The <a class="jump" href="SciCoding.html">coding style</a> used in Scintilla and SciTE is
    worth following if you want to contribute code to Scintilla but is not compulsory.</p>

    <h2>Introduction</h2>

    <p>The Windows version of Scintilla is a Windows Control. As such, its primary programming
    interface is through Windows messages. Early versions of Scintilla emulated much of the API
    defined by the standard Windows Edit and RichEdit controls but those APIs are now deprecated in
    favour of Scintilla's own, more consistent API. In addition to messages performing the actions
    of a normal Edit control, Scintilla allows control of syntax styling, folding, markers, autocompletion
    and call tips.</p>

    <p>The GTK+ version also uses messages in a similar way to the Windows version. This is
    different to normal GTK+ practice but made it easier to implement rapidly.</p>

    <p>This documentation describes the individual messages and notifications used by Scintilla. It
    does not describe how to link them together to form a useful editor. For now, the best way to
    work out how to develop using Scintilla is to see how SciTE uses it. SciTE exercises most of
    Scintilla's facilities.</p>

    <p>In the descriptions that follow, the messages are described as function calls with zero, one
    or two arguments. These two arguments are the standard <code>wParam</code> and
    <code>lParam</code> familiar to Windows programmers. These parameters are integers that
    are large enough to hold pointers, and the return value is also an integer large enough to contain a
    pointer.
    Although the commands only use the
    arguments described, because all messages have two arguments whether Scintilla uses them or
    not, it is strongly recommended that any unused arguments are set to 0. This allows future
    enhancement of messages without the risk of breaking existing code. Common argument types
    are:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Common argument types">
      <tbody valign="top">
        <tr>
          <th align="left">bool</th>

          <td>Arguments expect the values 0 for <code>false</code> and 1 for
          <code>true</code>.</td>
        </tr>

        <tr>
          <th align="left">int</th>

          <td>Arguments are 32-bit signed integers.</td>
        </tr>

        <tr>
          <th align="left">const&nbsp;char&nbsp;*</th>

          <td>Arguments point at text that is being passed to Scintilla but not modified. The text
          may be zero terminated or another argument may specify the character count, the
          description will make this clear.</td>
        </tr>

        <tr>
          <th align="left">char *</th>

          <td>Arguments point at text buffers that Scintilla will fill with text. In some cases,
          another argument will tell Scintilla the buffer size. In others, you must make sure that
          the buffer is big enough to hold the requested text. If a NULL pointer (0) is passed
          then, for SCI_* calls, the length that should be allocated is returned.</td>
        </tr>

        <tr>
          <th align="left" id="colour">colour</th>

          <td>Colours are set using the RGB format (Red, Green, Blue). The intensity of each colour
          is set in the range 0 to 255. If you have three such intensities, they are combined as:
          red | (green &lt;&lt; 8) | (blue &lt;&lt; 16). If you set all intensities to 255, the
          colour is white. If you set all intensities to 0, the colour is black. When you set a
          colour, you are making a request. What you will get depends on the capabilities of the
          system and the current screen mode.</td>
        </tr>

        <tr>
          <th align="left" id="alpha">alpha</th>

          <td>Translucency is set using an alpha value.
                        Alpha ranges from 0 (SC_ALPHA_TRANSPARENT) which is completely transparent to
                               255 (SC_ALPHA_OPAQUE) which is opaque. The value 256 (SC_ALPHA_NOALPHA)
                               is opaque and uses code that is not alpha-aware and may be faster. Not all platforms support
                               translucency and only some Scintilla features implement translucency.
                               The default alpha value for most features is SC_ALPHA_NOALPHA.</td>
        </tr>

        <tr>
          <th align="left">&lt;unused&gt;</th>

          <td>This is an unused argument. Setting it to 0 will ensure compatibility with future
          enhancements.</td>
        </tr>
      </tbody>
    </table>

    <h2 id="MessageCategories">Contents</h2>

    <table cellpadding="4" cellspacing="2" border="0" summary="Message categories">
      <tbody>
        <tr>
          <td>o <a class="toc" href="#TextRetrievalAndModification">Text retrieval and
          modification</a></td>

          <td>o <a class="toc" href="#Searching">Searching and replacing</a></td>

          <td>o <a class="toc" href="#Overtype">Overtype</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#CutCopyAndPaste">Cut, copy and paste</a></td>

          <td>o <a class="toc" href="#ErrorHandling">Error handling</a></td>

          <td>o <a class="toc" href="#UndoAndRedo">Undo and Redo</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#SelectionAndInformation">Selection and information</a></td>

          <td>o <a class="toc" href="#ScrollingAndAutomaticScrolling">Scrolling and automatic
          scrolling</a></td>

          <td>o <a class="toc" href="#WhiteSpace">White space</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Cursor">Cursor</a></td>

          <td>o <a class="toc" href="#MouseCapture">Mouse capture</a></td>

          <td>o <a class="toc" href="#LineEndings">Line endings</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Styling">Styling</a></td>

          <td>o <a class="toc" href="#StyleDefinition">Style definition</a></td>

          <td>o <a class="toc" href="#CaretAndSelectionStyles">Caret, selection, and hotspot styles</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Margins">Margins</a></td>

          <td>o <a class="toc" href="#Annotations">Annotations</a></td>

          <td>o <a class="toc" href="#OtherSettings">Other settings</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#BraceHighlighting">Brace highlighting</a></td>

          <td>o <a class="toc" href="#TabsAndIndentationGuides">Tabs and Indentation
          Guides</a></td>

          <td>o <a class="toc" href="#Markers">Markers</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Indicators">Indicators</a></td>

	<td>o <a class="toc" href="#Autocompletion">Autocompletion</a></td>

          <td>o <a class="toc" href="#UserLists">User lists</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#CallTips">Call tips</a></td>

	<td>o <a class="toc" href="#KeyboardCommands">Keyboard commands</a></td>

          <td>o <a class="toc" href="#KeyBindings">Key bindings</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#PopupEditMenu">Popup edit menu</a></td>
	  
          <td>o <a class="toc" href="#MacroRecording">Macro recording</a></td>

          <td>o <a class="toc" href="#Printing">Printing</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#DirectAccess">Direct access</a></td>
	  
          <td>o <a class="toc" href="#MultipleViews">Multiple views</a></td>

          <td>o <a class="toc" href="#Folding">Folding</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#LineWrapping">Line wrapping</a></td>
	
          <td>o <a class="toc" href="#Zooming">Zooming</a></td>

          <td>o <a class="toc" href="#LongLines">Long lines</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Lexer">Lexer</a></td>
	  
          <td>o <a class="toc" href="#Notifications">Notifications</a></td>

          <td>o <a class="toc" href="#GTK">GTK+</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#DeprecatedMessages">Deprecated messages</a></td>
	  
          <td>o <a class="toc" href="#EditMessagesNeverSupportedByScintilla">Edit messages never
          supported by Scintilla</a></td>

          <td>o <a class="toc" href="#BuildingScintilla">Building Scintilla</a></td>
        </tr>
      </tbody>
    </table>

    <p>Messages with names of the form <code>SCI_SETxxxxx</code> often have a companion
    <code>SCI_GETxxxxx</code>. To save tedious repetition, if the <code>SCI_GETxxxxx</code> message
    returns the value set by the <code>SCI_SETxxxxx</code> message, the <code>SET</code> routine is
    described and the <code>GET</code> routine is left to your imagination.</p>

    <h2 id="TextRetrievalAndModification">Text retrieval and modification</h2>

    <p>Each byte in a Scintilla document is followed by an associated byte of styling
    information. The combination of a character byte and a style byte is called a cell. Style bytes
    are interpreted an index into an array of styles.
    Style bytes may be split into an index and a set of indicator bits
    but this use is discouraged and indicators should now use
    <a class="message" href ="#SCI_INDICATORFILLRANGE">SCI_INDICATORFILLRANGE</a>
    and related calls.
    The default split is with the index in the low 5 bits and 3 high bits as <a class="jump"
    href="#Indicators">indicators</a>. This allows 32 fundamental styles, which is enough for most
    languages, and three independent indicators so that, for example, syntax errors, deprecated
    names and bad indentation could all be displayed at once. The number of bits used for styles
    can be altered with <a class="message"
    href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a> up to a maximum of 7 bits.
    The remaining bits can be used for indicators.</p>

    <p>In this document, 'character' normally refers to a byte even when multi-byte characters are used.
    Lengths measure the numbers of bytes, not the amount of characters in those bytes.</p>

    <p>Positions within the Scintilla document refer to a character or the gap before that
    character. The first character in a document is 0, the second 1 and so on. If a document
    contains <code>nLen</code> characters, the last character is numbered <code>nLen</code>-1.
    The caret exists between character positions and can be located from before the first character (0)
    to after the last character (<code>nLen</code>).</p>

    <p>There are places where the caret can not go where two character bytes make up one character.
    This occurs when a DBCS character from a language like Japanese is included in the document or
    when line ends are marked with the CP/M standard of a carriage return followed by a line feed.
    The <code>INVALID_POSITION</code> constant (-1) represents an invalid position within the
    document.</p>

    <p>All lines of text in Scintilla are the same height, and this height is calculated from the
    largest font in any current style. This restriction is for performance; if lines differed in
    height then calculations involving positioning of text would require the text to be styled
    first.</p>
    <code><a class="message" href="#SCI_GETTEXT">SCI_GETTEXT(int length, char *text)</a><br />
     <a class="message" href="#SCI_SETTEXT">SCI_SETTEXT(&lt;unused&gt;, const char *text)</a><br />
     <a class="message" href="#SCI_SETSAVEPOINT">SCI_SETSAVEPOINT</a><br />
     <a class="message" href="#SCI_GETLINE">SCI_GETLINE(int line, char *text)</a><br />
     <a class="message" href="#SCI_REPLACESEL">SCI_REPLACESEL(&lt;unused&gt;, const char
    *text)</a><br />
     <a class="message" href="#SCI_SETREADONLY">SCI_SETREADONLY(bool readOnly)</a><br />
     <a class="message" href="#SCI_GETREADONLY">SCI_GETREADONLY</a><br />
     <a class="message" href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE(&lt;unused&gt;, TextRange
    *tr)</a><br />
     <a class="message" href="#SCI_ALLOCATE">SCI_ALLOCATE(int bytes, &lt;unused&gt;)</a><br />
     <a class="message" href="#SCI_ADDTEXT">SCI_ADDTEXT(int length, const char *s)</a><br />
     <a class="message" href="#SCI_ADDSTYLEDTEXT">SCI_ADDSTYLEDTEXT(int length, cell *s)</a><br />
     <a class="message" href="#SCI_APPENDTEXT">SCI_APPENDTEXT(int length, const char *s)</a><br />
     <a class="message" href="#SCI_INSERTTEXT">SCI_INSERTTEXT(int pos, const char *text)</a><br />
     <a class="message" href="#SCI_CLEARALL">SCI_CLEARALL</a><br />
     <a class="message" href="#SCI_CLEARDOCUMENTSTYLE">SCI_CLEARDOCUMENTSTYLE</a><br />
     <a class="message" href="#SCI_GETCHARAT">SCI_GETCHARAT(int position)</a><br />
     <a class="message" href="#SCI_GETSTYLEAT">SCI_GETSTYLEAT(int position)</a><br />
     <a class="message" href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT(&lt;unused&gt;, TextRange
    *tr)</a><br />
     <a class="message" href="#SCI_SETSTYLEBITS">SCI_SETSTYLEBITS(int bits)</a><br />
     <a class="message" href="#SCI_GETSTYLEBITS">SCI_GETSTYLEBITS</a><br />
     <a class="message" href="#SCI_TARGETASUTF8">SCI_TARGETASUTF8(&lt;unused&gt;, char *s)</a><br />
     <a class="message" href="#SCI_ENCODEDFROMUTF8">SCI_ENCODEDFROMUTF8(const char *utf8, char *encoded)</a><br />
     <a class="message" href="#SCI_SETLENGTHFORENCODE">SCI_SETLENGTHFORENCODE(int bytes)</a><br />
    </code>

    <p><b id="SCI_GETTEXT">SCI_GETTEXT(int length, char *text)</b><br />
     This returns <code>length</code>-1 characters of text from the start of the document plus one
    terminating 0 character. To collect all the text in a document, use <code>SCI_GETLENGTH</code>
    to get the number of characters in the document (<code>nLen</code>), allocate a character
    buffer of length <code>nLen+1</code> bytes, then call <code>SCI_GETTEXT(nLen+1, char
    *text)</code>. If the text argument is 0 then the length that should be allocated to store the
    entire document is returned.
    If you then save the text, you should use <code>SCI_SETSAVEPOINT</code> to mark
    the text as unmodified.</p>

    <p>See also: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a class="message"
    href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a></code></p>

    <p><b id="SCI_SETTEXT">SCI_SETTEXT(&lt;unused&gt;, const char *text)</b><br />
     This replaces all the text in the document with the zero terminated text string you pass
    in.</p>

    <p><b id="SCI_SETSAVEPOINT">SCI_SETSAVEPOINT</b><br />
     This message tells Scintilla that the current state of the document is unmodified. This is
    usually done when the file is saved or loaded, hence the name "save point". As Scintilla
    performs undo and redo operations, it notifies the container that it has entered or left the
    save point with <code><a class="message"
    href="#SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</a></code> and <code><a class="message"
    href="#SCN_SAVEPOINTLEFT">SCN_SAVEPOINTLEFT</a></code> <a class="jump"
    href="#Notifications">notification messages</a>, allowing the container to know if the file
    should be considered dirty or not.</p>

    <p>See also: <code><a class="message" href="#SCI_EMPTYUNDOBUFFER">SCI_EMPTYUNDOBUFFER</a>, <a
    class="message" href="#SCI_GETMODIFY">SCI_GETMODIFY</a></code></p>

    <p><b id="SCI_GETLINE">SCI_GETLINE(int line, char *text)</b><br />
     This fills the buffer defined by text with the contents of the nominated line (lines start at
    0). The buffer is not terminated by a 0 character. It is up to you to make sure that the buffer
    is long enough for the text, use <a class="message"
    href="#SCI_LINELENGTH"><code>SCI_LINELENGTH(int line)</code></a>. The returned value is the
    number of characters copied to the buffer. The returned text includes any end of line
    characters. If you ask for a line number outside the range of lines in the document, 0
    characters are copied. If the text argument is 0 then the length that should be allocated
    to store the entire line is returned.</p>

    <p>See also: <code><a class="message" href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a
    class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a></code></p>

    <p><b id="SCI_REPLACESEL">SCI_REPLACESEL(&lt;unused&gt;, const char *text)</b><br />
     The currently selected text between the <a class="jump" href="#SelectionAndInformation">anchor
    and the current position</a> is replaced by the 0 terminated text string. If the anchor and
    current position are the same, the text is inserted at the caret position. The caret is
    positioned after the inserted text and the caret is scrolled into view.</p>

    <p><b id="SCI_SETREADONLY">SCI_SETREADONLY(bool readOnly)</b><br />
     <b id="SCI_GETREADONLY">SCI_GETREADONLY</b><br />
     These messages set and get the read-only flag for the document. If you mark a document as read
    only, attempts to modify the text cause the <a class="message"
    href="#SCN_MODIFYATTEMPTRO"><code>SCN_MODIFYATTEMPTRO</code></a> notification.</p>

    <p><b id="SCI_GETTEXTRANGE">SCI_GETTEXTRANGE(&lt;unused&gt;, <a class="jump"
    href="#TextRange">TextRange</a> *tr)</b><br />
     This collects the text between the positions <code>cpMin</code> and <code>cpMax</code> and
    copies it to <code>lpstrText</code> (see <code>struct TextRange</code> in
    <code>Scintilla.h</code>). If <code>cpMax</code> is -1, text is returned to the end of the
    document. The text is 0 terminated, so you must supply a buffer that is at least 1 character
    longer than the number of characters you wish to read. The return value is the length of the
    returned text not including the terminating 0.</p>

    <p>See also: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a></code></p>

    <p><b id="SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT(&lt;unused&gt;, <a class="jump"
    href="#TextRange">TextRange</a> *tr)</b><br />
     This collects styled text into a buffer using two bytes for each cell, with the character at
    the lower address of each pair and the style byte at the upper address. Characters between the
    positions <code>cpMin</code> and <code>cpMax</code> are copied to <code>lpstrText</code> (see
    <code>struct TextRange</code> in <code>Scintilla.h</code>). Two 0 bytes are added to the end of
    the text, so the buffer that <code>lpstrText</code> points at must be at least
    <code>2*(cpMax-cpMin)+2</code> bytes long. No check is made for sensible values of
    <code>cpMin</code> or <code>cpMax</code>. Positions outside the document return character codes
    and style bytes of 0.</p>

    <p>See also: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a></code></p>

    <p><b id="SCI_ALLOCATE">SCI_ALLOCATE(int bytes, &lt;unused&gt;)</b><br />
     Allocate a document buffer large enough to store a given number of bytes.
     The document will not be made smaller than its current contents.</p>

    <p><b id="SCI_ADDTEXT">SCI_ADDTEXT(int length, const char *s)</b><br />
     This inserts the first <code>length</code> characters from the string <code>s</code>
    at the current position. This will include any 0's in the string that you might have expected
    to stop the insert operation. The current position is set at the end of the inserted text,
    but it is not scrolled into view.</p>

    <p><b id="SCI_ADDSTYLEDTEXT">SCI_ADDSTYLEDTEXT(int length, cell *s)</b><br />
     This behaves just like <code>SCI_ADDTEXT</code>, but inserts styled text.</p>

    <p><b id="SCI_APPENDTEXT">SCI_APPENDTEXT(int length, const char *s)</b><br />
     This adds the first <code>length</code> characters from the string <code>s</code> to the end
    of the document. This will include any 0's in the string that you might have expected to stop
    the operation. The current selection is not changed and the new text is not scrolled into
    view.</p>

    <p><b id="SCI_INSERTTEXT">SCI_INSERTTEXT(int pos, const char *text)</b><br />
     This inserts the zero terminated <code>text</code> string at position <code>pos</code> or at
    the current position if <code>pos</code> is -1. If the current position is after the insertion point
    then it is moved along with its surrounding text but no scrolling is performed.</p>

    <p><b id="SCI_CLEARALL">SCI_CLEARALL</b><br />
     Unless the document is read-only, this deletes all the text.</p>

    <p><b id="SCI_CLEARDOCUMENTSTYLE">SCI_CLEARDOCUMENTSTYLE</b><br />
     When wanting to completely restyle the document, for example after choosing a lexer, the
    <code>SCI_CLEARDOCUMENTSTYLE</code> can be used to clear all styling information and reset the
    folding state.</p>

    <p><b id="SCI_GETCHARAT">SCI_GETCHARAT(int pos)</b><br />
     This returns the character at <code>pos</code> in the document or 0 if <code>pos</code> is
    negative or past the end of the document.</p>

    <p><b id="SCI_GETSTYLEAT">SCI_GETSTYLEAT(int pos)</b><br />
     This returns the style at <code>pos</code> in the document, or 0 if <code>pos</code> is
    negative or past the end of the document.</p>

    <p><b id="SCI_SETSTYLEBITS">SCI_SETSTYLEBITS(int bits)</b><br />
     <b id="SCI_GETSTYLEBITS">SCI_GETSTYLEBITS</b><br />
     This pair of routines sets and reads back the number of bits in each cell to use for styling,
    to a maximum of 7 style bits. The remaining bits can be used as indicators. The standard
    setting is <code>SCI_SETSTYLEBITS(5)</code>.
    The number of styling bits needed by the current lexer can be found with
    <a class="message" href="#SCI_GETSTYLEBITSNEEDED">SCI_GETSTYLEBITSNEEDED</a>.</p>

    <p><b id="TextRange">TextRange</b> and <b id="CharacterRange">CharacterRange</b><br />
     These structures are defined to be exactly the same shape as the Win32 <code>TEXTRANGE</code>
    and <code>CHARRANGE</code>, so that older code that treats Scintilla as a RichEdit will
    work.</p>
<pre>
struct CharacterRange {
    long cpMin;
    long cpMax;
};

struct TextRange {
    struct CharacterRange chrg;
    char *lpstrText;
};
</pre>

    <h3 id="EncodedAccess">GTK+-specific: Access to encoded text</h3>

    <p><b id="SCI_TARGETASUTF8">SCI_TARGETASUTF8(&lt;unused&gt;, char *s)</b><br />
     This method retrieves the value of the target encoded as UTF-8 which is the default
     encoding of GTK+ so is useful for retrieving text for use in other parts of the user interface,
     such as find and replace dialogs. The length of the encoded text in bytes is returned.
    </p>

    <p><b id="SCI_ENCODEDFROMUTF8">SCI_ENCODEDFROMUTF8(const char *utf8, char *encoded)</b><br />
     <b id="SCI_SETLENGTHFORENCODE">SCI_SETLENGTHFORENCODE(int bytes)</b><br />
     <code>SCI_ENCODEDFROMUTF8</code> converts a UTF-8 string into the document's
     encoding which is useful for taking the results of a find dialog, for example, and receiving
     a string of bytes that can be searched for in the document. Since the text can contain nul bytes,
     the <code>SCI_SETLENGTHFORENCODE</code> method can be used to set the
     length that will be converted. If set to -1, the length is determined by finding a nul byte.
     The length of the converted string is returned.
    </p>


    <h2 id="Searching">Searching</h2>
    <p>
    There are methods to search for text and for regular expressions. The regular expression support
    is limited and should only be used for simple cases and initial development. A different regular expression
    library can be <a class="jump" href="#AlternativeRegEx">integrated into Scintilla</a>
    or can be called from the container using direct access to the buffer contents through
    <a class="message" href="#SCI_GETCHARACTERPOINTER">SCI_GETCHARACTERPOINTER</a>.
    </p>
    <code><a class="message" href="#SCI_FINDTEXT">SCI_FINDTEXT(int flags, TextToFind
    *ttf)</a><br />
     <a class="message" href="#SCI_SEARCHANCHOR">SCI_SEARCHANCHOR</a><br />
     <a class="message" href="#SCI_SEARCHNEXT">SCI_SEARCHNEXT(int searchFlags, const char
    *text)</a><br />
     <a class="message" href="#SCI_SEARCHPREV">SCI_SEARCHPREV(int searchFlags, const char
    *text)</a><br />
     <a class="jump" href="#SearchAndReplaceUsingTheTarget">Search and replace using the
    target</a><br />
    </code>

    <p><b id="searchFlags"><code>searchFlags</code></b><br />
     Several of the search routines use flag options, which include a simple regular expression
    search. Combine the flag options by adding them:</p>

    <table border="0" summary="Search flags">
      <tbody>
        <tr>
          <td><code>SCFIND_MATCHCASE</code></td>

          <td>A match only occurs with text that matches the case of the search string.</td>
        </tr>

        <tr>
          <td><code>SCFIND_WHOLEWORD</code></td>

          <td>A match only occurs if the characters before and after are not word characters.</td>
        </tr>

        <tr>
          <td><code>SCFIND_WORDSTART</code></td>

          <td>A match only occurs if the character before is not a word character.</td>
        </tr>

        <tr>
          <td><code>SCFIND_REGEXP</code></td>

          <td>The search string should be interpreted as a regular expression.</td>
        </tr>
        <tr>
          <td><code>SCFIND_POSIX</code></td>

          <td>Treat regular expression in a more POSIX compatible manner
            by interpreting bare ( and ) for tagged sections rather than \( and \).</td>
        </tr>
      </tbody>
    </table>

    <p>If <code>SCFIND_REGEXP</code> is not included in the <code>searchFlags</code>, you can
    search backwards to find the previous occurrence of a search string by setting the end of the
    search range before the start. If <code>SCFIND_REGEXP</code> is included, searches are always
    from a lower position to a higher position, even if the search range is backwards.</p>

    <p>In a regular expression, special characters interpreted are:</p>

    <table border="0" summary="Regular expression synopsis">
      <tbody>
        <tr>
          <td><code>.</code></td>

          <td>Matches any character</td>
        </tr>

        <tr>
          <td><code>\(</code></td>

          <td>This marks the start of a region for tagging a match.</td>
        </tr>

        <tr>
          <td><code>\)</code></td>

          <td>This marks the end of a tagged region.</td>
        </tr>

        <tr>
          <td><code>\n</code></td>

          <td>Where <code>n</code> is 1 through 9 refers to the first through ninth tagged region
          when replacing. For example, if the search string was <code>Fred\([1-9]\)XXX</code> and
          the replace string was <code>Sam\1YYY</code>, when applied to <code>Fred2XXX</code> this
          would generate <code>Sam2YYY</code>.</td>
        </tr>

        <tr>
          <td><code>\&lt;</code></td>

          <td>This matches the start of a word using Scintilla's definitions of words.</td>
        </tr>

        <tr>
          <td><code>\&gt;</code></td>

          <td>This matches the end of a word using Scintilla's definition of words.</td>
        </tr>

        <tr>
          <td><code>\x</code></td>

          <td>This allows you to use a character x that would otherwise have a special meaning. For
          example, \[ would be interpreted as [ and not as the start of a character set.</td>
        </tr>

        <tr>
          <td><code>[...]</code></td>

          <td>This indicates a set of characters, for example, [abc] means any of the characters a,
          b or c. You can also use ranges, for example [a-z] for any lower case character.</td>
        </tr>

        <tr>
          <td><code>[^...]</code></td>

          <td>The complement of the characters in the set. For example, [^A-Za-z] means any
          character except an alphabetic character.</td>
        </tr>

        <tr>
          <td><code>^</code></td>

          <td>This matches the start of a line (unless used inside a set, see above).</td>
        </tr>

        <tr>
          <td><code>$</code></td>

          <td>This matches the end of a line.</td>
        </tr>

        <tr>
          <td><code>*</code></td>

          <td>This matches 0 or more times. For example, <code>Sa*m</code> matches <code>Sm</code>,
          <code>Sam</code>, <code>Saam</code>, <code>Saaam</code> and so on.</td>
        </tr>

        <tr>
          <td><code>+</code></td>

          <td>This matches 1 or more times. For example, <code>Sa+m</code> matches
          <code>Sam</code>, <code>Saam</code>, <code>Saaam</code> and so on.</td>
        </tr>
      </tbody>
    </table>

    <p><b id="SCI_FINDTEXT">SCI_FINDTEXT(int searchFlags, <a class="jump"
    href="#TextToFind">TextToFind</a> *ttf)</b><br />
     This message searches for text in the document. It does not use or move the current selection.
    The <a class="jump" href="#searchFlags"><code>searchFlags</code></a> argument controls the
    search type, which includes regular expression searches.</p>

    <p>The <code>TextToFind</code> structure is defined in <code>Scintilla.h</code>; set
    <code>chrg.cpMin</code> and <code>chrg.cpMax</code> with the range of positions in the document
    to search. If <code>SCFIND_REGEXP</code> is not included in the flags, you can search backwards by
    setting <code>chrg.cpMax</code> less than <code>chrg.cpMin</code>. If <code>SCFIND_REGEXP</code>
    is included, the search is always forwards (even if <code>chrg.cpMax</code> is less than <code>chrg.cpMin</code>).
    Set the <code>lpstrText</code> member of <code>TextToFind</code> to point at a zero terminated
    text string holding the search pattern. If your language makes the use of <code>TextToFind</code>
    difficult, you should consider using <code>SCI_SEARCHINTARGET</code> instead.</p>

    <p>The return value is -1 if the search fails or the position of the start of the found text if
    it succeeds. The <code>chrgText.cpMin</code> and <code>chrgText.cpMax</code> members of
    <code>TextToFind</code> are filled in with the start and end positions of the found text.</p>

    <p>See also: <code><a class="message"
    href="#SCI_SEARCHINTARGET">SCI_SEARCHINTARGET</a></code></p>

    <p><b id="TextToFind">TextToFind</b><br />
     This structure is defined to have exactly the same shape as the Win32 structure
    <code>FINDTEXTEX</code> for old code that treated Scintilla as a RichEdit control.</p>
<pre>
struct TextToFind {
    struct <a class="jump" href="#CharacterRange">CharacterRange</a> chrg;     // range to search
    char *lpstrText;                // the search pattern (zero terminated)
    struct CharacterRange chrgText; // returned as position of matching text
};
</pre>

    <p><b id="SCI_SEARCHANCHOR">SCI_SEARCHANCHOR</b><br />
     <b id="SCI_SEARCHNEXT">SCI_SEARCHNEXT(int searchFlags, const char *text)</b><br />
     <b id="SCI_SEARCHPREV">SCI_SEARCHPREV(int searchFlags, const char *text)</b><br />
     These messages provide relocatable search support. This allows multiple incremental
    interactive searches to be macro recorded while still setting the selection to found text so
    the find/select operation is self-contained. These three messages send <a class="message"
    href="#SCN_MACRORECORD"><code>SCN_MACRORECORD</code></a> <a class="jump"
    href="#Notifications">notifications</a> if macro recording is enabled.</p>

    <p><code>SCI_SEARCHANCHOR</code> sets the search start point used by
    <code>SCI_SEARCHNEXT</code> and <code>SCI_SEARCHPREV</code> to the start of the current
    selection, that is, the end of the selection that is nearer to the start of the document. You
    should always call this before calling either of <code>SCI_SEARCHNEXT</code> or
    <code>SCI_SEARCHPREV</code>.</p>

    <p><code>SCI_SEARCHNEXT</code> and <code>SCI_SEARCHPREV</code> search for the next and previous
    occurrence of the zero terminated search string pointed at by text. The search is modified by
    the <a class="jump" href="#searchFlags"><code>searchFlags</code></a>. If you request a regular
    expression, <code>SCI_SEARCHPREV</code> finds the first occurrence of the search string in the
    document, not the previous one before the anchor point.</p>

    <p>The return value is -1 if nothing is found, otherwise the return value is the start position
    of the matching text. The selection is updated to show the matched text, but is not scrolled
    into view.</p>

    <p>See also: <a class="message" href="#SCI_SEARCHINTARGET"><code>SCI_SEARCHINTARGET</code></a>,
    <a class="message" href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a></p>

    <h3 id="SearchAndReplaceUsingTheTarget">Search and replace using the target</h3>

    <p>Using <a class="message" href="#SCI_REPLACESEL"><code>SCI_REPLACESEL</code></a>,
    modifications cause scrolling and other visible changes, which may take some time and cause
    unwanted display updates. If performing many changes, such as a replace all command, the target
    can be used instead. First, set the target, ie. the range to be replaced. Then call
    <code>SCI_REPLACETARGET</code> or <code>SCI_REPLACETARGETRE</code>.</p>

    <p>Searching can be performed within the target range with <code>SCI_SEARCHINTARGET</code>,
    which uses a counted string to allow searching for null characters. It returns the length of
    range or -1 for failure, in which case the target is not moved. The flags used by
    <code>SCI_SEARCHINTARGET</code> such as <code>SCFIND_MATCHCASE</code>,
    <code>SCFIND_WHOLEWORD</code>, <code>SCFIND_WORDSTART</code>, and <code>SCFIND_REGEXP</code>
    can be set with <code>SCI_SETSEARCHFLAGS</code>. <code>SCI_SEARCHINTARGET</code> may be simpler
    for some clients to use than <a class="message"
    href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a>, as that requires using a pointer to a
    structure.</p>
    <code><a class="message" href="#SCI_SETTARGETSTART">SCI_SETTARGETSTART(int pos)</a><br />
     <a class="message" href="#SCI_GETTARGETSTART">SCI_GETTARGETSTART</a><br />
     <a class="message" href="#SCI_SETTARGETEND">SCI_SETTARGETEND(int pos)</a><br />
     <a class="message" href="#SCI_GETTARGETEND">SCI_GETTARGETEND</a><br />
     <a class="message" href="#SCI_TARGETFROMSELECTION">SCI_TARGETFROMSELECTION</a><br />
     <a class="message" href="#SCI_SETSEARCHFLAGS">SCI_SETSEARCHFLAGS(int searchFlags)</a><br />
     <a class="message" href="#SCI_GETSEARCHFLAGS">SCI_GETSEARCHFLAGS</a><br />
     <a class="message" href="#SCI_SEARCHINTARGET">SCI_SEARCHINTARGET(int length, const char
    *text)</a><br />
     <a class="message" href="#SCI_REPLACETARGET">SCI_REPLACETARGET(int length, const char
    *text)</a><br />
     <a class="message" href="#SCI_REPLACETARGETRE">SCI_REPLACETARGETRE(int length, const char
    *text)</a><br />
    </code>

    <p><b id="SCI_SETTARGETSTART">SCI_SETTARGETSTART(int pos)</b><br />
     <b id="SCI_GETTARGETSTART">SCI_GETTARGETSTART</b><br />
     <b id="SCI_SETTARGETEND">SCI_SETTARGETEND(int pos)</b><br />
     <b id="SCI_GETTARGETEND">SCI_GETTARGETEND</b><br />
     These functions set and return the start and end of the target. When searching in non-regular
    expression mode, you can set start greater than end to find the last matching text in the
    target rather than the first matching text. The target is also set by a successful
    <code>SCI_SEARCHINTARGET</code>.</p>

     <p><b id="SCI_TARGETFROMSELECTION">SCI_TARGETFROMSELECTION</b><br />
     Set the target start and end to the start and end positions of the selection.</p>

    <p><b id="SCI_SETSEARCHFLAGS">SCI_SETSEARCHFLAGS(int searchFlags)</b><br />
     <b id="SCI_GETSEARCHFLAGS">SCI_GETSEARCHFLAGS</b><br />
     These get and set the <a class="jump" href="#searchFlags"><code>searchFlags</code></a> used by
    <code>SCI_SEARCHINTARGET</code>. There are several option flags including a simple regular
    expression search.</p>

    <p><b id="SCI_SEARCHINTARGET">SCI_SEARCHINTARGET(int length, const char *text)</b><br />
     This searches for the first occurrence of a text string in the target defined by
    <code>SCI_SETTARGETSTART</code> and <code>SCI_SETTARGETEND</code>. The text string is not zero
    terminated; the size is set by <code>length</code>. The search is modified by the search flags
    set by <code>SCI_SETSEARCHFLAGS</code>. If the search succeeds, the target is set to the found
    text and the return value is the position of the start of the matching text. If the search
    fails, the result is -1.</p>

    <p><b id="SCI_REPLACETARGET">SCI_REPLACETARGET(int length, const char *text)</b><br />
     If <code>length</code> is -1, <code>text</code> is a zero terminated string, otherwise
    <code>length</code> sets the number of character to replace the target with.
           After replacement, the target range refers to the replacement text.
           The return value
    is the length of the replacement string.<br />
    Note that the recommended way to delete text in the document is to set the target to the text to be removed,
    and to perform a replace target with an empty string.</p>

    <p><b id="SCI_REPLACETARGETRE">SCI_REPLACETARGETRE(int length, const char *text)</b><br />
     This replaces the target using regular expressions. If <code>length</code> is -1,
    <code>text</code> is a zero terminated string, otherwise <code>length</code> is the number of
    characters to use. The replacement string is formed from the text string with any sequences of
    <code>\1</code> through <code>\9</code> replaced by tagged matches from the most recent regular
    expression search.
           After replacement, the target range refers to the replacement text.
           The return value is the length of the replacement string.</p>

    <p>See also: <a class="message" href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a></p>

    <h2 id="Overtype">Overtype</h2>

    <p><b id="SCI_SETOVERTYPE">SCI_SETOVERTYPE(bool overType)</b><br />
     <b id="SCI_GETOVERTYPE">SCI_GETOVERTYPE</b><br />
     When overtype is enabled, each typed character replaces the character to the right of the text
    caret. When overtype is disabled, characters are inserted at the caret.
    <code>SCI_GETOVERTYPE</code> returns <code>TRUE</code> (1) if overtyping is active, otherwise
    <code>FALSE</code> (0) will be returned. Use <code>SCI_SETOVERTYPE</code> to set the overtype
    mode.</p>

    <h2 id="CutCopyAndPaste">Cut, copy and paste</h2>

    <code><a class="message" href="#SCI_CUT">SCI_CUT</a><br />
     <a class="message" href="#SCI_COPY">SCI_COPY</a><br />
     <a class="message" href="#SCI_PASTE">SCI_PASTE</a><br />
     <a class="message" href="#SCI_CLEAR">SCI_CLEAR</a><br />
     <a class="message" href="#SCI_CANPASTE">SCI_CANPASTE</a><br />
     <a class="message" href="#SCI_COPYRANGE">SCI_COPYRANGE(int start, int end)</a><br />
     <a class="message" href="#SCI_COPYTEXT">SCI_COPYTEXT(int length,
     const char *text)</a><br />
     <a class="message" href="#SCI_COPYALLOWLINE">SCI_COPYALLOWLINE</a><br />
     <a class="message" href="#SCI_SETPASTECONVERTENDINGS">SCI_SETPASTECONVERTENDINGS(bool convert)</a><br />
     <a class="message" href="#SCI_GETPASTECONVERTENDINGS">SCI_GETPASTECONVERTENDINGS</a><br />
    </code>

    <p><b id="SCI_CUT">SCI_CUT</b><br />
     <b id="SCI_COPY">SCI_COPY</b><br />
     <b id="SCI_PASTE">SCI_PASTE</b><br />
     <b id="SCI_CLEAR">SCI_CLEAR</b><br />
     <b id="SCI_CANPASTE">SCI_CANPASTE</b><br />
     <b id="SCI_COPYALLOWLINE">SCI_COPYALLOWLINE</b><br />
     These commands perform the standard tasks of cutting and copying data to the clipboard,
    pasting from the clipboard into the document, and clearing the document.
    <code>SCI_CANPASTE</code> returns non-zero if the document isn't read-only and if the selection
    doesn't contain protected text. If you need a "can copy" or "can cut", use
    <code>SCI_GETSELECTIONSTART()-SCI_GETSELECTIONEND()</code>, which will be non-zero if you can
    copy or cut to the clipboard.</p>

    <p>GTK+ does not really support <code>SCI_CANPASTE</code> and always returns <code>TRUE</code>
    unless the document is read-only.</p>

    <p>On X, the clipboard is asynchronous and may require several messages between
    the destination and source applications. Data from SCI_PASTE will not arrive in the
    document immediately.</p>

    <p><code>SCI_COPYALLOWLINE</code> works the same as SCI_COPY except that if the
    selection is empty then the current line is copied. On Windows, an extra "MSDEVLineSelect" marker
    is added to the clipboard which is then used in <code>SCI_PASTE</code> to paste
    the whole line before the current line.</p>

     <b id="SCI_COPYRANGE">SCI_COPYRANGE(int start, int end)</b><br />
     <b id="SCI_COPYTEXT">SCI_COPYTEXT(int length, const char *text)</b><br />
    <p><code>SCI_COPYRANGE</code> copies a range of text from the document to
    the system clipboard and <code>SCI_COPYTEXT</code> copies a supplied piece of
    text to the system clipboard.</p>

    <p><b id="SCI_SETPASTECONVERTENDINGS">SCI_SETPASTECONVERTENDINGS(bool convert)</b><br />
     <b id="SCI_GETPASTECONVERTENDINGS">SCI_GETPASTECONVERTENDINGS</b><br />
     If this property is set then when text is pasted any line ends are converted to match the document's
     end of line mode as set with
     <a class="message" href="#SCI_SETEOLMODE">SCI_SETEOLMODE</a>.
     Currently only changeable on Windows. On GTK+ pasted text is always converted.</p>

    <h2 id="ErrorHandling">Error handling</h2>

    <p><b id="SCI_SETSTATUS">SCI_SETSTATUS(int status)</b><br />
     <b id="SCI_GETSTATUS">SCI_GETSTATUS</b><br />
     If an error occurs, Scintilla may set an internal error number that can be retrieved with
    <code>SCI_GETSTATUS</code>. Not currently used but will be in the future. To clear the error
    status call <code>SCI_SETSTATUS(0)</code>.</p>

    <h2 id="UndoAndRedo">Undo and Redo</h2>

    <p>Scintilla has multiple level undo and redo. It will continue to collect undoable actions
    until memory runs out. Scintilla saves actions that change the document. Scintilla does not
    save caret and selection movements, view scrolling and the like. Sequences of typing or
    deleting are compressed into single transactions to make it easier to undo and redo at a sensible
    level of detail. Sequences of actions can be combined into transactions that are undone as a unit.
    These sequences occur between <code>SCI_BEGINUNDOACTION</code> and
    <code>SCI_ENDUNDOACTION</code> messages. These transactions can be nested and only the top-level
    sequences are undone as units.</p>
    <code><a class="message" href="#SCI_UNDO">SCI_UNDO</a><br />
     <a class="message" href="#SCI_CANUNDO">SCI_CANUNDO</a><br />
     <a class="message" href="#SCI_EMPTYUNDOBUFFER">SCI_EMPTYUNDOBUFFER</a><br />
     <a class="message" href="#SCI_REDO">SCI_REDO</a><br />
     <a class="message" href="#SCI_CANREDO">SCI_CANREDO</a><br />
     <a class="message" href="#SCI_SETUNDOCOLLECTION">SCI_SETUNDOCOLLECTION(bool
    collectUndo)</a><br />
     <a class="message" href="#SCI_GETUNDOCOLLECTION">SCI_GETUNDOCOLLECTION</a><br />
     <a class="message" href="#SCI_BEGINUNDOACTION">SCI_BEGINUNDOACTION</a><br />
     <a class="message" href="#SCI_ENDUNDOACTION">SCI_ENDUNDOACTION</a><br />
     <a class="message" href="#SCI_ADDUNDOACTION">SCI_ADDUNDOACTION(int token, int flags)</a><br />
    </code>

    <p><b id="SCI_UNDO">SCI_UNDO</b><br />
     <b id="SCI_CANUNDO">SCI_CANUNDO</b><br />
     <code>SCI_UNDO</code> undoes one action, or if the undo buffer has reached a
    <code>SCI_ENDUNDOACTION</code> point, all the actions back to the corresponding
    <code>SCI_BEGINUNDOACTION</code>.</p>

    <p><code>SCI_CANUNDO</code> returns 0 if there is nothing to undo, and 1 if there is. You would
    typically use the result of this message to enable/disable the Edit menu Undo command.</p>

    <p><b id="SCI_REDO">SCI_REDO</b><br />
     <b id="SCI_CANREDO">SCI_CANREDO</b><br />
     <code>SCI_REDO</code> undoes the effect of the last <code>SCI_UNDO</code> operation.</p>

    <p><code>SCI_CANREDO</code> returns 0 if there is no action to redo and 1 if there are undo
    actions to redo. You could typically use the result of this message to enable/disable the Edit
    menu Redo command.</p>

    <p><b id="SCI_EMPTYUNDOBUFFER">SCI_EMPTYUNDOBUFFER</b><br />
     This command tells Scintilla to forget any saved undo or redo history. It also sets the save
    point to the start of the undo buffer, so the document will appear to be unmodified. This does
    not cause the <code><a class="message"
    href="#SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</a></code> notification to be sent to the
    container.</p>

    <p>See also: <a class="message" href="#SCI_SETSAVEPOINT"><code>SCI_SETSAVEPOINT</code></a></p>

    <p><b id="SCI_SETUNDOCOLLECTION">SCI_SETUNDOCOLLECTION(bool collectUndo)</b><br />
     <b id="SCI_GETUNDOCOLLECTION">SCI_GETUNDOCOLLECTION</b><br />
     You can control whether Scintilla collects undo information with
    <code>SCI_SETUNDOCOLLECTION</code>. Pass in <code>true</code> (1) to collect information and
    <code>false</code> (0) to stop collecting. If you stop collection, you should also use
    <code>SCI_EMPTYUNDOBUFFER</code> to avoid the undo buffer being unsynchronized with the data in
    the buffer.</p>

    <p>You might wish to turn off saving undo information if you use the Scintilla to store text
    generated by a program (a Log view) or in a display window where text is often deleted and
    regenerated.</p>

    <p><b id="SCI_BEGINUNDOACTION">SCI_BEGINUNDOACTION</b><br />
     <b id="SCI_ENDUNDOACTION">SCI_ENDUNDOACTION</b><br />
     Send these two messages to Scintilla to mark the beginning and end of a set of operations that
    you want to undo all as one operation but that you have to generate as several operations.
    Alternatively, you can use these to mark a set of operations that you do not want to have
    combined with the preceding or following operations if they are undone.</p>

    <p><b id="SCI_ADDUNDOACTION">SCI_ADDUNDOACTION(int token, int flags)</b><br />
     The container can add its own actions into the undo stack by calling 
     <code>SCI_ADDUNDOACTION</code> and an <code>SCN_MODIFIED</code> 
     notification will be sent to the container with the 
     <a class="message" href="#SC_MOD_CONTAINER"><code>SC_MOD_CONTAINER</code></a>
     flag when it is time to undo (<code>SC_PERFORMED_UNDO</code>) or 
     redo (<code>SC_PERFORMED_REDO</code>) the action. The token argument supplied is 
     returned in the <code>token</code> field of the notification.</p>
     <p>For example, if the container wanted to allow undo and redo of a 'toggle bookmark' command then
     it could call <code>SCI_ADDUNDOACTION(line, 0)</code> each time the command is performed.
     Then when it receives a notification to undo or redo it toggles a bookmark on the line given by
     the token field. If there are different types of commands or parameters that need to be stored into the undo
     stack then the container should maintain a stack of its own for the document and use the current
     position in that stack as the argument to <code>SCI_ADDUNDOACTION(line)</code>.
     <code>SCI_ADDUNDOACTION</code> commands are not combined together 
     into a single undo transaction unless grouped with <code>SCI_BEGINUNDOACTION</code>
     and <code>SCI_ENDUNDOACTION</code>.</p>

     <p>The flags argument can be <code>UNDO_MAY_COALESCE</code> (1) if the container action may be 
     coalesced along with any insertion and deletion actions into a single compound action, otherwise 0.
     Coalescing treats coalescible container actions as transparent so will still only group together insertions that 
     look like typing or deletions that look like multiple uses of the Backspace or Delete keys.
     </p>
    <h2 id="SelectionAndInformation">Selection and information</h2>

    <p>Scintilla maintains a selection that stretches between two points, the anchor and the
    current position. If the anchor and the current position are the same, there is no selected
    text. Positions in the document range from 0 (before the first character), to the document size
    (after the last character). If you use messages, there is nothing to stop you setting a
    position that is in the middle of a CRLF pair, or in the middle of a 2 byte character. However,
    keyboard commands will not move the caret into such positions.</p>
    <code><a class="message" href="#SCI_GETTEXTLENGTH">SCI_GETTEXTLENGTH</a><br />
     <a class="message" href="#SCI_GETLENGTH">SCI_GETLENGTH</a><br />
     <a class="message" href="#SCI_GETLINECOUNT">SCI_GETLINECOUNT</a><br />
     <a class="message" href="#SCI_GETFIRSTVISIBLELINE">SCI_GETFIRSTVISIBLELINE</a><br />
     <a class="message" href="#SCI_LINESONSCREEN">SCI_LINESONSCREEN</a><br />
     <a class="message" href="#SCI_GETMODIFY">SCI_GETMODIFY</a><br />
     <a class="message" href="#SCI_SETSEL">SCI_SETSEL(int anchorPos, int currentPos)</a><br />
     <a class="message" href="#SCI_GOTOPOS">SCI_GOTOPOS(int position)</a><br />
     <a class="message" href="#SCI_GOTOLINE">SCI_GOTOLINE(int line)</a><br />
     <a class="message" href="#SCI_SETCURRENTPOS">SCI_SETCURRENTPOS(int position)</a><br />
     <a class="message" href="#SCI_GETCURRENTPOS">SCI_GETCURRENTPOS</a><br />
     <a class="message" href="#SCI_SETANCHOR">SCI_SETANCHOR(int position)</a><br />
     <a class="message" href="#SCI_GETANCHOR">SCI_GETANCHOR</a><br />
     <a class="message" href="#SCI_SETSELECTIONSTART">SCI_SETSELECTIONSTART(int position)</a><br />
     <a class="message" href="#SCI_GETSELECTIONSTART">SCI_GETSELECTIONSTART</a><br />
     <a class="message" href="#SCI_SETSELECTIONEND">SCI_SETSELECTIONEND(int position)</a><br />
     <a class="message" href="#SCI_GETSELECTIONEND">SCI_GETSELECTIONEND</a><br />
     <a class="message" href="#SCI_SELECTALL">SCI_SELECTALL</a><br />
     <a class="message" href="#SCI_LINEFROMPOSITION">SCI_LINEFROMPOSITION(int position)</a><br />
     <a class="message" href="#SCI_POSITIONFROMLINE">SCI_POSITIONFROMLINE(int line)</a><br />
     <a class="message" href="#SCI_GETLINEENDPOSITION">SCI_GETLINEENDPOSITION(int line)</a><br />
     <a class="message" href="#SCI_LINELENGTH">SCI_LINELENGTH(int line)</a><br />
     <a class="message" href="#SCI_GETCOLUMN">SCI_GETCOLUMN(int position)</a><br />
     <a class="message" href="#SCI_FINDCOLUMN">SCI_FINDCOLUMN(int line, int column)</a><br />
     <a class="message" href="#SCI_POSITIONFROMPOINT">SCI_POSITIONFROMPOINT(int x, int y)</a><br />
     <a class="message" href="#SCI_POSITIONFROMPOINTCLOSE">SCI_POSITIONFROMPOINTCLOSE(int x, int
    y)</a><br />
     <a class="message" href="#SCI_POINTXFROMPOSITION">SCI_POINTXFROMPOSITION(&lt;unused&gt;, int
    position)</a><br />
     <a class="message" href="#SCI_POINTYFROMPOSITION">SCI_POINTYFROMPOSITION(&lt;unused&gt;, int
    position)</a><br />
     <a class="message" href="#SCI_HIDESELECTION">SCI_HIDESELECTION(bool hide)</a><br />
     <a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT(&lt;unused&gt;, char *text)</a><br />
     <a class="message" href="#SCI_GETCURLINE">SCI_GETCURLINE(int textLen, char *text)</a><br />
     <a class="message" href="#SCI_SELECTIONISRECTANGLE">SCI_SELECTIONISRECTANGLE</a><br />
     <a class="message" href="#SCI_SETSELECTIONMODE">SCI_SETSELECTIONMODE(int mode)</a><br />
     <a class="message" href="#SCI_GETSELECTIONMODE">SCI_GETSELECTIONMODE</a><br />
     <a class="message" href="#SCI_GETLINESELSTARTPOSITION">SCI_GETLINESELSTARTPOSITION(int line)</a><br />
     <a class="message" href="#SCI_GETLINESELENDPOSITION">SCI_GETLINESELENDPOSITION(int line)</a><br />
     <a class="message" href="#SCI_MOVECARETINSIDEVIEW">SCI_MOVECARETINSIDEVIEW</a><br />
     <a class="message" href="#SCI_WORDENDPOSITION">SCI_WORDENDPOSITION(int position, bool
    onlyWordCharacters)</a><br />
     <a class="message" href="#SCI_WORDSTARTPOSITION">SCI_WORDSTARTPOSITION(int position, bool
    onlyWordCharacters)</a><br />
     <a class="message" href="#SCI_POSITIONBEFORE">SCI_POSITIONBEFORE(int position)</a><br />
     <a class="message" href="#SCI_POSITIONAFTER">SCI_POSITIONAFTER(int position)</a><br />
     <a class="message" href="#SCI_TEXTWIDTH">SCI_TEXTWIDTH(int styleNumber, const char *text)</a><br />
     <a class="message" href="#SCI_TEXTHEIGHT">SCI_TEXTHEIGHT(int line)</a><br />
     <a class="message" href="#SCI_CHOOSECARETX">SCI_CHOOSECARETX</a><br />
    </code>

    <p><b id="SCI_GETTEXTLENGTH">SCI_GETTEXTLENGTH</b><br />
     <b id="SCI_GETLENGTH">SCI_GETLENGTH</b><br />
     Both these messages return the length of the document in bytes.</p>

    <p><b id="SCI_GETLINECOUNT">SCI_GETLINECOUNT</b><br />
     This returns the number of lines in the document. An empty document contains 1 line. A
    document holding only an end of line sequence has 2 lines.</p>

    <p><b id="SCI_GETFIRSTVISIBLELINE">SCI_GETFIRSTVISIBLELINE</b><br />
     This returns the line number of the first visible line in the Scintilla view. The first line
    in the document is numbered 0. The value is a visible line rather than a document line.</p>

    <p><b id="SCI_LINESONSCREEN">SCI_LINESONSCREEN</b><br />
     This returns the number of complete lines visible on the screen. With a constant line height,
    this is the vertical space available divided by the line separation. Unless you arrange to size
    your window to an integral number of lines, there may be a partial line visible at the bottom
    of the view.</p>

    <p><b id="SCI_GETMODIFY">SCI_GETMODIFY</b><br />
     This returns non-zero if the document is modified and 0 if it is unmodified. The modified
    status of a document is determined by the undo position relative to the save point. The save
    point is set by <a class="message" href="#SCI_SETSAVEPOINT"><code>SCI_SETSAVEPOINT</code></a>,
    usually when you have saved data to a file.</p>

    <p>If you need to be notified when the document becomes modified, Scintilla notifies the
    container that it has entered or left the save point with the <a class="message"
    href="#SCN_SAVEPOINTREACHED"><code>SCN_SAVEPOINTREACHED</code></a> and <a class="message"
    href="#SCN_SAVEPOINTLEFT"><code>SCN_SAVEPOINTLEFT</code></a> <a class="jump"
    href="#Notifications">notification messages</a>.</p>

    <p><b id="SCI_SETSEL">SCI_SETSEL(int anchorPos, int currentPos)</b><br />
     This message sets both the anchor and the current position. If <code>currentPos</code> is
    negative, it means the end of the document. If <code>anchorPos</code> is negative, it means
    remove any selection (i.e. set the anchor to the same position as <code>currentPos</code>). The
    caret is scrolled into view after this operation.</p>

    <p><b id="SCI_GOTOPOS">SCI_GOTOPOS(int pos)</b><br />
     This removes any selection, sets the caret at <code>pos</code> and scrolls the view to make
    the caret visible, if necessary. It is equivalent to
    <code>SCI_SETSEL(pos, pos)</code>. The anchor position is set the same as the current
    position.</p>

    <p><b id="SCI_GOTOLINE">SCI_GOTOLINE(int line)</b><br />
     This removes any selection and sets the caret at the start of line number <code>line</code>
    and scrolls the view (if needed) to make it visible. The anchor position is set the same as the
    current position. If <code>line</code> is outside the lines in the document (first line is 0),
    the line set is the first or last.</p>

    <p><b id="SCI_SETCURRENTPOS">SCI_SETCURRENTPOS(int pos)</b><br />
     This sets the current position and creates a selection between the anchor and the current
    position. The caret is not scrolled into view.</p>

    <p>See also: <a class="message" href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a></p>

    <p><b id="SCI_GETCURRENTPOS">SCI_GETCURRENTPOS</b><br />
     This returns the current position.</p>

    <p><b id="SCI_SETANCHOR">SCI_SETANCHOR(int pos)</b><br />
     This sets the anchor position and creates a selection between the anchor position and the
    current position. The caret is not scrolled into view.</p>

    <p>See also: <a class="message" href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a></p>

    <p><b id="SCI_GETANCHOR">SCI_GETANCHOR</b><br />
     This returns the current anchor position.</p>

    <p><b id="SCI_SETSELECTIONSTART">SCI_SETSELECTIONSTART(int pos)</b><br />
     <b id="SCI_SETSELECTIONEND">SCI_SETSELECTIONEND(int pos)</b><br />
     These set the selection based on the assumption that the anchor position is less than the
    current position. They do not make the caret visible. The table shows the positions of the
    anchor and the current position after using these messages.</p>

    <table cellpadding="3" cellspacing="0" border="1" summary="SetSelection caret positioning">
      <thead align="center">
        <tr>
          <th>
          </th>

          <th>anchor</th>

          <th>current</th>
        </tr>
      </thead>

      <tbody align="center">
        <tr>
          <th><code>SCI_SETSELECTIONSTART</code></th>

          <td><code>pos</code></td>

          <td><code>Max(pos, current)</code></td>
        </tr>

        <tr>
          <th><code>SCI_SETSELECTIONEND</code></th>

          <td><code>Min(anchor, pos)</code></td>

          <td><code>pos</code></td>
        </tr>
      </tbody>
    </table>

    <p>See also: <a class="message" href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a></p>

    <p><b id="SCI_GETSELECTIONSTART">SCI_GETSELECTIONSTART</b><br />
     <b id="SCI_GETSELECTIONEND">SCI_GETSELECTIONEND</b><br />
     These return the start and end of the selection without regard to which end is the current
    position and which is the anchor. <code>SCI_GETSELECTIONSTART</code> returns the smaller of the
    current position or the anchor position. <code>SCI_GETSELECTIONEND</code> returns the larger of
    the two values.</p>

    <p><b id="SCI_SELECTALL">SCI_SELECTALL</b><br />
     This selects all the text in the document. The current position is not scrolled into view.</p>

    <p><b id="SCI_LINEFROMPOSITION">SCI_LINEFROMPOSITION(int pos)</b><br />
     This message returns the line that contains the position <code>pos</code> in the document. The
    return value is 0 if <code>pos</code> &lt;= 0. The return value is the last line if
    <code>pos</code> is beyond the end of the document.</p>

    <p><b id="SCI_POSITIONFROMLINE">SCI_POSITIONFROMLINE(int line)</b><br />
     This returns the document position that corresponds with the start of the line. If
    <code>line</code> is negative, the position of the line holding the start of the selection is
    returned. If <code>line</code> is greater than the lines in the document, the return value is
    -1. If <code>line</code> is equal to the number of lines in the document (i.e. 1 line past the
    last line), the return value is the end of the document.</p>

    <p><b id="SCI_GETLINEENDPOSITION">SCI_GETLINEENDPOSITION(int line)</b><br />
     This returns the position at the end of the line, before any line end characters. If <code>line</code>
    is the last line in the document (which does not have any end of line characters), the result is the size of the
    document. If <code>line</code> is negative or <code>line</code> &gt;= <a class="message"
    href="#SCI_GETLINECOUNT"><code>SCI_GETLINECOUNT()</code></a>, the result is undefined.</p>

    <p><b id="SCI_LINELENGTH">SCI_LINELENGTH(int line)</b><br />
     This returns the length of the line, including any line end characters. If <code>line</code>
    is negative or beyond the last line in the document, the result is 0. If you want the length of
    the line not including any end of line characters, use <a class="message"
    href="#SCI_GETLINEENDPOSITION"><code>SCI_GETLINEENDPOSITION(line)</code></a> - <a class="message"
    href="#SCI_POSITIONFROMLINE"><code>SCI_POSITIONFROMLINE(line)</code></a>.</p>
    <b id="SCI_GETSELTEXT">SCI_GETSELTEXT(&lt;unused&gt;, char *text)</b><br />
     This copies the currently selected text and a terminating 0 byte to the <code>text</code>
    buffer. The buffer must be at least
    <code>SCI_GETSELECTIONEND()-SCI_GETSELECTIONSTART()+1</code> bytes long. <br />
    If the text argument is 0 then the length that should be allocated
    to store the entire selection is returned.<br />

    <p>See also: <code><a class="message" href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a></code></p>

    <p><b id="SCI_GETCURLINE">SCI_GETCURLINE(int textLen, char *text)</b><br />
     This retrieves the text of the line containing the caret and returns the position within the
    line of the caret. Pass in <code>char* text</code> pointing at a buffer large enough to hold
    the text you wish to retrieve and a terminating 0 character.
    Set <code>textLen</code> to the
    length of the buffer which must be at least 1 to hold the terminating 0 character.
    If the text argument is 0 then the length that should be allocated
    to store the entire current line is returned.</p>

    <p>See also: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a></code></p>

    <p><b id="SCI_SELECTIONISRECTANGLE">SCI_SELECTIONISRECTANGLE</b><br />
     This returns 1 if the current selection is in rectangle mode, 0 if not.</p>

    <p><b id="SCI_SETSELECTIONMODE">SCI_SETSELECTIONMODE(int mode)</b><br />
    <b id="SCI_GETSELECTIONMODE">SCI_GETSELECTIONMODE</b><br />
    The two functions set and get the selection mode, which can be
     stream (<code>SC_SEL_STREAM</code>=0) or
     rectangular (<code>SC_SEL_RECTANGLE</code>=1)
     or by lines (<code>SC_SEL_LINES</code>=2).
     When set in these modes, regular caret moves will extend or reduce the selection,
     until the mode is cancelled by a call with same value or with <code>SCI_CANCEL</code>.
     The get function returns the current mode even if the selection was made by mouse
     or with regular extended moves.</p>

    <p><b id="SCI_GETLINESELSTARTPOSITION">SCI_GETLINESELSTARTPOSITION(int line)</b><br />
    <b id="SCI_GETLINESELENDPOSITION">SCI_GETLINESELENDPOSITION(int line)</b><br />
    Retrieve the position of the start and end of the selection at the given line with
    INVALID_POSITION returned if no selection on this line.</p>

    <p><b id="SCI_MOVECARETINSIDEVIEW">SCI_MOVECARETINSIDEVIEW</b><br />
     If the caret is off the top or bottom of the view, it is moved to the nearest line that is
    visible to its current position. Any selection is lost.</p>

    <p><b id="SCI_WORDENDPOSITION">SCI_WORDENDPOSITION(int position, bool
    onlyWordCharacters)</b><br />
     <b id="SCI_WORDSTARTPOSITION">SCI_WORDSTARTPOSITION(int position, bool
    onlyWordCharacters)</b><br />
     These messages return the start and end of words using the same definition of words as used
    internally within Scintilla. You can set your own list of characters that count as words with
    <a class="message" href="#SCI_SETWORDCHARS"><code>SCI_SETWORDCHARS</code></a>. The position
    sets the start or the search, which is forwards when searching for the end and backwards when
    searching for the start.</p>

    <p>Set <code>onlyWordCharacters</code> to <code>true</code> (1) to stop searching at the first
    non-word character in the search direction. If <code>onlyWordCharacters</code> is
    <code>false</code> (0), the first character in the search direction sets the type of the search
    as word or non-word and the search stops at the first non-matching character. Searches are also
    terminated by the start or end of the document.</p>

    <p>If "w" represents word characters and "." represents non-word characters and "|" represents
    the position and <code>true</code> or <code>false</code> is the state of
    <code>onlyWordCharacters</code>:</p>

    <table cellpadding="3" cellspacing="0" border="1" summary="Word start and end positions">
      <thead align="center">
        <tr>
          <th>Initial state</th>

          <th>end, true</th>

          <th>end, false</th>

          <th>start, true</th>

          <th>start, false</th>
        </tr>
      </thead>

      <tbody align="center">
        <tr>
          <td>..ww..|..ww..</td>

          <td>..ww..|..ww..</td>

          <td>..ww....|ww..</td>

          <td>..ww..|..ww..</td>

          <td>..ww|....ww..</td>
        </tr>

        <tr>
          <td>....ww|ww....</td>

          <td>....wwww|....</td>

          <td>....wwww|....</td>

          <td>....|wwww....</td>

          <td>....|wwww....</td>
        </tr>

        <tr>
          <td>..ww|....ww..</td>

          <td>..ww|....ww..</td>

          <td>..ww....|ww..</td>

          <td>..|ww....ww..</td>

          <td>..|ww....ww..</td>
        </tr>

        <tr>
          <td>..ww....|ww..</td>

          <td>..ww....ww|..</td>

          <td>..ww....ww|..</td>

          <td>..ww....|ww..</td>

          <td>..ww|....ww..</td>
        </tr>
      </tbody>
    </table>

    <p><b id="SCI_POSITIONBEFORE">SCI_POSITIONBEFORE(int position)</b><br />
     <b id="SCI_POSITIONAFTER">SCI_POSITIONAFTER(int position)</b><br />
     These messages return the position before and after another position
     in the document taking into account the current code page. The minimum
     position returned is 0 and the maximum is the last position in the document.
     If called with a position within a multi byte character will return the position
     of the start/end of that character.</p>

    <p><b id="SCI_TEXTWIDTH">SCI_TEXTWIDTH(int styleNumber, const char *text)</b><br />
     This returns the pixel width of a string drawn in the given <code>styleNumber</code> which can
    be used, for example, to decide how wide to make the line number margin in order to display a
    given number of numerals.</p>

    <p><b id="SCI_TEXTHEIGHT">SCI_TEXTHEIGHT(int line)</b><br />
     This returns the height in pixels of a particular line. Currently all lines are the same
    height.</p>

    <p><b id="SCI_GETCOLUMN">SCI_GETCOLUMN(int pos)</b><br />
     This message returns the column number of a position <code>pos</code> within the document
    taking the width of tabs into account. This returns the column number of the last tab on the
    line before <code>pos</code>, plus the number of characters between the last tab and
    <code>pos</code>. If there are no tab characters on the line, the return value is the number of
    characters up to the position on the line. In both cases, double byte characters count as a
    single character. This is probably only useful with monospaced fonts.</p>

    <p><b id="SCI_FINDCOLUMN">SCI_FINDCOLUMN(int line, int column)</b><br />
     This message returns the position of a <code>column</code> on a <code>line</code>
    taking the width of tabs into account. It treats a multi-byte character as a single column.
    Column numbers, like lines start at 0.</p>

    <p><b id="SCI_POSITIONFROMPOINT">SCI_POSITIONFROMPOINT(int x, int y)</b><br />
     <b id="SCI_POSITIONFROMPOINTCLOSE">SCI_POSITIONFROMPOINTCLOSE(int x, int y)</b><br />
     <code>SCI_POSITIONFROMPOINT</code> finds the closest character position to a point and
    <code>SCI_POSITIONFROMPOINTCLOSE</code> is similar but returns -1 if the point is outside the
    window or not close to any characters.</p>

    <p><b id="SCI_POINTXFROMPOSITION">SCI_POINTXFROMPOSITION(&lt;unused&gt;, int pos)</b><br />
     <b id="SCI_POINTYFROMPOSITION">SCI_POINTYFROMPOSITION(&lt;unused&gt;, int pos)</b><br />
     These messages return the x and y display pixel location of text at position <code>pos</code>
    in the document.</p>

    <p><b id="SCI_HIDESELECTION">SCI_HIDESELECTION(bool hide)</b><br />
     The normal state is to make the selection visible by drawing it as set by <a class="message"
    href="#SCI_SETSELFORE"><code>SCI_SETSELFORE</code></a> and <a class="message"
    href="#SCI_SETSELBACK"><code>SCI_SETSELBACK</code></a>. However, if you hide the selection, it
    is drawn as normal text.</p>

    <p><b id="SCI_CHOOSECARETX">SCI_CHOOSECARETX</b><br />
     Scintilla remembers the x value of the last position horizontally moved to explicitly by the
    user and this value is then used when moving vertically such as by using the up and down keys.
    This message sets the current x position of the caret as the remembered value.</p>

    <h2 id="ScrollingAndAutomaticScrolling">Scrolling and automatic scrolling</h2>
    <code><a class="message" href="#SCI_LINESCROLL">SCI_LINESCROLL(int column, int line)</a><br />
     <a class="message" href="#SCI_SCROLLCARET">SCI_SCROLLCARET</a><br />
     <a class="message" href="#SCI_SETXCARETPOLICY">SCI_SETXCARETPOLICY(int caretPolicy, int
    caretSlop)</a><br />
     <a class="message" href="#SCI_SETYCARETPOLICY">SCI_SETYCARETPOLICY(int caretPolicy, int
    caretSlop)</a><br />
     <a class="message" href="#SCI_SETVISIBLEPOLICY">SCI_SETVISIBLEPOLICY(int caretPolicy, int
    caretSlop)</a><br />
     <a class="message" href="#SCI_SETHSCROLLBAR">SCI_SETHSCROLLBAR(bool visible)</a><br />
     <a class="message" href="#SCI_GETHSCROLLBAR">SCI_GETHSCROLLBAR</a><br />
     <a class="message" href="#SCI_SETVSCROLLBAR">SCI_SETVSCROLLBAR(bool visible)</a><br />
     <a class="message" href="#SCI_GETVSCROLLBAR">SCI_GETVSCROLLBAR</a><br />
     <a class="message" href="#SCI_GETXOFFSET">SCI_GETXOFFSET</a><br />
     <a class="message" href="#SCI_SETXOFFSET">SCI_SETXOFFSET(int xOffset)</a><br />
     <a class="message" href="#SCI_SETSCROLLWIDTH">SCI_SETSCROLLWIDTH(int pixelWidth)</a><br />
     <a class="message" href="#SCI_GETSCROLLWIDTH">SCI_GETSCROLLWIDTH</a><br />
     <a class="message" href="#SCI_SETSCROLLWIDTHTRACKING">SCI_SETSCROLLWIDTHTRACKING(bool tracking)</a><br />
     <a class="message" href="#SCI_GETSCROLLWIDTHTRACKING">SCI_GETSCROLLWIDTHTRACKING</a><br />
     <a class="message" href="#SCI_SETENDATLASTLINE">SCI_SETENDATLASTLINE(bool
    endAtLastLine)</a><br />
     <a class="message" href="#SCI_GETENDATLASTLINE">SCI_GETENDATLASTLINE</a><br />
    </code>

    <p><b id="SCI_LINESCROLL">SCI_LINESCROLL(int column, int line)</b><br />
     This will attempt to scroll the display by the number of columns and lines that you specify.
    Positive line values increase the line number at the top of the screen (i.e. they move the text
    upwards as far as the user is concerned), Negative line values do the reverse.</p>

    <p>The column measure is the width of a space in the default style. Positive values increase
    the column at the left edge of the view (i.e. they move the text leftwards as far as the user
    is concerned). Negative values do the reverse.</p>

    <p>See also: <a class="message" href="#SCI_SETXOFFSET"><code>SCI_SETXOFFSET</code></a></p>

    <p><b id="SCI_SCROLLCARET">SCI_SCROLLCARET</b><br />
     If the current position (this is the caret if there is no selection) is not visible, the view
    is scrolled to make it visible according to the current caret policy.</p>

    <p><b id="SCI_SETXCARETPOLICY">SCI_SETXCARETPOLICY(int caretPolicy, int caretSlop)</b><br />
     <b id="SCI_SETYCARETPOLICY">SCI_SETYCARETPOLICY(int caretPolicy, int caretSlop)</b><br />
     These set the caret policy. The value of <code>caretPolicy</code> is a combination of
    <code>CARET_SLOP</code>, <code>CARET_STRICT</code>, <code>CARET_JUMPS</code> and
    <code>CARET_EVEN</code>.</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Caret policy">
      <tbody valign="top">
        <tr>
          <th align="left"><code>CARET_SLOP</code></th>

          <td>If set, we can define a slop value: <code>caretSlop</code>. This value defines an
          unwanted zone (UZ) where the caret is... unwanted. This zone is defined as a number of
          pixels near the vertical margins, and as a number of lines near the horizontal margins.
          By keeping the caret away from the edges, it is seen within its context. This makes it
          likely that the identifier that the caret is on can be completely seen, and that the
          current line is seen with some of the lines following it, which are often dependent on
          that line.</td>
        </tr>

        <tr>
          <th align="left"><code>CARET_STRICT</code></th>

          <td>If set, the policy set by <code>CARET_SLOP</code> is enforced... strictly. The caret
          is centred on the display if <code>caretSlop</code> is not set, and cannot go in the UZ
          if <code>caretSlop</code> is set.</td>
        </tr>

        <tr>
          <th align="left"><code>CARET_JUMPS</code></th>

          <td>If set, the display is moved more energetically so the caret can move in the same
          direction longer before the policy is applied again. '3UZ' notation is used to indicate
          three time the size of the UZ as a distance to the margin.</td>
        </tr>

        <tr>
          <th align="left"><code>CARET_EVEN</code></th>

          <td>If not set, instead of having symmetrical UZs, the left and bottom UZs are extended
          up to right and top UZs respectively. This way, we favour the displaying of useful
          information: the beginning of lines, where most code reside, and the lines after the
          caret, for example, the body of a function.</td>
        </tr>
      </tbody>
    </table>

    <table cellpadding="3" cellspacing="0" border="1" summary="Caret positioning">
      <thead align="center">
        <tr>
          <th>slop</th>

          <th>strict</th>

          <th>jumps</th>

          <th>even</th>

          <th>Caret can go to the margin</th>

          <th>On reaching limit (going out of visibility<br />
           or going into the UZ) display is...</th>
        </tr>
      </thead>

      <tbody align="center">
        <tr>
          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>Yes</td>

          <td>moved to put caret on top/on right</td>
        </tr>

        <tr>
          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>Yes</td>

          <td>moved by one position</td>
        </tr>

        <tr>
          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>0</td>

          <td>Yes</td>

          <td>moved to put caret on top/on right</td>
        </tr>

        <tr>
          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>1</td>

          <td>Yes</td>

          <td>centred on the caret</td>
        </tr>

        <tr>
          <td>0</td>

          <td>1</td>

          <td>-</td>

          <td>0</td>

          <td>Caret is always on top/on right of display</td>

          <td>-</td>
        </tr>

        <tr>
          <td>0</td>

          <td>1</td>

          <td>-</td>

          <td>1</td>

          <td>No, caret is always centred</td>

          <td>-</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>Yes</td>

          <td>moved to put caret out of the asymmetrical UZ</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>Yes</td>

          <td>moved to put caret out of the UZ</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>1</td>

          <td>0</td>

          <td>Yes</td>

          <td>moved to put caret at 3UZ of the top or right margin</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>1</td>

          <td>1</td>

          <td>Yes</td>

          <td>moved to put caret at 3UZ of the margin</td>
        </tr>

        <tr>
          <td>1</td>

          <td>1</td>

          <td>-</td>

          <td>0</td>

          <td>Caret is always at UZ of top/right margin</td>

          <td>-</td>
        </tr>

        <tr>
          <td>1</td>

          <td>1</td>

          <td>0</td>

          <td>1</td>

          <td>No, kept out of UZ</td>

          <td>moved by one position</td>
        </tr>

        <tr>
          <td>1</td>

          <td>1</td>

          <td>1</td>

          <td>0</td>

          <td>No, kept out of UZ</td>

          <td>moved to put caret at 3UZ of the margin</td>
        </tr>
      </tbody>
    </table>

    <p><b id="SCI_SETVISIBLEPOLICY">SCI_SETVISIBLEPOLICY(int caretPolicy, int caretSlop)</b><br />
     This determines how the vertical positioning is determined when <a class="message"
    href="#SCI_ENSUREVISIBLEENFORCEPOLICY"><code>SCI_ENSUREVISIBLEENFORCEPOLICY</code></a> is
    called. It takes <code>VISIBLE_SLOP</code> and <code>VISIBLE_STRICT</code> flags for the policy
    parameter. It is similar in operation to <a class="message"
    href="#SCI_SETYCARETPOLICY"><code>SCI_SETYCARETPOLICY(int caretPolicy, int
    caretSlop)</code></a>.</p>

    <p><b id="SCI_SETHSCROLLBAR">SCI_SETHSCROLLBAR(bool visible)</b><br />
     <b id="SCI_GETHSCROLLBAR">SCI_GETHSCROLLBAR</b><br />
     The horizontal scroll bar is only displayed if it is needed for the assumed width.
     If you never wish to see it, call
    <code>SCI_SETHSCROLLBAR(0)</code>. Use <code>SCI_SETHSCROLLBAR(1)</code> to enable it again.
    <code>SCI_GETHSCROLLBAR</code> returns the current state. The default state is to display it
    when needed.</p>
    <p>See also: <a class="message" href="#SCI_SETSCROLLWIDTH">SCI_SETSCROLLWIDTH</a>.</p>

    <p><b id="SCI_SETVSCROLLBAR">SCI_SETVSCROLLBAR(bool visible)</b><br />
     <b id="SCI_GETVSCROLLBAR">SCI_GETVSCROLLBAR</b><br />
     By default, the vertical scroll bar is always displayed when required. You can choose to hide
    or show it with <code>SCI_SETVSCROLLBAR</code> and get the current state with
    <code>SCI_GETVSCROLLBAR</code>.</p>

    <p><b id="SCI_SETXOFFSET">SCI_SETXOFFSET(int xOffset)</b><br />
     <b id="SCI_GETXOFFSET">SCI_GETXOFFSET</b><br />
     The <code>xOffset</code> is the horizontal scroll position in pixels of the start of the text
    view. A value of 0 is the normal position with the first text column visible at the left of the
    view.</p>

    <p>See also: <a class="message" href="#SCI_LINESCROLL"><code>SCI_LINESCROLL</code></a></p>

    <p><b id="SCI_SETSCROLLWIDTH">SCI_SETSCROLLWIDTH(int pixelWidth)</b><br />
     <b id="SCI_GETSCROLLWIDTH">SCI_GETSCROLLWIDTH</b><br />
     For performance, Scintilla does not measure the display width of the document to determine
     the properties of the horizontal scroll bar. Instead, an assumed width is used.
     These messages set and get the document width in pixels assumed by Scintilla.
     The default value is 2000.
     To ensure the width of the currently visible lines can be scrolled use
     <a class="message" href="#SCI_SETSCROLLWIDTHTRACKING"><code>SCI_SETSCROLLWIDTHTRACKING</code></a></p>

    <p><b id="SCI_SETSCROLLWIDTHTRACKING">SCI_SETSCROLLWIDTHTRACKING(bool tracking)</b><br />
     <b id="SCI_GETSCROLLWIDTHTRACKING">SCI_GETSCROLLWIDTHTRACKING</b><br />
     If scroll width tracking is enabled then the scroll width is adjusted to ensure that all of the lines currently
     displayed can be completely scrolled. This mode never adjusts the scroll width to be narrower.</p>

    <p><b id="SCI_SETENDATLASTLINE">SCI_SETENDATLASTLINE(bool endAtLastLine)</b><br />
     <b id="SCI_GETENDATLASTLINE">SCI_GETENDATLASTLINE</b><br />
     <code>SCI_SETENDATLASTLINE</code> sets the scroll range so that maximum scroll position has
    the last line at the bottom of the view (default). Setting this to <code>false</code> allows
    scrolling one page below the last line.</p>

    <h2 id="WhiteSpace">White space</h2>
    <code><a class="message" href="#SCI_SETVIEWWS">SCI_SETVIEWWS(int wsMode)</a><br />
     <a class="message" href="#SCI_GETVIEWWS">SCI_GETVIEWWS</a><br />
     <a class="message" href="#SCI_SETWHITESPACEFORE">SCI_SETWHITESPACEFORE(bool
    useWhitespaceForeColour, int colour)</a><br />
     <a class="message" href="#SCI_SETWHITESPACEBACK">SCI_SETWHITESPACEBACK(bool
    useWhitespaceBackColour, int colour)</a><br />
     <a class="message" href="#SCI_SETEXTRAASCENT">SCI_SETEXTRAASCENT(int extraAscent)</a><br />
     <a class="message" href="#SCI_GETEXTRAASCENT">SCI_GETEXTRAASCENT</a><br />
     <a class="message" href="#SCI_SETEXTRADESCENT">SCI_SETEXTRADESCENT(int extraDescent)</a><br />
     <a class="message" href="#SCI_GETEXTRADESCENT">SCI_GETEXTRADESCENT</a><br />
    </code>
 
    <p><b id="SCI_SETVIEWWS">SCI_SETVIEWWS(int wsMode)</b><br />
     <b id="SCI_GETVIEWWS">SCI_GETVIEWWS</b><br />
     White space can be made visible which may useful for languages in which white space is
    significant, such as Python. Space characters appear as small centred dots and tab characters
    as light arrows pointing to the right. There are also ways to control the display of <a
    class="jump" href="#LineEndings">end of line characters</a>. The two messages set and get the
    white space display mode. The <code>wsMode</code> argument can be one of:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="White space policy">
      <tbody valign="top">
        <tr>
          <th align="left"><code>SCWS_INVISIBLE</code></th>

          <td>0</td>

          <td>The normal display mode with white space displayed as an empty background
          colour.</td>
        </tr>

        <tr>
          <th align="left"><code>SCWS_VISIBLEALWAYS</code></th>

          <td>1</td>

          <td>White space characters are drawn as dots and arrows,</td>
        </tr>

        <tr>
          <th align="left"><code>SCWS_VISIBLEAFTERINDENT</code></th>

          <td>2</td>

          <td>White space used for indentation is displayed normally but after the first visible
          character, it is shown as dots and arrows.</td>
        </tr>
      </tbody>
    </table>

    <p>The effect of using any other <code>wsMode</code> value is undefined.</p>

    <p><b id="SCI_SETWHITESPACEFORE">SCI_SETWHITESPACEFORE(bool useWhitespaceForeColour, int <a
    class="jump" href="#colour">colour</a>)</b><br />
     <b id="SCI_SETWHITESPACEBACK">SCI_SETWHITESPACEBACK(bool useWhitespaceBackColour, int <a
    class="jump" href="#colour">colour</a>)</b><br />
     By default, the colour of visible white space is determined by the lexer in use. The
    foreground and/or background colour of all visible white space can be set globally, overriding
    the lexer's colours with <code>SCI_SETWHITESPACEFORE</code> and
    <code>SCI_SETWHITESPACEBACK</code>.</p>

    <p>
     <b id="SCI_SETEXTRAASCENT">SCI_SETEXTRAASCENT(int extraAscent)</b><br />
     <b id="SCI_GETEXTRAASCENT">SCI_GETEXTRAASCENT</b><br />
     <b id="SCI_SETEXTRADESCENT">SCI_SETEXTRADESCENT(int extraDescent)</b><br />
     <b id="SCI_GETEXTRADESCENT">SCI_GETEXTRADESCENT</b><br />
     Text is drawn with the base of each character on a 'baseline'. The height of a line is found from the maximum 
     that any style extends above the baseline (its 'ascent'), added to the maximum that any style extends below the 
     baseline (its 'descent').
     Space may be added to the maximum ascent (<code>SCI_SETEXTRAASCENT</code>) and the 
     maximum descent (<code>SCI_SETEXTRADESCENT</code>) to allow for more space between lines.
     This may done to make the text easier to read or to accomodate underlines or highlights.
    <p>

    <h2 id="Cursor">Cursor</h2>

    <p><b id="SCI_SETCURSOR">SCI_SETCURSOR(int curType)</b><br />
     <b id="SCI_GETCURSOR">SCI_GETCURSOR</b><br />
     The cursor is normally chosen in a context sensitive way, so it will be different over the
    margin than when over the text. When performing a slow action, you may wish to change to a wait
    cursor. You set the cursor type with <code>SCI_SETCURSOR</code>. The <code>curType</code>
    argument can be:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Mouse cursors">
      <tbody valign="top">
        <tr>
          <th align="left"><code>SC_CURSORNORMAL</code></th>

          <td>-1</td>

          <td>The normal cursor is displayed.</td>
        </tr>

        <tr>
          <th align="left"><code>SC_CURSORWAIT</code></th>

          <td>&nbsp;4</td>

          <td>The wait cursor is displayed when the mouse is over or owned by the Scintilla
          window.</td>
        </tr>
      </tbody>
    </table>

    <p>Cursor values 1 through 7 have defined cursors, but only <code>SC_CURSORWAIT</code> is
    usefully controllable. Other values of <code>curType</code> cause a pointer to be displayed.
    The <code>SCI_GETCURSOR</code> message returns the last cursor type you set, or
    <code>SC_CURSORNORMAL</code> (-1) if you have not set a cursor type.</p>

    <h2 id="MouseCapture">Mouse capture</h2>

    <p><b id="SCI_SETMOUSEDOWNCAPTURES">SCI_SETMOUSEDOWNCAPTURES(bool captures)</b><br />
     <b id="SCI_GETMOUSEDOWNCAPTURES">SCI_GETMOUSEDOWNCAPTURES</b><br />
     When the mouse is pressed inside Scintilla, it is captured so future mouse movement events are
    sent to Scintilla. This behavior may be turned off with
    <code>SCI_SETMOUSEDOWNCAPTURES(0)</code>.</p>

    <h2 id="LineEndings">Line endings</h2>

    <p>Scintilla can interpret any of the three major line end conventions, Macintosh (\r), Unix
    (\n) and CP/M / DOS / Windows (\r\n). When the user presses the Enter key, one of these line
    end strings is inserted into the buffer. The default is \r\n in Windows and \n in Unix, but
    this can be changed with the <code>SCI_SETEOLMODE</code> message. You can also convert the
    entire document to one of these line endings with <code>SCI_CONVERTEOLS</code>. Finally, you
    can choose to display the line endings with <code>SCI_SETVIEWEOL</code>.</p>
    <code><a class="message" href="#SCI_SETEOLMODE">SCI_SETEOLMODE(int eolMode)</a><br />
     <a class="message" href="#SCI_GETEOLMODE">SCI_GETEOLMODE</a><br />
     <a class="message" href="#SCI_CONVERTEOLS">SCI_CONVERTEOLS(int eolMode)</a><br />
     <a class="message" href="#SCI_SETVIEWEOL">SCI_SETVIEWEOL(bool visible)</a><br />
     <a class="message" href="#SCI_GETVIEWEOL">SCI_GETVIEWEOL</a><br />
    </code>

    <p><b id="SCI_SETEOLMODE">SCI_SETEOLMODE(int eolMode)</b><br />
     <b id="SCI_GETEOLMODE">SCI_GETEOLMODE</b><br />
     <code>SCI_SETEOLMODE</code> sets the characters that are added into the document when the user
    presses the Enter key. You can set <code>eolMode</code> to one of <code>SC_EOL_CRLF</code> (0),
    <code>SC_EOL_CR</code> (1), or <code>SC_EOL_LF</code> (2). The <code>SCI_GETEOLMODE</code>
    message retrieves the current state.</p>

    <p><b id="SCI_CONVERTEOLS">SCI_CONVERTEOLS(int eolMode)</b><br />
     This message changes all the end of line characters in the document to match
    <code>eolMode</code>. Valid values are: <code>SC_EOL_CRLF</code> (0), <code>SC_EOL_CR</code>
    (1), or <code>SC_EOL_LF</code> (2).</p>

    <p><b id="SCI_SETVIEWEOL">SCI_SETVIEWEOL(bool visible)</b><br />
     <b id="SCI_GETVIEWEOL">SCI_GETVIEWEOL</b><br />
     Normally, the end of line characters are hidden, but <code>SCI_SETVIEWEOL</code> allows you to
    display (or hide) them by setting <code>visible</code> <code>true</code> (or
    <code>false</code>). The visible rendering of the end of line characters is similar to
    <code>(CR)</code>, <code>(LF)</code>, or <code>(CR)(LF)</code>. <code>SCI_GETVIEWEOL</code>
    returns the current state.</p>

    <h2 id="Styling">Styling</h2>

    <p>The styling messages allow you to assign styles to text. The standard Scintilla settings
    divide the 8 style bits available for each character into 5 bits (0 to 4 = <a class="jump"
    href="#StyleDefinition">styles 0 to 31</a>) that set a style and three bits (5 to 7) that
    define <a class="jump" href="#Indicators">indicators</a>. You can change the balance between
    styles and indicators with <a class="message"
    href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a>. If your styling needs can be met by
    one of the standard lexers, or if you can write your own, then a lexer is probably the easiest
    way to style your document. If you choose to use the container to do the styling you can use
    the <a class="message" href="#SCI_SETLEXER"><code>SCI_SETLEXER</code></a> command to select
    <code>SCLEX_CONTAINER</code>, in which case the container is sent a <a class="message"
    href="#SCN_STYLENEEDED"><code>SCN_STYLENEEDED</code></a> <a class="jump"
    href="#Notifications">notification</a> each time text needs styling for display. As another
    alternative, you might use idle time to style the document. Even if you use a lexer, you might
    use the styling commands to mark errors detected by a compiler. The following commands can be
    used.</p>
    <code><a class="message" href="#SCI_GETENDSTYLED">SCI_GETENDSTYLED</a><br />
     <a class="message" href="#SCI_STARTSTYLING">SCI_STARTSTYLING(int position, int mask)</a><br />
     <a class="message" href="#SCI_SETSTYLING">SCI_SETSTYLING(int length, int style)</a><br />
     <a class="message" href="#SCI_SETSTYLINGEX">SCI_SETSTYLINGEX(int length, const char
    *styles)</a><br />
     <a class="message" href="#SCI_SETLINESTATE">SCI_SETLINESTATE(int line, int value)</a><br />
     <a class="message" href="#SCI_GETLINESTATE">SCI_GETLINESTATE(int line)</a><br />
     <a class="message" href="#SCI_GETMAXLINESTATE">SCI_GETMAXLINESTATE</a><br />
    </code>

    <p><b id="SCI_GETENDSTYLED">SCI_GETENDSTYLED</b><br />
     Scintilla keeps a record of the last character that is likely to be styled correctly. This is
    moved forwards when characters after it are styled and moved backwards if changes are made to
    the text of the document before it. Before drawing text, this position is checked to see if any
    styling is needed and, if so, a <code><a class="message"
    href="#SCN_STYLENEEDED">SCN_STYLENEEDED</a></code> notification message is sent to the
    container. The container can send <code>SCI_GETENDSTYLED</code> to work out where it needs to
    start styling. Scintilla will always ask to style whole lines.</p>

    <p><b id="SCI_STARTSTYLING">SCI_STARTSTYLING(int pos, int mask)</b><br />
     This prepares for styling by setting the styling position <code>pos</code> to start at and a
    <code>mask</code> indicating which bits of the style bytes can be set. The mask allows styling
    to occur over several passes, with, for example, basic styling done on an initial pass to
    ensure that the text of the code is seen quickly and correctly, and then a second slower pass,
    detecting syntax errors and using indicators to show where these are. For example, with the
    standard settings of 5 style bits and 3 indicator bits, you would use a <code>mask</code> value
    of 31 (0x1f) if you were setting text styles and did not want to change the indicators. After
    <code>SCI_STARTSTYLING</code>, send multiple <code>SCI_SETSTYLING</code> messages for each
    lexical entity to style.</p>

    <p><b id="SCI_SETSTYLING">SCI_SETSTYLING(int length, int style)</b><br />
     This message sets the style of <code>length</code> characters starting at the styling position
    and then increases the styling position by <code>length</code>, ready for the next call. If
    <code>sCell</code> is the style byte, the operation is:<br />
     <code>if ((sCell &amp; mask) != style) sCell = (sCell &amp; ~mask) | (style &amp;
    mask);</code><br />
    </p>

    <p><b id="SCI_SETSTYLINGEX">SCI_SETSTYLINGEX(int length, const char *styles)</b><br />
     As an alternative to <code>SCI_SETSTYLING</code>, which applies the same style to each byte,
    you can use this message which specifies the styles for each of <code>length</code> bytes from
    the styling position and then increases the styling position by <code>length</code>, ready for
    the next call. The <code>length</code> styling bytes pointed at by <code>styles</code> should
    not contain any bits not set in mask.</p>

    <p><b id="SCI_SETLINESTATE">SCI_SETLINESTATE(int line, int value)</b><br />
     <b id="SCI_GETLINESTATE">SCI_GETLINESTATE(int line)</b><br />
     As well as the 8 bits of lexical state stored for each character there is also an integer
    stored for each line. This can be used for longer lived parse states such as what the current
    scripting language is in an ASP page. Use <code>SCI_SETLINESTATE</code> to set the integer
    value and <code>SCI_GETLINESTATE</code> to get the value.
    Changing the value produces a <a class="message" href="#SC_MOD_CHANGELINESTATE">SC_MOD_CHANGELINESTATE</a> notification.
    </p>

    <p><b id="SCI_GETMAXLINESTATE">SCI_GETMAXLINESTATE</b><br />
     This returns the last line that has any line state.</p>

    <h2 id="StyleDefinition">Style definition</h2>

    <p>While the style setting messages mentioned above change the style numbers associated with
    text, these messages define how those style numbers are interpreted visually. There are 256
    lexer styles that can be set, numbered 0 to <code>STYLE_MAX</code> (255). Unless you use <a
    class="message" href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a> to change the number
    of style bits, styles 0 to 31 are used to set the text attributes. There are also some
    predefined numbered styles starting at 32, The following <code>STYLE_</code>* constants are
    defined.</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Preset styles">
      <tbody valign="top">
        <tr>
          <th align="left"><code>STYLE_DEFAULT</code></th>

          <td>32</td>

          <td>This style defines the attributes that all styles receive when the
          <code>SCI_STYLECLEARALL</code> message is used.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_LINENUMBER</code></th>

          <td>33</td>

          <td>This style sets the attributes of the text used to display line numbers in a line
          number margin. The background colour set for this style also sets the background colour
          for all margins that do not have any folding mask bits set. That is, any margin for which
          <code>mask &amp; SC_MASK_FOLDERS</code> is 0. See <a class="message"
          href="#SCI_SETMARGINMASKN"><code>SCI_SETMARGINMASKN</code></a> for more about masks.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_BRACELIGHT</code></th>

          <td>34</td>

          <td>This style sets the attributes used when highlighting braces with the <a
          class="message" href="#BraceHighlighting"><code>SCI_BRACEHIGHLIGHT</code></a> message and
          when highlighting the corresponding indentation with <a class="message"
          href="#SCI_SETHIGHLIGHTGUIDE"><code>SCI_SETHIGHLIGHTGUIDE</code></a>.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_BRACEBAD</code></th>

          <td>35</td>

          <td>This style sets the display attributes used when marking an unmatched brace with the
          <a class="message" href="#BraceHighlighting"><code>SCI_BRACEBADLIGHT</code></a>
          message.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_CONTROLCHAR</code></th>

          <td>36</td>

          <td>This style sets the font used when drawing control characters.
            Only the font, size, bold, italics, and character set attributes are used and not
            the colour attributes. See
          also: <a class="message"
          href="#SCI_SETCONTROLCHARSYMBOL"><code>SCI_SETCONTROLCHARSYMBOL</code></a>.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_INDENTGUIDE</code></th>

          <td>37</td>

          <td>This style sets the foreground and background colours used when drawing the
          indentation guides.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_CALLTIP</code></th>

          <td>38</td>

          <td> Call tips normally use the font attributes defined by <code>STYLE_DEFAULT</code>.
          Use of <a class="message" href="#SCI_CALLTIPUSESTYLE"><code>SCI_CALLTIPUSESTYLE</code></a>
            causes call tips to use this style instead. Only the font face name, font size,
          foreground and background colours and character set attributes are used.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_LASTPREDEFINED</code></th>

          <td>39</td>

          <td>To make it easier for client code to discover the range of styles that are
          predefined, this is set to the style number of the last predefined style. This is
          currently set to 39 and the last style with an identifier is 38, which reserves space
          for one future predefined style.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_MAX</code></th>

          <td>255</td>

          <td>This is not a style but is the number of the maximum style that can be set. Styles
          between <code>STYLE_LASTPREDEFINED</code> and <code>STYLE_MAX</code> would be appropriate
          if you used <a class="message" href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a>
          to set more than 5 style bits.</td>
        </tr>
      </tbody>
    </table>

    <p>For each style you can set the font name, size and use of bold, italic and underline,
    foreground and background colour and the character set. You can also choose to hide text with a
    given style, display all characters as upper or lower case and fill from the last character on
    a line to the end of the line (for embedded languages). There is also an experimental attribute
    to make text read-only.</p>

    <p>It is entirely up to you how you use styles. If you want to use syntax colouring you might
    use style 0 for white space, style 1 for numbers, style 2 for keywords, style 3 for strings,
    style 4 for preprocessor, style 5 for operators, and so on.</p>
    <code><a class="message" href="#SCI_STYLERESETDEFAULT">SCI_STYLERESETDEFAULT</a><br />
    <a class="message" href="#SCI_STYLECLEARALL">SCI_STYLECLEARALL</a><br />
    <a class="message" href="#SCI_STYLESETFONT">SCI_STYLESETFONT(int styleNumber, char
    *fontName)</a><br />
    <a class="message" href="#SCI_STYLEGETFONT">SCI_STYLEGETFONT(int styleNumber, char *fontName)</a><br />
    <a class="message" href="#SCI_STYLESETSIZE">SCI_STYLESETSIZE(int styleNumber, int
    sizeInPoints)</a><br />
    <a class="message" href="#SCI_STYLEGETSIZE">SCI_STYLEGETSIZE(int styleNumber)</a><br />
    <a class="message" href="#SCI_STYLESETBOLD">SCI_STYLESETBOLD(int styleNumber, bool
    bold)</a><br />
    <a class="message" href="#SCI_STYLEGETBOLD">SCI_STYLEGETBOLD(int styleNumber)</a><br />
    <a class="message" href="#SCI_STYLESETITALIC">SCI_STYLESETITALIC(int styleNumber, bool
    italic)</a><br />
    <a class="message" href="#SCI_STYLEGETITALIC">SCI_STYLEGETITALIC(int styleNumber)</a><br />
    <a class="message" href="#SCI_STYLESETUNDERLINE">SCI_STYLESETUNDERLINE(int styleNumber, bool
    underline)</a><br />
    <a class="message" href="#SCI_STYLEGETUNDERLINE">SCI_STYLEGETUNDERLINE(int styleNumber)</a><br />
    <a class="message" href="#SCI_STYLESETFORE">SCI_STYLESETFORE(int styleNumber, int
    colour)</a><br />
    <a class="message" href="#SCI_STYLEGETFORE">SCI_STYLEGETFORE(int styleNumber)</a><br />
    <a class="message" href="#SCI_STYLESETBACK">SCI_STYLESETBACK(int styleNumber, int
    colour)</a><br />
    <a class="message" href="#SCI_STYLEGETBACK">SCI_STYLESETBACK(int styleNumber)</a><br />
    <a class="message" href="#SCI_STYLESETEOLFILLED">SCI_STYLESETEOLFILLED(int styleNumber, bool
    eolFilled)</a><br />
    <a class="message" href="#SCI_STYLEGETEOLFILLED">SCI_STYLEGETEOLFILLED(int styleNumber)</a><br />
    <a class="message" href="#SCI_STYLESETCHARACTERSET">SCI_STYLESETCHARACTERSET(int styleNumber,
    int charSet)</a><br />
    <a class="message" href="#SCI_STYLEGETCHARACTERSET">SCI_STYLEGETCHARACTERSET(int styleNumber)</a><br />
    <a class="message" href="#SCI_STYLESETCASE">SCI_STYLESETCASE(int styleNumber, int
    caseMode)</a><br />
    <a class="message" href="#SCI_STYLEGETCASE">SCI_STYLEGETCASE(int styleNumber)</a><br />
    <a class="message" href="#SCI_STYLESETVISIBLE">SCI_STYLESETVISIBLE(int styleNumber, bool
    visible)</a><br />
    <a class="message" href="#SCI_STYLEGETVISIBLE">SCI_STYLEGETVISIBLE(int styleNumber)</a><br />
    <a class="message" href="#SCI_STYLESETCHANGEABLE">SCI_STYLESETCHANGEABLE(int styleNumber, bool
    changeable)</a><br />
    <a class="message" href="#SCI_STYLEGETCHANGEABLE">SCI_STYLEGETCHANGEABLE(int styleNumber)</a><br />
     <a class="message" href="#SCI_STYLESETHOTSPOT">SCI_STYLESETHOTSPOT(int styleNumber, bool
    hotspot)</a><br />
    <a class="message" href="#SCI_STYLEGETHOTSPOT">SCI_STYLEGETHOTSPOT(int styleNumber)</a><br />
    </code>

    <p><b id="SCI_STYLERESETDEFAULT">SCI_STYLERESETDEFAULT</b><br />
     This message resets <code>STYLE_DEFAULT</code> to its state when Scintilla was
    initialised.</p>

    <p><b id="SCI_STYLECLEARALL">SCI_STYLECLEARALL</b><br />
     This message sets all styles to have the same attributes as <code>STYLE_DEFAULT</code>. If you
    are setting up Scintilla for syntax colouring, it is likely that the lexical styles you set
    will be very similar. One way to set the styles is to:<br />
     1. Set <code>STYLE_DEFAULT</code> to the common features of all styles.<br />
     2. Use <code>SCI_STYLECLEARALL</code> to copy this to all styles.<br />
     3. Set the style attributes that make your lexical styles different.</p>

    <p><b id="SCI_STYLESETFONT">SCI_STYLESETFONT(int styleNumber, const char *fontName)</b><br />
    <b id="SCI_STYLEGETFONT">SCI_STYLEGETFONT(int styleNumber, char *fontName)</b><br />
    <b id="SCI_STYLESETSIZE">SCI_STYLESETSIZE(int styleNumber, int sizeInPoints)</b><br />
    <b id="SCI_STYLEGETSIZE">SCI_STYLEGETSIZE(int styleNumber)</b><br />
    <b id="SCI_STYLESETBOLD">SCI_STYLESETBOLD(int styleNumber, bool bold)</b><br />
    <b id="SCI_STYLEGETBOLD">SCI_STYLEGETBOLD(int styleNumber)</b><br />
    <b id="SCI_STYLESETITALIC">SCI_STYLESETITALIC(int styleNumber, bool italic)</b><br />
    <b id="SCI_STYLEGETITALIC">SCI_STYLEGETITALIC(int styleNumber)</b><br />
     These messages (plus <a class="message"
    href="#SCI_STYLESETCHARACTERSET"><code>SCI_STYLESETCHARACTERSET</code></a>) set the font
    attributes that are used to match the fonts you request to those available. The
    <code>fontName</code> is a zero terminated string holding the name of a font. Under Windows,
    only the first 32 characters of the name are used and the name is not case sensitive. For
    internal caching, Scintilla tracks fonts by name and does care about the casing of font names,
    so please be consistent. On GTK+ 2.x, either GDK or Pango can be used to display text.
    Pango antialiases text, works well with Unicode and is better supported in recent versions of GTK+
    but GDK is faster.
    Prepend a '!' character to the font name to use Pango.</p>

    <p><b id="SCI_STYLESETUNDERLINE">SCI_STYLESETUNDERLINE(int styleNumber, bool
    underline)</b><br />
    <b id="SCI_STYLEGETUNDERLINE">SCI_STYLEGETUNDERLINE(int styleNumber)</b><br />
    You can set a style to be underlined. The underline is drawn in the foreground colour. All
    characters with a style that includes the underline attribute are underlined, even if they are
    white space.</p>

    <p><b id="SCI_STYLESETFORE">SCI_STYLESETFORE(int styleNumber, int <a class="jump"
    href="#colour">colour</a>)</b><br />
    <b id="SCI_STYLEGETFORE">SCI_STYLEGETFORE(int styleNumber)</b><br />
    <b id="SCI_STYLESETBACK">SCI_STYLESETBACK(int styleNumber, int <a class="jump"
    href="#colour">colour</a>)</b><br />
    <b id="SCI_STYLEGETBACK">SCI_STYLEGETBACK(int styleNumber)</b><br />
    Text is drawn in the foreground colour. The space in each character cell that is not occupied
    by the character is drawn in the background colour.</p>

    <p><b id="SCI_STYLESETEOLFILLED">SCI_STYLESETEOLFILLED(int styleNumber, bool
    eolFilled)</b><br />
    <b id="SCI_STYLEGETEOLFILLED">SCI_STYLEGETEOLFILLED(int styleNumber)</b><br />
    If the last character in the line has a style with this attribute set, the remainder of the
    line up to the right edge of the window is filled with the background colour set for the last
    character. This is useful when a document contains embedded sections in another language such
    as HTML pages with embedded JavaScript. By setting <code>eolFilled</code> to <code>true</code>
    and a consistent background colour (different from the background colour set for the HTML
    styles) to all JavaScript styles then JavaScript sections will be easily distinguished from
    HTML.</p>

    <p><b id="SCI_STYLESETCHARACTERSET">SCI_STYLESETCHARACTERSET(int styleNumber, int
    charSet)</b><br />
    <b id="SCI_STYLEGETCHARACTERSET">SCI_STYLEGETCHARACTERSET(int styleNumber)</b><br />
    You can set a style to use a different character set than the default. The places where such
    characters sets are likely to be useful are comments and literal strings. For example,
    <code>SCI_STYLESETCHARACTERSET(SCE_C_STRING, SC_CHARSET_RUSSIAN)</code> would ensure that
    strings in Russian would display correctly in C and C++ (<code>SCE_C_STRING</code> is the style
    number used by the C and C++ lexer to display literal strings; it has the value 6). This
    feature works differently on Windows and GTK+.</p>

    <p>The character sets supported on Windows are:<br />
     <code>SC_CHARSET_ANSI</code>, <code>SC_CHARSET_ARABIC</code>, <code>SC_CHARSET_BALTIC</code>,
    <code>SC_CHARSET_CHINESEBIG5</code>, <code>SC_CHARSET_DEFAULT</code>,
    <code>SC_CHARSET_EASTEUROPE</code>, <code>SC_CHARSET_GB2312</code>,
    <code>SC_CHARSET_GREEK</code>, <code>SC_CHARSET_HANGUL</code>, <code>SC_CHARSET_HEBREW</code>,
    <code>SC_CHARSET_JOHAB</code>, <code>SC_CHARSET_MAC</code>, <code>SC_CHARSET_OEM</code>,
    <code>SC_CHARSET_RUSSIAN</code> (code page 1251),
    <code>SC_CHARSET_SHIFTJIS</code>, <code>SC_CHARSET_SYMBOL</code>, <code>SC_CHARSET_THAI</code>,
    <code>SC_CHARSET_TURKISH</code>, and <code>SC_CHARSET_VIETNAMESE</code>.</p>

    <p>The character sets supported on GTK+ are:<br />
     <code>SC_CHARSET_ANSI</code>, <code>SC_CHARSET_CYRILLIC</code> (code page 1251),
     <code>SC_CHARSET_EASTEUROPE</code>,
    <code>SC_CHARSET_GB2312</code>, <code>SC_CHARSET_HANGUL</code>,
    <code>SC_CHARSET_RUSSIAN</code> (KOI8-R), <code>SC_CHARSET_SHIFTJIS</code>, and
    <code>SC_CHARSET_8859_15</code>.</p>

    <p><b id="SCI_STYLESETCASE">SCI_STYLESETCASE(int styleNumber, int caseMode)</b><br />
    <b id="SCI_STYLEGETCASE">SCI_STYLEGETCASE(int styleNumber)</b><br />
    The value of caseMode determines how text is displayed. You can set upper case
    (<code>SC_CASE_UPPER</code>, 1) or lower case (<code>SC_CASE_LOWER</code>, 2) or display
    normally (<code>SC_CASE_MIXED</code>, 0). This does not change the stored text, only how it is
    displayed.</p>

    <p><b id="SCI_STYLESETVISIBLE">SCI_STYLESETVISIBLE(int styleNumber, bool visible)</b><br />
    <b id="SCI_STYLEGETVISIBLE">SCI_STYLEGETVISIBLE(int styleNumber)</b><br />
    Text is normally visible. However, you can completely hide it by giving it a style with the
    <code>visible</code> set to 0. This could be used to hide embedded formatting instructions or
    hypertext keywords in HTML or XML.</p>

    <p><b id="SCI_STYLESETCHANGEABLE">SCI_STYLESETCHANGEABLE(int styleNumber, bool
    changeable)</b><br />
    <b id="SCI_STYLEGETCHANGEABLE">SCI_STYLEGETCHANGEABLE(int styleNumber)</b><br />
    This is an experimental and incompletely implemented style attribute. The default setting is
    <code>changeable</code> set <code>true</code> but when set <code>false</code> it makes text
    read-only. Currently it only stops the caret from being within not-changeable text and does not
    yet stop deleting a range that contains not-changeable text.</p>

    <p><b id="SCI_STYLESETHOTSPOT">SCI_STYLESETHOTSPOT(int styleNumber, bool
    hotspot)</b><br />
    <b id="SCI_STYLEGETHOTSPOT">SCI_STYLEGETHOTSPOT(int styleNumber)</b><br />
    This style is used to mark ranges of text that can detect mouse clicks.
    The cursor changes to a hand over hotspots, and the foreground, and background colours
    may change and an underline appear to indicate that these areas are sensitive to clicking.
    This may be used to allow hyperlinks to other documents.</p>

    <h2 id="CaretAndSelectionStyles">Caret, selection, and hotspot styles</h2>

    <p>The selection is shown by changing the foreground and/or background colours. If one of these
    is not set then that attribute is not changed for the selection. The default is to show the
    selection by changing the background to light gray and leaving the foreground the same as when
    it was not selected. When there is no selection, the current insertion point is marked by the
    text caret. This is a vertical line that is normally blinking on and off to attract the users
    attention.</p>
    <code><a class="message" href="#SCI_SETSELFORE">SCI_SETSELFORE(bool useSelectionForeColour,
    int <a class="jump" href="#colour">colour<a>)</a><br />
    <a class="message" href="#SCI_SETSELBACK">SCI_SETSELBACK(bool useSelectionBackColour,
    int <a class="jump" href="#colour">colour<a>)</a><br />
    <a class="message" href="#SCI_SETSELALPHA">SCI_SETSELALPHA(int alpha)</a><br />
    <a class="message" href="#SCI_GETSELALPHA">SCI_GETSELALPHA</a><br />
    <a class="message" href="#SCI_SETSELEOLFILLED">SCI_SETSELEOLFILLED(bool filled)</a><br />
    <a class="message" href="#SCI_GETSELEOLFILLED">SCI_GETSELEOLFILLED</a><br />
    <a class="message" href="#SCI_SETCARETFORE">SCI_SETCARETFORE(int colour)</a><br />
    <a class="message" href="#SCI_GETCARETFORE">SCI_GETCARETFORE</a><br />
    <a class="message" href="#SCI_SETCARETLINEVISIBLE">SCI_SETCARETLINEVISIBLE(bool
    show)</a><br />
    <a class="message" href="#SCI_GETCARETLINEVISIBLE">SCI_GETCARETLINEVISIBLE</a><br />
    <a class="message" href="#SCI_SETCARETLINEBACK">SCI_SETCARETLINEBACK(int colour)</a><br />
    <a class="message" href="#SCI_GETCARETLINEBACK">SCI_GETCARETLINEBACK</a><br />
    <a class="message" href="#SCI_SETCARETLINEBACKALPHA">SCI_SETCARETLINEBACKALPHA(int alpha)</a><br />
    <a class="message" href="#SCI_GETCARETLINEBACKALPHA">SCI_GETCARETLINEBACKALPHA</a><br />
    <a class="message" href="#SCI_SETCARETPERIOD">SCI_SETCARETPERIOD(int milliseconds)</a><br />
    <a class="message" href="#SCI_GETCARETPERIOD">SCI_GETCARETPERIOD</a><br />
    <a class="message" href="#SCI_SETCARETSTYLE">SCI_SETCARETSTYLE(int style)</a><br />
    <a class="message" href="#SCI_GETCARETSTYLE">SCI_GETCARETSTYLE</a><br />
    <a class="message" href="#SCI_SETCARETWIDTH">SCI_SETCARETWIDTH(int pixels)</a><br />
    <a class="message" href="#SCI_GETCARETWIDTH">SCI_GETCARETWIDTH</a><br />
    <a class="message" href="#SCI_SETHOTSPOTACTIVEFORE">SCI_SETHOTSPOTACTIVEFORE(bool useSetting,
    int <a class="jump" href="#colour">colour<a>)</a><br />
    <a class="message" href="#SCI_GETHOTSPOTACTIVEFORE">SCI_GETHOTSPOTACTIVEFORE</a><br />
    <a class="message" href="#SCI_SETHOTSPOTACTIVEBACK">SCI_SETHOTSPOTACTIVEBACK(bool useSetting,
    int <a class="jump" href="#colour">colour<a>)</a><br />
    <a class="message" href="#SCI_GETHOTSPOTACTIVEBACK">SCI_GETHOTSPOTACTIVEBACK</a><br />
    <a class="message" href="#SCI_SETHOTSPOTACTIVEUNDERLINE">SCI_SETHOTSPOTACTIVEUNDERLINE(bool underline)</a><br />
    <a class="message" href="#SCI_GETHOTSPOTACTIVEUNDERLINE">SCI_GETHOTSPOTACTIVEUNDERLINE</a><br />
    <a class="message" href="#SCI_SETHOTSPOTSINGLELINE">SCI_SETHOTSPOTSINGLELINE(bool singleLine)</a><br />
    <a class="message" href="#SCI_GETHOTSPOTSINGLELINE">SCI_GETHOTSPOTSINGLELINE</a><br />
    <a class="message" href="#SCI_SETCONTROLCHARSYMBOL">SCI_SETCONTROLCHARSYMBOL(int
    symbol)</a><br />
     <a class="message" href="#SCI_GETCONTROLCHARSYMBOL">SCI_GETCONTROLCHARSYMBOL</a><br />
     <a class="message" href="#SCI_SETCARETSTICKY">SCI_SETCARETSTICKY(bool useCaretStickyBehaviour)</a><br />
     <a class="message" href="#SCI_GETCARETSTICKY">SCI_GETCARETSTICKY</a><br />
     <a class="message" href="#SCI_TOGGLECARETSTICKY">SCI_TOGGLECARETSTICKY</a><br />
    </code>

    <p><b id="SCI_SETSELFORE">SCI_SETSELFORE(bool useSelectionForeColour, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b id="SCI_SETSELBACK">SCI_SETSELBACK(bool useSelectionBackColour, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     You can choose to override the default selection colouring with these two messages. The colour
    you provide is used if you set <code>useSelection*Colour</code> to <code>true</code>. If it is
    set to <code>false</code>, the default styled colouring is used and the <code>colour</code>
    argument has no effect.</p>
     <p><b id="SCI_SETSELALPHA">SCI_SETSELALPHA(int <a class="jump" href="#alpha">alpha</a>)</b><br />
     <b id="SCI_GETSELALPHA">SCI_GETSELALPHA</b><br />
     The selection can be drawn translucently in the selection background colour by
     setting an alpha value.</p>

     <p><b id="SCI_SETSELEOLFILLED">SCI_SETSELEOLFILLED(bool filled)</b><br />
     <b id="SCI_GETSELEOLFILLED">SCI_GETSELEOLFILLED</b><br />
     The selection can be drawn up to the right hand border by setting this property.</p>

    <p><b id="SCI_SETCARETFORE">SCI_SETCARETFORE(int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b id="SCI_GETCARETFORE">SCI_GETCARETFORE</b><br />
     The colour of the caret can be set with <code>SCI_SETCARETFORE</code> and retrieved with
    <code>SCI_GETCARETFORE</code>.</p>

    <p><b id="SCI_SETCARETLINEVISIBLE">SCI_SETCARETLINEVISIBLE(bool show)</b><br />
     <b id="SCI_GETCARETLINEVISIBLE">SCI_GETCARETLINEVISIBLE</b><br />
     <b id="SCI_SETCARETLINEBACK">SCI_SETCARETLINEBACK(int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b id="SCI_GETCARETLINEBACK">SCI_GETCARETLINEBACK</b><br />
     <b id="SCI_SETCARETLINEBACKALPHA">SCI_SETCARETLINEBACKALPHA(int <a class="jump" href="#alpha">alpha</a>)</b><br />
     <b id="SCI_GETCARETLINEBACKALPHA">SCI_GETCARETLINEBACKALPHA</b><br />
     You can choose to make the background colour of the line containing the caret different with
    these messages. To do this, set the desired background colour with
    <code>SCI_SETCARETLINEBACK</code>, then use <code>SCI_SETCARETLINEVISIBLE(true)</code> to
    enable the effect. You can cancel the effect with <code>SCI_SETCARETLINEVISIBLE(false)</code>.
    The two <code>SCI_GETCARET*</code> functions return the state and the colour. This form of
    background colouring has highest priority when a line has markers that would otherwise change
    the background colour.
           The caret line may also be drawn translucently which allows other background colours to show
           through. This is done by setting the alpha (translucency) value by calling
           SCI_SETCARETLINEBACKALPHA. When the alpha is not SC_ALPHA_NOALPHA,
           the caret line is drawn after all other features so will affect the colour of all other features.
          </p>

    <p><b id="SCI_SETCARETPERIOD">SCI_SETCARETPERIOD(int milliseconds)</b><br />
     <b id="SCI_GETCARETPERIOD">SCI_GETCARETPERIOD</b><br />
     The rate at which the caret blinks can be set with <code>SCI_SETCARETPERIOD</code> which
    determines the time in milliseconds that the caret is visible or invisible before changing
    state. Setting the period to 0 stops the caret blinking. The default value is 500 milliseconds.
    <code>SCI_GETCARETPERIOD</code> returns the current setting.</p>

    <p><b id="SCI_SETCARETSTYLE">SCI_SETCARETSTYLE(int style)</b><br />
     <b id="SCI_GETCARETSTYLE">SCI_GETCARETSTYLE</b><br />
     The style of the caret can be set with <code>SCI_SETCARETSTYLE</code> to be a line caret
    (CARETSTYLE_LINE=1), a block caret (CARETSTYLE_BLOCK=2) or to not draw at all
    (CARETSTYLE_INVISIBLE=0). The default value is the line caret (CARETSTYLE_LINE=1).
    You can determine the current caret style setting using <code>SCI_GETCARETSTYLE</code>.</p>

    <p>The block character draws most combining and multibyte character sequences successfully,
    though some fonts like Thai Fonts (and possibly others) can sometimes appear strange when
    the cursor is positioned at these characters, which may result in only drawing a part of the
    cursor character sequence. This is most notable on Windows platforms.</p>

    <p><b id="SCI_SETCARETWIDTH">SCI_SETCARETWIDTH(int pixels)</b><br />
     <b id="SCI_GETCARETWIDTH">SCI_GETCARETWIDTH</b><br />
     The width of the line caret can be set with <code>SCI_SETCARETWIDTH</code> to a value of
    0, 1, 2 or 3 pixels. The default width is 1 pixel. You can read back the current width with
    <code>SCI_GETCARETWIDTH</code>. A width of 0 makes the caret invisible (added at version
    1.50), similar to setting the caret style to CARETSTYLE_INVISIBLE (though not interchangable).
    This setting only affects the width of the cursor when the cursor style is set to line caret
    mode, it does not affect the width for a block caret.</p>

    <p><b id="SCI_SETHOTSPOTACTIVEFORE">SCI_SETHOTSPOTACTIVEFORE(bool useHotSpotForeColour, int <a class="jump"
    href="#colour">colour</a>)</b><br />
    <b id="SCI_GETHOTSPOTACTIVEFORE">SCI_GETHOTSPOTACTIVEFORE</b><br />
    <b id="SCI_SETHOTSPOTACTIVEBACK">SCI_SETHOTSPOTACTIVEBACK(bool useHotSpotBackColour, int <a class="jump"
    href="#colour">colour</a>)</b><br />
    <b id="SCI_GETHOTSPOTACTIVEBACK">SCI_GETHOTSPOTACTIVEBACK</b><br />
    <b id="SCI_SETHOTSPOTACTIVEUNDERLINE">SCI_SETHOTSPOTACTIVEUNDERLINE(bool underline)</b><br />
     <b id="SCI_GETHOTSPOTACTIVEUNDERLINE">SCI_GETHOTSPOTACTIVEUNDERLINE</b><br />
    <b id="SCI_SETHOTSPOTSINGLELINE">SCI_SETHOTSPOTSINGLELINE(bool singleLine)</b><br />
     <b id="SCI_GETHOTSPOTSINGLELINE">SCI_GETHOTSPOTSINGLELINE</b><br />
    While the cursor hovers over text in a style with the hotspot attribute set,
    the default colouring can be modified and an underline drawn with these settings.
    Single line mode stops a hotspot from wrapping onto next line.</p>

    <p><b id="SCI_SETCONTROLCHARSYMBOL">SCI_SETCONTROLCHARSYMBOL(int symbol)</b><br />
     <b id="SCI_GETCONTROLCHARSYMBOL">SCI_GETCONTROLCHARSYMBOL</b><br />
     By default, Scintilla displays control characters (characters with codes less than 32) in a
    rounded rectangle as ASCII mnemonics: "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
    "BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI", "DLE", "DC1", "DC2", "DC3", "DC4", "NAK",
    "SYN", "ETB", "CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US". These mnemonics come from the
    early days of signaling, though some are still used (LF = Line Feed, BS = Back Space, CR =
    Carriage Return, for example).</p>

    <p>You can choose to replace these mnemonics by a nominated symbol with an ASCII code in the
    range 32 to 255. If you set a symbol value less than 32, all control characters are displayed
    as mnemonics. The symbol you set is rendered in the font of the style set for the character.
    You can read back the current symbol with the <code>SCI_GETCONTROLCHARSYMBOL</code> message.
    The default symbol value is 0.</p>

    <p><b id="SCI_SETCARETSTICKY">SCI_SETCARETSTICKY(bool useCaretStickyBehaviour)</b><br />
    <b id="SCI_GETCARETSTICKY">SCI_GETCARETSTICKY</b><br />
    <b id="SCI_TOGGLECARETSTICKY">SCI_TOGGLECARETSTICKY</b><br />
    These messages set, get or toggle the caretSticky flag which controls when the last position
     of the caret on the line is saved. When set to true, the position is not saved when you type
     a character, a tab, paste the clipboard content or press backspace.</p>

    <h2 id="Margins">Margins</h2>

    <p>There may be up to five margins to the left of the text display, plus a gap either side of
    the text. Each margin can be set to display either symbols or line numbers with <a
    class="message" href="#SCI_SETMARGINTYPEN"><code>SCI_SETMARGINTYPEN</code></a>. The markers
    that can be displayed in each margin are set with <a class="message"
    href="#SCI_SETMARGINMASKN"><code>SCI_SETMARGINMASKN</code></a>. Any markers not associated with
    a visible margin will be displayed as changes in background colour in the text. A width in
    pixels can be set for each margin. Margins with a zero width are ignored completely. You can
    choose if a mouse click in a margin sends a <a class="message"
    href="#SCN_MARGINCLICK"><code>SCN_MARGINCLICK</code></a> notification to the container or
    selects a line of text.</p>

    <p>The margins are numbered 0 to 4. Using a margin number outside the valid range has no
    effect. By default, margin 0 is set to display line numbers, but is given a width of 0, so it
    is hidden. Margin 1 is set to display non-folding symbols and is given a width of 16 pixels, so
    it is visible. Margin 2 is set to display the folding symbols, but is given a width of 0, so it
    is hidden. Of course, you can set the margins to be whatever you wish.</p>
    
    <p>Styled text margins used to show revision and blame information:</p>
    <p><img src="styledmargin.png" alt="Styled text margins used to show revision and blame information" /></p>

    <code><a class="message" href="#SCI_SETMARGINTYPEN">SCI_SETMARGINTYPEN(int margin, int
    type)</a><br />
     <a class="message" href="#SCI_GETMARGINTYPEN">SCI_GETMARGINTYPEN(int margin)</a><br />
     <a class="message" href="#SCI_SETMARGINWIDTHN">SCI_SETMARGINWIDTHN(int margin, int
    pixelWidth)</a><br />
     <a class="message" href="#SCI_GETMARGINWIDTHN">SCI_GETMARGINWIDTHN(int margin)</a><br />
     <a class="message" href="#SCI_SETMARGINMASKN">SCI_SETMARGINMASKN(int margin, int
    mask)</a><br />
     <a class="message" href="#SCI_GETMARGINMASKN">SCI_GETMARGINMASKN(int margin)</a><br />
     <a class="message" href="#SCI_SETMARGINSENSITIVEN">SCI_SETMARGINSENSITIVEN(int margin, bool
    sensitive)</a><br />
     <a class="message" href="#SCI_GETMARGINSENSITIVEN">SCI_GETMARGINSENSITIVEN(int
    margin)</a><br />
     <a class="message" href="#SCI_SETMARGINLEFT">SCI_SETMARGINLEFT(&lt;unused&gt;, int
    pixels)</a><br />
     <a class="message" href="#SCI_GETMARGINLEFT">SCI_GETMARGINLEFT</a><br />
     <a class="message" href="#SCI_SETMARGINRIGHT">SCI_SETMARGINRIGHT(&lt;unused&gt;, int
    pixels)</a><br />
     <a class="message" href="#SCI_GETMARGINRIGHT">SCI_GETMARGINRIGHT</a><br />
     <a class="message" href="#SCI_SETFOLDMARGINCOLOUR">SCI_SETFOLDMARGINCOLOUR(bool useSetting, int colour)</a><br />
     <a class="message" href="#SCI_SETFOLDMARGINHICOLOUR">SCI_SETFOLDMARGINHICOLOUR(bool useSetting, int colour)</a><br />
     <a class="message" href="#SCI_MARGINSETTEXT">SCI_MARGINSETTEXT(int line, char *text)</a><br />
     <a class="message" href="#SCI_MARGINGETTEXT">SCI_MARGINGETTEXT(int line, char *text)</a><br />
     <a class="message" href="#SCI_MARGINSETSTYLE">SCI_MARGINSETSTYLE(int line, int style)</a><br />
     <a class="message" href="#SCI_MARGINGETSTYLE">SCI_MARGINGETSTYLE(int line)</a><br />
     <a class="message" href="#SCI_MARGINSETSTYLES">SCI_MARGINSETSTYLES(int line, char *styles)</a><br />
     <a class="message" href="#SCI_MARGINGETSTYLES">SCI_MARGINGETSTYLES(int line, char *styles)</a><br />
     <a class="message" href="#SCI_MARGINTEXTCLEARALL">SCI_MARGINTEXTCLEARALL</a><br />
     <a class="message" href="#SCI_MARGINSETSTYLEOFFSET">SCI_MARGINSETSTYLEOFFSET(int style)</a><br />
     <a class="message" href="#SCI_MARGINGETSTYLEOFFSET">SCI_MARGINGETSTYLEOFFSET</a><br />
    </code>

    <p><b id="SCI_SETMARGINTYPEN">SCI_SETMARGINTYPEN(int margin, int iType)</b><br />
     <b id="SCI_GETMARGINTYPEN">SCI_GETMARGINTYPEN(int margin)</b><br />
     These two routines set and get the type of a margin. The margin argument should be 0, 1, 2, 3 or 4.
    You can use the predefined constants <code>SC_MARGIN_SYMBOL</code> (0) and
    <code>SC_MARGIN_NUMBER</code> (1) to set a margin as either a line number or a symbol margin.
    A margin with application defined text may use <code>SC_MARGIN_TEXT</code> (4) or
    <code>SC_MARGIN_RTEXT</code> (5) to right justify the text.
    By convention, margin 0 is used for line numbers and the next two are used for symbols. You can
    also use the constants <code>SC_MARGIN_BACK</code> (2) and <code>SC_MARGIN_FORE</code> (3) for
    symbol margins that set their background colour to match the STYLE_DEFAULT background and
    foreground colours.</p>

    <p><b id="SCI_SETMARGINWIDTHN">SCI_SETMARGINWIDTHN(int margin, int pixelWidth)</b><br />
     <b id="SCI_GETMARGINWIDTHN">SCI_GETMARGINWIDTHN(int margin)</b><br />
     These routines set and get the width of a margin in pixels. A margin with zero width is
    invisible. By default, Scintilla sets margin 1 for symbols with a width of 16 pixels, so this
    is a reasonable guess if you are not sure what would be appropriate. Line number margins widths
    should take into account the number of lines in the document and the line number style. You
    could use something like <a class="message"
    href="#SCI_TEXTWIDTH"><code>SCI_TEXTWIDTH(STYLE_LINENUMBER, "_99999")</code></a> to get a
    suitable width.</p>

    <p><b id="SCI_SETMARGINMASKN">SCI_SETMARGINMASKN(int margin, int mask)</b><br />
     <b id="SCI_GETMARGINMASKN">SCI_GETMARGINMASKN(int margin)</b><br />
     The mask is a 32-bit value. Each bit corresponds to one of 32 logical symbols that can be
    displayed in a margin that is enabled for symbols. There is a useful constant,
    <code>SC_MASK_FOLDERS</code> (0xFE000000 or -33554432), that is a mask for the 7 logical
    symbols used to denote folding. You can assign a wide range of symbols and colours to each of
    the 32 logical symbols, see <a href="#Markers">Markers</a> for more information. If <code>(mask
    &amp; SC_MASK_FOLDERS)==0</code>, the margin background colour is controlled by style 33 (<a
    class="message" href="#StyleDefinition"><code>STYLE_LINENUMBER</code></a>).</p>

    <p>You add logical markers to a line with <a class="message"
    href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a>. If a line has an associated marker that
    does not appear in the mask of any margin with a non-zero width, the marker changes the
    background colour of the line. For example, suppose you decide to use logical marker 10 to mark
    lines with a syntax error and you want to show such lines by changing the background colour.
    The mask for this marker is 1 shifted left 10 times (1&lt;&lt;10) which is 0x400. If you make
    sure that no symbol margin includes 0x400 in its mask, any line with the marker gets the
    background colour changed.</p>

    <p>To set a non-folding margin 1 use <code>SCI_SETMARGINMASKN(1, ~SC_MASK_FOLDERS)</code>; to
    set a folding margin 2 use <code>SCI_SETMARGINMASKN(2, SC_MASK_FOLDERS)</code>. This is the
    default set by Scintilla. <code>~SC_MASK_FOLDERS</code> is 0x1FFFFFF in hexadecimal or 33554431
    decimal. Of course, you may need to display all 32 symbols in a margin, in which case use
    <code>SCI_SETMARGINMASKN(margin, -1)</code>.</p>

    <p><b id="SCI_SETMARGINSENSITIVEN">SCI_SETMARGINSENSITIVEN(int margin, bool
    sensitive)</b><br />
     <b id="SCI_GETMARGINSENSITIVEN">SCI_GETMARGINSENSITIVEN(int margin)</b><br />
     Each of the five margins can be set sensitive or insensitive to mouse clicks. A click in a
    sensitive margin sends a <a class="message"
    href="#SCN_MARGINCLICK"><code>SCN_MARGINCLICK</code></a> <a class="jump"
    href="#Notifications">notification</a> to the container. Margins that are not sensitive act as
    selection margins which make it easy to select ranges of lines. By default, all margins are
    insensitive.</p>

    <p><b id="SCI_SETMARGINLEFT">SCI_SETMARGINLEFT(&lt;unused&gt;, int pixels)</b><br />
     <b id="SCI_GETMARGINLEFT">SCI_GETMARGINLEFT</b><br />
     <b id="SCI_SETMARGINRIGHT">SCI_SETMARGINRIGHT(&lt;unused&gt;, int pixels)</b><br />
     <b id="SCI_GETMARGINRIGHT">SCI_GETMARGINRIGHT</b><br />
     These messages set and get the width of the blank margin on both sides of the text in pixels.
    The default is to one pixel on each side.</p>

    <p><b id="SCI_SETFOLDMARGINCOLOUR">SCI_SETFOLDMARGINCOLOUR(bool useSetting, int colour)</b><br />
     <b id="SCI_SETFOLDMARGINHICOLOUR">SCI_SETFOLDMARGINHICOLOUR(bool useSetting, int colour)</b><br />
     These messages allow changing the colour of the fold margin and fold margin highlight.
     On Windows the fold margin colour defaults to ::GetSysColor(COLOR_3DFACE) and the fold margin highlight
     colour to ::GetSysColor(COLOR_3DHIGHLIGHT).</p>

    <p>
     <b id="SCI_MARGINSETTEXT">SCI_MARGINSETTEXT(int line, char *text)</b><br />
     <b id="SCI_MARGINGETTEXT">SCI_MARGINGETTEXT(int line, char *text)</b><br />
     <b id="SCI_MARGINSETSTYLE">SCI_MARGINSETSTYLE(int line, int style)</b><br />
     <b id="SCI_MARGINGETSTYLE">SCI_MARGINGETSTYLE(int line)</b><br />
     <b id="SCI_MARGINSETSTYLES">SCI_MARGINSETSTYLES(int line, char *styles)</b><br />
     <b id="SCI_MARGINGETSTYLES">SCI_MARGINGETSTYLES(int line, char *styles)</b><br />
     <b id="SCI_MARGINTEXTCLEARALL">SCI_MARGINTEXTCLEARALL</b><br />
     Text margins are created with the type SC_MARGIN_TEXT or SC_MARGIN_RTEXT. 
     A different string may be set for each line with <code>SCI_MARGINSETTEXT</code>.
     The whole of the text margin on a line may be displayed in a particular style with 
     <code>SCI_MARGINSETSTYLE</code> or each character may be individually styled with 
     <code>SCI_MARGINSETSTYLES</code> which uses an array of bytes with each byte setting the style
     of the corresponding text byte simlar to <code>SCI_SETSTYLINGEX</code>.
     Setting a text margin will cause a 
     <a class="message" href="#SC_MOD_CHANGEMARGIN"><code>SC_MOD_CHANGEMARGIN</code></a>
     notification to be sent.
    </p>
    <p>
     <b id="SCI_MARGINSETSTYLEOFFSET">SCI_MARGINSETSTYLEOFFSET(int style)</b><br />
     <b id="SCI_MARGINGETSTYLEOFFSET">SCI_MARGINGETSTYLEOFFSET</b><br />
    Margin styles may be completely separated from standard text styles by setting a style offset. For example, 
    <code>SCI_MARGINSETSTYLEOFFSET(256)</code> would allow the margin styles to be numbered from
    256 upto 511 so they do not overlap styles set by lexers. Each style number set with <code>SCI_MARGINSETSTYLE</code>
    or <code>SCI_MARGINSETSTYLES</code> has the offset added before looking up the style.
    </p>

    <h2 id="Annotations">Annotations</h2>

    <p>Annotations are read-only lines of text underneath each line of editable text.
    An annotation may consist of multiple lines separated by '\n'. 
    Annotations can be used to display an assembler version of code for debugging or to show diagnostic messages inline or to 
    line up different versions of text in a merge tool.</p>
    <p>Annotations used for inline diagnostics:</p>
    <p><img src="annotations.png" alt="Annotations used for inline diagnostics" /></p>

    <code>
     <a class="message" href="#SCI_ANNOTATIONSETTEXT">SCI_ANNOTATIONSETTEXT(int line, char *text)</a><br />
     <a class="message" href="#SCI_ANNOTATIONGETTEXT">SCI_ANNOTATIONGETTEXT(int line, char *text)</a><br />
     <a class="message" href="#SCI_ANNOTATIONSETSTYLE">SCI_ANNOTATIONSETSTYLE(int line, int style)</a><br />
     <a class="message" href="#SCI_ANNOTATIONGETSTYLE">SCI_ANNOTATIONGETSTYLE(int line)</a><br />
     <a class="message" href="#SCI_ANNOTATIONSETSTYLES">SCI_ANNOTATIONSETSTYLES(int line, char *styles)</a><br />
     <a class="message" href="#SCI_ANNOTATIONGETSTYLES">SCI_ANNOTATIONGETSTYLES(int line, char *styles)</a><br />
     <a class="message" href="#SCI_ANNOTATIONGETLINES">SCI_ANNOTATIONGETLINES(int line)</a><br />
     <a class="message" href="#SCI_ANNOTATIONCLEARALL">SCI_ANNOTATIONCLEARALL</a><br />
     <a class="message" href="#SCI_ANNOTATIONSETVISIBLE">SCI_ANNOTATIONSETVISIBLE(int visible)</a><br />
     <a class="message" href="#SCI_ANNOTATIONGETVISIBLE">SCI_ANNOTATIONGETVISIBLE</a><br />
     <a class="message" href="#SCI_ANNOTATIONSETSTYLEOFFSET">SCI_ANNOTATIONSETSTYLEOFFSET(int style)</a><br />
     <a class="message" href="#SCI_ANNOTATIONGETSTYLEOFFSET">SCI_ANNOTATIONGETSTYLEOFFSET</a><br />
    </code>

    <p>
     <b id="SCI_ANNOTATIONSETTEXT">SCI_ANNOTATIONSETTEXT(int line, char *text)</b><br />
     <b id="SCI_ANNOTATIONGETTEXT">SCI_ANNOTATIONGETTEXT(int line, char *text)</b><br />
     <b id="SCI_ANNOTATIONSETSTYLE">SCI_ANNOTATIONSETSTYLE(int line, int style)</b><br />
     <b id="SCI_ANNOTATIONGETSTYLE">SCI_ANNOTATIONGETSTYLE(int line)</b><br />
     <b id="SCI_ANNOTATIONSETSTYLES">SCI_ANNOTATIONSETSTYLES(int line, char *styles)</b><br />
     <b id="SCI_ANNOTATIONGETSTYLES">SCI_ANNOTATIONGETSTYLES(int line, char *styles)</b><br />
     <b id="SCI_ANNOTATIONGETLINES">SCI_ANNOTATIONGETLINES(int line)</b><br />
     <b id="SCI_ANNOTATIONCLEARALL">SCI_ANNOTATIONCLEARALL</b><br />
     A different string may be set for each line with <code>SCI_ANNOTATIONSETTEXT</code>.
     To clear annotations call <code>SCI_ANNOTATIONSETTEXT</code> with a NULL pointer.
     The whole of the text ANNOTATION on a line may be displayed in a particular style with 
     <code>SCI_ANNOTATIONSETSTYLE</code> or each character may be individually styled with 
     <code>SCI_ANNOTATIONSETSTYLES</code> which uses an array of bytes with each byte setting the style
     of the corresponding text byte simlar to <code>SCI_SETSTYLINGEX</code>. The text must be set first as it
     specifies how long the annotation is so how many bytes of styling to read.
     Setting an annotation will cause a 
     <a class="message" href="#SC_MOD_CHANGEANNOTATION"><code>SC_MOD_CHANGEANNOTATION</code></a>
     notification to be sent.
    </p>
    <p>
    The number of lines annotating a line can be retrieved with <code>SCI_ANNOTATIONGETLINES</code>.
    All the lines can be cleared of annotations with <code>SCI_ANNOTATIONCLEARALL</code>
    which is equivalent to clearing each line (setting to 0) and then deleting other memory used for this feature.
    </p>
    <p>
     <b id="SCI_ANNOTATIONSETVISIBLE">SCI_ANNOTATIONSETVISIBLE(int visible)</b><br />
     <b id="SCI_ANNOTATIONGETVISIBLE">SCI_ANNOTATIONGETVISIBLE</b><br />
     Annotations can be made visible in a view and there is a choice of display style when visible.
     The two messages set and get the annotation display mode. The <code>visible</code> 
     argument can be one of:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Annotation visibility">
      <tbody valign="top">
        <tr>
          <th align="left"><code>ANNOTATION_HIDDEN</code></th>

          <td>0</td>

          <td>Annotations are not displayed.</td>
        </tr>

        <tr>
          <th align="left"><code>ANNOTATION_STANDARD</code></th>

          <td>1</td>

          <td>Annotations are drawn left justified with no adornment.</td>
        </tr>

        <tr>
          <th align="left"><code>ANNOTATION_BOXED</code></th>

          <td>2</td>

          <td>Annotations are indented 40 pixels and are surrounded by a box.</td>
        </tr>
      </tbody>
    </table>

    </p>
    <p>
     <b id="SCI_ANNOTATIONSETSTYLEOFFSET">SCI_ANNOTATIONSETSTYLEOFFSET(int style)</b><br />
     <b id="SCI_ANNOTATIONGETSTYLEOFFSET">SCI_ANNOTATIONGETSTYLEOFFSET</b><br />
    Annotation styles may be completely separated from standard text styles by setting a style offset. For example, 
    <code>SCI_ANNOTATIONSETSTYLEOFFSET(512)</code> would allow the annotation styles to be numbered from
    512 upto 767 so they do not overlap styles set by lexers (or margins if margins offset is 256). 
    Each style number set with <code>SCI_ANNOTATIONSETSTYLE</code>
    or <code>SCI_ANNOTATIONSETSTYLES</code> has the offset added before looking up the style.
    </p>

    <h2 id="OtherSettings">Other settings</h2>
    <code><a class="message" href="#SCI_SETUSEPALETTE">SCI_SETUSEPALETTE(bool
    allowPaletteUse)</a><br />
     <a class="message" href="#SCI_GETUSEPALETTE">SCI_GETUSEPALETTE</a><br />
     <a class="message" href="#SCI_SETBUFFEREDDRAW">SCI_SETBUFFEREDDRAW(bool isBuffered)</a><br />
     <a class="message" href="#SCI_GETBUFFEREDDRAW">SCI_GETBUFFEREDDRAW</a><br />
     <a class="message" href="#SCI_SETTWOPHASEDRAW">SCI_SETTWOPHASEDRAW(bool twoPhase)</a><br />
     <a class="message" href="#SCI_GETTWOPHASEDRAW">SCI_GETTWOPHASEDRAW</a><br />
     <a class="message" href="#SCI_SETCODEPAGE">SCI_SETCODEPAGE(int codePage)</a><br />
     <a class="message" href="#SCI_GETCODEPAGE">SCI_GETCODEPAGE</a><br />
     <a class="message" href="#SCI_SETKEYSUNICODE">SCI_SETKEYSUNICODE(bool keysUnicode)</a><br />
     <a class="message" href="#SCI_GETKEYSUNICODE">SCI_GETKEYSUNICODE</a><br />
     <a class="message" href="#SCI_SETWORDCHARS">SCI_SETWORDCHARS(&lt;unused&gt;, const char
    *chars)</a><br />
     <a class="message" href="#SCI_SETWHITESPACECHARS">SCI_SETWHITESPACECHARS(&lt;unused&gt;, const char
    *chars)</a><br />
     <a class="message" href="#SCI_SETCHARSDEFAULT">SCI_SETCHARSDEFAULT</a><br />
     <a class="message" href="#SCI_GRABFOCUS">SCI_GRABFOCUS</a><br />
     <a class="message" href="#SCI_SETFOCUS">SCI_SETFOCUS(bool focus)</a><br />
     <a class="message" href="#SCI_GETFOCUS">SCI_GETFOCUS</a><br />
    </code>

    <p><b id="SCI_SETUSEPALETTE">SCI_SETUSEPALETTE(bool allowPaletteUse)</b><br />
     <b id="SCI_GETUSEPALETTE">SCI_GETUSEPALETTE</b><br />
     On 8 bit displays, which can only display a maximum of 256 colours, the graphics environment
    mediates between the colour needs of applications through the use of palettes. On GTK+,
    Scintilla always uses a palette.</p>

    <p>On Windows, there are some problems with visual flashing when switching between applications
    with palettes and it is also necessary for the application containing the Scintilla control to
    forward some messages to Scintilla for its palette code to work. Because of this, by default,
    the palette is not used and the application must tell Scintilla to use one. If Scintilla is not
    using a palette, it will only display in those colours already available, which are often the
    20 Windows system colours.</p>

    <p>To see an example of how to enable palette support in Scintilla, search the text of SciTE
    for <code>WM_PALETTECHANGED</code>, <code>WM_QUERYNEWPALETTE</code> and
    <code>SCI_SETUSEPALETTE</code>. The Windows messages to forward are:<br />
     <code>WM_SYSCOLORCHANGE</code>, <code>WM_PALETTECHANGED</code>,
    <code>WM_QUERYNEWPALETTE</code> (should return <code>TRUE</code>).</p>

    <p>To forward a message <code>(WM_XXXX, WPARAM, LPARAM)</code> to Scintilla, you can use
    <code>SendMessage(hScintilla, WM_XXXX, WPARAM, LPARAM)</code> where <code>hScintilla</code> is
    the handle to the Scintilla window you created as your editor.</p>

    <p>While we are on the subject of forwarding messages in Windows, the top level window should
    forward any <code>WM_SETTINGCHANGE</code> messages to Scintilla (this is currently used to
    collect changes to mouse settings, but could be used for other user interface items in the
    future).</p>

    <p><b id="SCI_SETBUFFEREDDRAW">SCI_SETBUFFEREDDRAW(bool isBuffered)</b><br />
     <b id="SCI_GETBUFFEREDDRAW">SCI_GETBUFFEREDDRAW</b><br />
     These messages turn buffered drawing on or off and report the buffered drawing state. Buffered
    drawing draws each line into a bitmap rather than directly to the screen and then copies the
    bitmap to the screen. This avoids flickering although it does take longer. The default is for
    drawing to be buffered.</p>

    <p><b id="SCI_SETTWOPHASEDRAW">SCI_SETTWOPHASEDRAW(bool twoPhase)</b><br />
     <b id="SCI_GETTWOPHASEDRAW">SCI_GETTWOPHASEDRAW</b><br />
     Two phase drawing is a better but slower way of drawing text.
     In single phase drawing each run of characters in one style is drawn along with its background.
     If a character overhangs the end of a run, such as in "<i>V</i>_" where the
     "<i>V</i>" is in a different style from the "_", then this can cause the right hand
     side of the "<i>V</i>" to be overdrawn by the background of the "_" which
     cuts it off. Two phase drawing
     fixes this by drawing all the backgrounds first and then drawing the text in
     transparent mode. Two phase drawing may flicker more than single phase
     unless buffered drawing is on. The default is for drawing to be two phase.</p>

    <p><b id="SCI_SETCODEPAGE">SCI_SETCODEPAGE(int codePage)</b><br />
     <b id="SCI_GETCODEPAGE">SCI_GETCODEPAGE</b><br />
     Scintilla has some support for Japanese, Chinese and Korean DBCS. Use this message with
    <code>codePage</code> set to the code page number to set Scintilla to use code page information
    to ensure double byte characters are treated as one character rather than two. This also stops
    the caret from moving between the two bytes in a double byte character.
    Do not use this message to choose between different single byte character sets: it doesn't do that.
    Call with
    <code>codePage</code> set to zero to disable DBCS support. The default is
    <code>SCI_SETCODEPAGE(0)</code>.</p>

    <p>Code page <code>SC_CP_UTF8</code> (65001) sets Scintilla into Unicode mode with the document
    treated as a sequence of characters expressed in UTF-8. The text is converted to the platform's
    normal Unicode encoding before being drawn by the OS and thus can display Hebrew, Arabic,
    Cyrillic, and Han characters. Languages which can use two characters stacked vertically in one
    horizontal space, such as Thai, will mostly work but there are some issues where the characters
    are drawn separately leading to visual glitches. Bi-directional text is not supported. Characters outside the
    Basic Multilingual Plane are unlikely to work.</p>

    <p>On Windows, code page can be set to 932 (Japanese Shift-JIS), 936 (Simplified Chinese GBK),
    949 (Korean Unified Hangul Code), 950 (Traditional Chinese Big5), or 1361 (Korean Johab)
    although these may require installation of language specific support.</p>

    <p>On GTK+, code page <code>SC_CP_DBCS</code> (1) sets Scintilla into
    multi byte character mode as is required for Japanese language processing with
    the EUC encoding.</p>

    <p>For GTK+ 1.x, the locale should be set to a Unicode locale with a call similar to
    <code>setlocale(LC_CTYPE, "en_US.UTF-8")</code>. Fonts with an <code>"iso10646"</code> registry
    should be used in a font set. Font sets are a comma separated list of partial font
    specifications where each partial font specification can be in the form:
    <code>foundry-fontface-charsetregistry-encoding</code> or
    <code>fontface-charsetregistry-encoding</code> or <code>foundry-fontface</code> or
    <code>fontface</code>. An example is <code>"misc-fixed-iso10646-1,*"</code>.
    On GTK+ 2.x, Pango fonts should be used rather than font sets.</p>

    <p>Setting <code>codePage</code> to a non-zero value that is not <code>SC_CP_UTF8</code> is
    operating system dependent.</p>

    <p><b id="SCI_SETKEYSUNICODE">SCI_SETKEYSUNICODE(bool keysUnicode)</b><br />
     <b id="SCI_GETKEYSUNICODE">SCI_GETKEYSUNICODE</b><br />
     On Windows, character keys are normally handled differently depending on whether Scintilla is a wide
     or narrow character window with character messages treated as Unicode when wide and as 8 bit otherwise.
     Set this property to always treat as Unicode. This option is needed for Delphi.</p>

    <p><b id="SCI_SETWORDCHARS">SCI_SETWORDCHARS(&lt;unused&gt;, const char *chars)</b><br />
     Scintilla has several functions that operate on words, which are defined to be contiguous
    sequences of characters from a particular set of characters. This message defines which
    characters are members of that set. The character sets are set to default values before processing this
    function.
    For example, if you don't allow '_' in your set of characters
    use:<br />
     <code>SCI_SETWORDCHARS(0, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")</code>;</p>

    <p><b id="SCI_SETWHITESPACECHARS">SCI_SETWHITESPACECHARS(&lt;unused&gt;, const char *chars)</b><br />
     Similar to <code>SCI_SETWORDCHARS</code>, this message allows the user to define which chars Scintilla considers
          as whitespace.  Setting the whitespace chars allows the user to fine-tune Scintilla's behaviour doing
          such things as moving the cursor to the start or end of a word; for example, by defining punctuation chars
          as whitespace, they will be skipped over when the user presses ctrl+left or ctrl+right.
          This function should be called after <code>SCI_SETWORDCHARS</code> as it will
          reset the whitespace characters to the default set.</p>
    <p><b id="SCI_SETCHARSDEFAULT">SCI_SETCHARSDEFAULT</b><br />
     Use the default sets of word and whitespace characters. This sets whitespace to space, tab and other
     characters with codes less than 0x20, with word characters set to alphanumeric and '_'.
    </p>


    <p><b id="SCI_GRABFOCUS">SCI_GRABFOCUS</b><br />
     <b id="SCI_SETFOCUS">SCI_SETFOCUS(bool focus)</b><br />
     <b id="SCI_GETFOCUS">SCI_GETFOCUS</b><br />
     Scintilla can be told to grab the focus with this message. This is needed more on GTK+ where
           focus handling is more complicated than on Windows.</p>

    <p>The internal focus flag can be set with <code>SCI_SETFOCUS</code>. This is used by clients
    that have complex focus requirements such as having their own window that gets the real focus
    but with the need to indicate that Scintilla has the logical focus.</p>

    <h2 id="BraceHighlighting">Brace highlighting</h2>
    <code><a class="message" href="#SCI_BRACEHIGHLIGHT">SCI_BRACEHIGHLIGHT(int pos1, int
    pos2)</a><br />
     <a class="message" href="#SCI_BRACEBADLIGHT">SCI_BRACEBADLIGHT(int pos1)</a><br />
     <a class="message" href="#SCI_BRACEMATCH">SCI_BRACEMATCH(int position, int
    maxReStyle)</a><br />
    </code>

    <p><b id="SCI_BRACEHIGHLIGHT">SCI_BRACEHIGHLIGHT(int pos1, int pos2)</b><br />
     Up to two characters can be highlighted in a 'brace highlighting style', which is defined as
    style number <a class="message" href="#StyleDefinition"><code>STYLE_BRACELIGHT</code></a> (34).
    If you have enabled indent guides, you may also wish to highlight the indent that corresponds
    with the brace. You can locate the column with <a class="message"
    href="#SCI_GETCOLUMN"><code>SCI_GETCOLUMN</code></a> and highlight the indent with <a
    class="message" href="#SCI_SETHIGHLIGHTGUIDE"><code>SCI_SETHIGHLIGHTGUIDE</code></a>.</p>

    <p><b id="SCI_BRACEBADLIGHT">SCI_BRACEBADLIGHT(int pos1)</b><br />
     If there is no matching brace then the <a class="jump" href="#StyleDefinition">brace
    badlighting style</a>, style <code>BRACE_BADLIGHT</code> (35), can be used to show the brace
    that is unmatched. Using a position of <code>INVALID_POSITION</code> (-1) removes the
    highlight.</p>

    <p><b id="SCI_BRACEMATCH">SCI_BRACEMATCH(int pos, int maxReStyle)</b><br />
     The <code>SCI_BRACEMATCH</code> message finds a corresponding matching brace given
    <code>pos</code>, the position of one brace. The brace characters handled are '(', ')', '[',
    ']', '{', '}', '&lt;', and '&gt;'. The search is forwards from an opening brace and backwards
    from a closing brace. If the character at position is not a brace character, or a matching
    brace cannot be found, the return value is -1. Otherwise, the return value is the position of
    the matching brace.</p>

    <p>A match only occurs if the style of the matching brace is the same as the starting brace or
    the matching brace is beyond the end of styling. Nested braces are handled correctly. The
    <code>maxReStyle</code> parameter must currently be 0 - it may be used in the future to limit
    the length of brace searches.</p>

    <h2 id="TabsAndIndentationGuides">Tabs and Indentation Guides</h2>

    <p>Indentation (the white space at the start of a line) is often used by programmers to clarify
    program structure and in some languages, for example Python, it may be part of the language
    syntax. Tabs are normally used in editors to insert a tab character or to pad text with spaces
    up to the next tab.</p>

    <p>Scintilla can be set to treat tab and backspace in the white space at the start of a line in
    a special way: inserting a tab indents the line to the next indent position rather than just
    inserting a tab at the current character position and backspace unindents the line rather than
    deleting a character. Scintilla can also display indentation guides (vertical lines) to help
    you to generate code.</p>
    <code><a class="message" href="#SCI_SETTABWIDTH">SCI_SETTABWIDTH(int widthInChars)</a><br />
     <a class="message" href="#SCI_GETTABWIDTH">SCI_GETTABWIDTH</a><br />
     <a class="message" href="#SCI_SETUSETABS">SCI_SETUSETABS(bool useTabs)</a><br />
     <a class="message" href="#SCI_GETUSETABS">SCI_GETUSETABS</a><br />
     <a class="message" href="#SCI_SETINDENT">SCI_SETINDENT(int widthInChars)</a><br />
     <a class="message" href="#SCI_GETINDENT">SCI_GETINDENT</a><br />
     <a class="message" href="#SCI_SETTABINDENTS">SCI_SETTABINDENTS(bool tabIndents)</a><br />
     <a class="message" href="#SCI_GETTABINDENTS">SCI_GETTABINDENTS</a><br />
     <a class="message" href="#SCI_SETBACKSPACEUNINDENTS">SCI_SETBACKSPACEUNINDENTS(bool
    bsUnIndents)</a><br />
     <a class="message" href="#SCI_GETBACKSPACEUNINDENTS">SCI_GETBACKSPACEUNINDENTS</a><br />
     <a class="message" href="#SCI_SETLINEINDENTATION">SCI_SETLINEINDENTATION(int line, int
    indentation)</a><br />
     <a class="message" href="#SCI_GETLINEINDENTATION">SCI_GETLINEINDENTATION(int line)</a><br />
     <a class="message" href="#SCI_GETLINEINDENTPOSITION">SCI_GETLINEINDENTPOSITION(int
    line)</a><br />
     <a class="message" href="#SCI_SETINDENTATIONGUIDES">SCI_SETINDENTATIONGUIDES(bool
    view)</a><br />
     <a class="message" href="#SCI_GETINDENTATIONGUIDES">SCI_GETINDENTATIONGUIDES</a><br />
     <a class="message" href="#SCI_SETHIGHLIGHTGUIDE">SCI_SETHIGHLIGHTGUIDE(int column)</a><br />
     <a class="message" href="#SCI_GETHIGHLIGHTGUIDE">SCI_GETHIGHLIGHTGUIDE</a><br />
    </code>

    <p><b id="SCI_SETTABWIDTH">SCI_SETTABWIDTH(int widthInChars)</b><br />
     <b id="SCI_GETTABWIDTH">SCI_GETTABWIDTH</b><br />
     <code>SCI_SETTABWIDTH</code> sets the size of a tab as a multiple of the size of a space
    character in <code>STYLE_DEFAULT</code>. The default tab width is 8 characters. There are no
    limits on tab sizes, but values less than 1 or large values may have undesirable effects.</p>

    <p><b id="SCI_SETUSETABS">SCI_SETUSETABS(bool useTabs)</b><br />
     <b id="SCI_GETUSETABS">SCI_GETUSETABS</b><br />
     <code>SCI_SETUSETABS</code> determines whether indentation should be created out of a mixture
    of tabs and spaces or be based purely on spaces. Set <code>useTabs</code> to <code>false</code>
    (0) to create all tabs and indents out of spaces. The default is <code>true</code>. You can use
    <a class="message" href="#SCI_GETCOLUMN"><code>SCI_GETCOLUMN</code></a> to get the column of a
    position taking the width of a tab into account.</p>
    <p><b id="SCI_SETINDENT">SCI_SETINDENT(int widthInChars)</b><br />
     <b id="SCI_GETINDENT">SCI_GETINDENT</b><br />
     <code>SCI_SETINDENT</code> sets the size of indentation in terms of the width of a space in <a
    class="message" href="#StyleDefinition"><code>STYLE_DEFAULT</code></a>. If you set a width of
    0, the indent size is the same as the tab size. There are no limits on indent sizes, but values
    less than 0 or large values may have undesirable effects.
    </p>

    <p><b id="SCI_SETTABINDENTS">SCI_SETTABINDENTS(bool tabIndents)</b><br />
     <b id="SCI_GETTABINDENTS">SCI_GETTABINDENTS</b><br />
     <b id="SCI_SETBACKSPACEUNINDENTS">SCI_SETBACKSPACEUNINDENTS(bool bsUnIndents)</b><br />
     <b id="SCI_GETBACKSPACEUNINDENTS">SCI_GETBACKSPACEUNINDENTS</b><br />
    </p>

    <p>Inside indentation white space, the tab and backspace keys can be made to indent and
    unindent rather than insert a tab character or delete a character with the
    <code>SCI_SETTABINDENTS</code> and <code>SCI_SETBACKSPACEUNINDENTS</code> functions.</p>

    <p><b id="SCI_SETLINEINDENTATION">SCI_SETLINEINDENTATION(int line, int indentation)</b><br />
     <b id="SCI_GETLINEINDENTATION">SCI_GETLINEINDENTATION(int line)</b><br />
     The amount of indentation on a line can be discovered and set with
    <code>SCI_GETLINEINDENTATION</code> and <code>SCI_SETLINEINDENTATION</code>. The indentation is
    measured in character columns, which correspond to the width of space characters.</p>

    <p><b id="SCI_GETLINEINDENTPOSITION">SCI_GETLINEINDENTPOSITION(int line)</b><br />
     This returns the position at the end of indentation of a line.</p>

    <p><b id="SCI_SETINDENTATIONGUIDES">SCI_SETINDENTATIONGUIDES(int indentView)</b><br />
     <b id="SCI_GETINDENTATIONGUIDES">SCI_GETINDENTATIONGUIDES</b><br />
     Indentation guides are dotted vertical lines that appear within indentation white space every
    indent size columns. They make it easy to see which constructs line up especially when they
    extend over multiple pages. Style <a class="message"
    href="#StyleDefinition"><code>STYLE_INDENTGUIDE</code></a> (37) is used to specify the
    foreground and background colour of the indentation guides.</p>

    <p>There are 4 indentation guide views.
    SC_IV_NONE turns the feature off but the other 3 states determine how far the guides appear on
    empty lines.
    <table border="0" summary="Search flags">
      <tbody>
        <tr>
          <td><code>SC_IV_NONE</code></td>
          <td>No indentation guides are shown.</td>
        </tr>

        <tr>
          <td><code>SC_IV_REAL</code></td>
          <td>Indentation guides are shown inside real indentation white space.</td>
        </tr>

        <tr>
          <td><code>SC_IV_LOOKFORWARD</code></td>
          <td>Indentation guides are shown beyond the actual indentation up to the level of the
          next non-empty line.
          If the previous non-empty line was a fold header then indentation guides are shown for
          one more level of indent than that line. This setting is good for Python.</td>
        </tr>

        <tr>
          <td><code>SC_IV_LOOKBOTH</code></td>
          <td>Indentation guides are shown beyond the actual indentation up to the level of the
          next non-empty line or previous non-empty line whichever is the greater.
          This setting is good for most languages.</td>
        </tr>

    </table>
    </p>

    <p><b id="SCI_SETHIGHLIGHTGUIDE">SCI_SETHIGHLIGHTGUIDE(int column)</b><br />
     <b id="SCI_GETHIGHLIGHTGUIDE">SCI_GETHIGHLIGHTGUIDE</b><br />
     When brace highlighting occurs, the indentation guide corresponding to the braces may be
    highlighted with the brace highlighting style, <a class="message"
    href="#StyleDefinition"><code>STYLE_BRACELIGHT</code></a> (34). Set <code>column</code> to 0 to
    cancel this highlight.</p>

    <h2 id="Markers">Markers</h2>

    <p>There are 32 markers, numbered 0 to 31, and you can assign any combination of them to each
    line in the document. Markers appear in the <a class="jump" href="#Margins">selection
    margin</a> to the left of the text. If the selection margin is set to zero width, the
    background colour of the whole line is changed instead. Marker numbers 25 to 31 are used by
    Scintilla in folding margins, and have symbolic names of the form <code>SC_MARKNUM_</code>*,
    for example <code>SC_MARKNUM_FOLDEROPEN</code>.</p>

    <p>Marker numbers 0 to 24 have no pre-defined function; you can use them to mark syntax errors
    or the current point of execution, break points, or whatever you need marking. If you do not
    need folding, you can use all 32 for any purpose you wish.</p>

    <p>Each marker number has a symbol associated with it. You can also set the foreground and
    background colour for each marker number, so you can use the same symbol more than once with
    different colouring for different uses. Scintilla has a set of symbols you can assign
    (<code>SC_MARK_</code>*) or you can use characters. By default, all 32 markers are set to
    <code>SC_MARK_CIRCLE</code> with a black foreground and a white background.</p>

    <p>The markers are drawn in the order of their numbers, so higher numbered markers appear on
    top of lower numbered ones. Markers try to move with their text by tracking where the start of
    their line moves. When a line is deleted, its markers are combined, by an <code>OR</code>
    operation, with the markers of the previous line.</p>
    <code><a class="message" href="#SCI_MARKERDEFINE">SCI_MARKERDEFINE(int markerNumber, int
    markerSymbols)</a><br />
     <a class="message" href="#SCI_MARKERDEFINEPIXMAP">SCI_MARKERDEFINEPIXMAP(int markerNumber,
    const char *xpm)</a><br />
     <a class="message" href="#SCI_MARKERSYMBOLDEFINED">SCI_MARKERSYMBOLDEFINED(int markerNumber)
     </a><br />
     <a class="message" href="#SCI_MARKERSETFORE">SCI_MARKERSETFORE(int markerNumber, int
    colour)</a><br />
     <a class="message" href="#SCI_MARKERSETBACK">SCI_MARKERSETBACK(int markerNumber, int
    colour)</a><br />
     <a class="message" href="#SCI_MARKERSETALPHA">SCI_MARKERSETALPHA(int markerNumber, int
    alpha)</a><br />
     <a class="message" href="#SCI_MARKERADD">SCI_MARKERADD(int line, int markerNumber)</a><br />
     <a class="message" href="#SCI_MARKERADDSET">SCI_MARKERADDSET(int line, int markerMask)</a><br />
     <a class="message" href="#SCI_MARKERDELETE">SCI_MARKERDELETE(int line, int
    markerNumber)</a><br />
     <a class="message" href="#SCI_MARKERDELETEALL">SCI_MARKERDELETEALL(int markerNumber)</a><br />
     <a class="message" href="#SCI_MARKERGET">SCI_MARKERGET(int line)</a><br />
     <a class="message" href="#SCI_MARKERNEXT">SCI_MARKERNEXT(int lineStart, int
    markerMask)</a><br />
     <a class="message" href="#SCI_MARKERPREVIOUS">SCI_MARKERPREVIOUS(int lineStart, int
    markerMask)</a><br />
     <a class="message" href="#SCI_MARKERLINEFROMHANDLE">SCI_MARKERLINEFROMHANDLE(int
    handle)</a><br />
     <a class="message" href="#SCI_MARKERDELETEHANDLE">SCI_MARKERDELETEHANDLE(int handle)</a><br />
    </code>

    <p><b id="SCI_MARKERDEFINE">SCI_MARKERDEFINE(int markerNumber, int markerSymbols)</b><br />
     This message associates a marker number in the range 0 to 31 with one of the marker symbols or
    an ASCII character. The general-purpose marker symbols currently available are:<br />
     <code>SC_MARK_CIRCLE</code>, <code>SC_MARK_ROUNDRECT</code>, <code>SC_MARK_ARROW</code>,
    <code>SC_MARK_SMALLRECT</code>, <code>SC_MARK_SHORTARROW</code>, <code>SC_MARK_EMPTY</code>,
    <code>SC_MARK_ARROWDOWN</code>, <code>SC_MARK_MINUS</code>, <code>SC_MARK_PLUS</code>,
    <code>SC_MARK_ARROWS</code>, <code>SC_MARK_DOTDOTDOT</code>, <code>SC_MARK_EMPTY</code>,
    <code>SC_MARK_BACKGROUND</code>, <code>SC_MARK_LEFTRECT</code>
    and <code>SC_MARK_FULLRECT</code>.</p>

    <p>The <code>SC_MARK_BACKGROUND</code> marker changes the background colour of the line only.
          The <code>SC_MARK_FULLRECT</code> symbol mirrors this, changing only the margin background colour.
    The <code>SC_MARK_EMPTY</code> symbol is invisible, allowing client code to track the movement
    of lines. You would also use it if you changed the folding style and wanted one or more of the
    <code>SC_FOLDERNUM_</code>* markers to have no associated symbol.</p>
    
    <p>Applications may use the marker symbol <code>SC_MARK_AVAILABLE</code> to indicate that 
    plugins may allocate that marker number.
    </p>

    <p>There are also marker symbols designed for use in the folding margin in a flattened tree
    style.<br />
     <code>SC_MARK_BOXMINUS</code>, <code>SC_MARK_BOXMINUSCONNECTED</code>,
    <code>SC_MARK_BOXPLUS</code>, <code>SC_MARK_BOXPLUSCONNECTED</code>,
    <code>SC_MARK_CIRCLEMINUS</code>, <code>SC_MARK_CIRCLEMINUSCONNECTED</code>,
    <code>SC_MARK_CIRCLEPLUS</code>, <code>SC_MARK_CIRCLEPLUSCONNECTED</code>,
    <code>SC_MARK_LCORNER</code>, <code>SC_MARK_LCORNERCURVE</code>, <code>SC_MARK_TCORNER</code>,
    <code>SC_MARK_TCORNERCURVE</code>, and <code>SC_MARK_VLINE</code>.</p>
     Characters can be used as markers by adding the ASCII value of the character to
    <code>SC_MARK_CHARACTER</code> (10000). For example, to use 'A' (ASCII code 65) as marker
    number 1 use:<br />
     <code>SCI_MARKERDEFINE(1, SC_MARK_CHARACTER+65)</code>. <br />

    <p>The marker numbers <code>SC_MARKNUM_FOLDER</code> and <code>SC_MARKNUM_FOLDEROPEN</code> are
    used for showing that a fold is present and open or closed. Any symbols may be assigned for
    this purpose although the (<code>SC_MARK_PLUS</code>, <code>SC_MARK_MINUS</code>) pair or the
    (<code>SC_MARK_ARROW</code>, <code>SC_MARK_ARROWDOWN</code>) pair are good choices. As well as
    these two, more assignments are needed for the flattened tree style:
    <code>SC_MARKNUM_FOLDEREND</code>, <code>SC_MARKNUM_FOLDERMIDTAIL</code>,
    <code>SC_MARKNUM_FOLDEROPENMID</code>, <code>SC_MARKNUM_FOLDERSUB</code>, and
    <code>SC_MARKNUM_FOLDERTAIL</code>. The bits used for folding are specified by
    <code>SC_MASK_FOLDERS</code>, which is commonly used as an argument to
    <code>SCI_SETMARGINMASKN</code> when defining a margin to be used for folding.</p>

    <p>This table shows which <code>SC_MARK_</code>* symbols should be assigned to which
    <code>SC_MARKNUM_</code>* marker numbers to obtain four folding styles: Arrow (mimics
    Macintosh), plus/minus shows folded lines as '+' and opened folds as '-', Circle tree, Box
    tree.</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Markers used for folding">
      <thead align="left">
        <tr>
          <th><code>SC_MARKNUM_</code>*</th>

          <th>Arrow</th>

          <th>Plus/minus</th>

          <th>Circle tree</th>

          <th>Box tree</th>
        </tr>
      </thead>

      <tbody valign="top">
        <tr>
          <th align="left"><code>FOLDEROPEN</code></th>

          <td><code>ARROWDOWN</code></td>

          <td><code>MINUS</code></td>

          <td><code>CIRCLEMINUS</code></td>

          <td><code>BOXMINUS</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDER</code></th>

          <td><code>ARROW</code></td>

          <td><code>PLUS</code></td>

          <td><code>CIRCLEPLUS</code></td>

          <td><code>BOXPLUS</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDERSUB</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>VLINE</code></td>

          <td><code>VLINE</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDERTAIL</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>LCORNERCURVE</code></td>

          <td><code>LCORNER</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDEREND</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>CIRCLEPLUSCONNECTED</code></td>

          <td><code>BOXPLUSCONNECTED</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDEROPENMID</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>CIRCLEMINUSCONNECTED</code></td>

          <td><code>BOXMINUSCONNECTED</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDERMIDTAIL</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>TCORNERCURVE</code></td>

          <td><code>TCORNER</code></td>
        </tr>
      </tbody>
    </table>

    <p><b id="SCI_MARKERDEFINEPIXMAP">SCI_MARKERDEFINEPIXMAP(int markerNumber, const char
    *xpm)</b><br />
     Markers can be set to pixmaps with this message. The XPM format is used for the pixmap and it
    is limited to pixmaps that use one character per pixel with no named colours.
    The transparent colour may be named 'None'.
    The data should be null terminated.
    Pixmaps use the <code>SC_MARK_PIXMAP</code> marker symbol. You can find the full description of
    the XPM format <a class="jump" href="http://koala.ilog.fr/lehors/xpm.html">here</a>.</p>

    <p><b id="SCI_MARKERSYMBOLDEFINED">SCI_MARKERSYMBOLDEFINED(int markerNumber)</b><br />
     Returns the symbol defined for a markerNumber with <code>SCI_MARKERDEFINE</code> 
     or <code>SC_MARK_PIXMAP</code> if defined with <code>SCI_MARKERDEFINEPIXMAP</code>.</p>

    <p><b id="SCI_MARKERSETFORE">SCI_MARKERSETFORE(int markerNumber, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b id="SCI_MARKERSETBACK">SCI_MARKERSETBACK(int markerNumber, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     These two messages set the foreground and background colour of a marker number.</p>
     <p><b id="SCI_MARKERSETALPHA">SCI_MARKERSETALPHA(int markerNumber, int <a class="jump"
    href="#alpha">alpha</a>)</b><br />
     When markers are drawn in the content area, either because there is no margin for them or
     they are of SC_MARK_BACKGROUND type, they may be drawn translucently by
     setting an alpha value.</p>

    <p><b id="SCI_MARKERADD">SCI_MARKERADD(int line, int markerNumber)</b><br />
     This message adds marker number <code>markerNumber</code> to a line. The message returns -1 if
    this fails (illegal line number, out of memory) or it returns a marker handle number that
    identifies the added marker. You can use this returned handle with <a class="message"
    href="#SCI_MARKERLINEFROMHANDLE"><code>SCI_MARKERLINEFROMHANDLE</code></a> to find where a
    marker is after moving or combining lines and with <a class="message"
    href="#SCI_MARKERDELETEHANDLE"><code>SCI_MARKERDELETEHANDLE</code></a> to delete the marker
    based on its handle. The message does not check the value of markerNumber, nor does it
    check if the line already contains the marker.</p>

    <p><b id="SCI_MARKERADDSET">SCI_MARKERADDSET(int line, int markerMask)</b><br />
     This message can add one or more markers to a line with a single call, specified in the same "one-bit-per-marker" 32-bit integer format returned by
    <a class="message" href="#SCI_MARKERGET"><code>SCI_MARKERGET</code></a>
    (and used by the mask-based marker search functions
    <a class="message" href="#SCI_MARKERNEXT"><code>SCI_MARKERNEXT</code></a> and
    <a class="message" href="#SCI_MARKERPREVIOUS"><code>SCI_MARKERPREVIOUS</code></a>).
    As with
    <a class="message" href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a>, no check is made
    to see if any of the markers are already present on the targeted line.</p>

    <p><b id="SCI_MARKERDELETE">SCI_MARKERDELETE(int line, int markerNumber)</b><br />
     This searches the given line number for the given marker number and deletes it if it is
    present. If you added the same marker more than once to the line, this will delete one copy
    each time it is used. If you pass in a marker number of -1, all markers are deleted from the
    line.</p>

    <p><b id="SCI_MARKERDELETEALL">SCI_MARKERDELETEALL(int markerNumber)</b><br />
     This removes markers of the given number from all lines. If markerNumber is -1, it deletes all
    markers from all lines.</p>

    <p><b id="SCI_MARKERGET">SCI_MARKERGET(int line)</b><br />
     This returns a 32-bit integer that indicates which markers were present on the line. Bit 0 is
    set if marker 0 is present, bit 1 for marker 1 and so on.</p>

    <p><b id="SCI_MARKERNEXT">SCI_MARKERNEXT(int lineStart, int markerMask)</b><br />
     <b id="SCI_MARKERPREVIOUS">SCI_MARKERPREVIOUS(int lineStart, int markerMask)</b><br />
     These messages search efficiently for lines that include a given set of markers. The search
    starts at line number <code>lineStart</code> and continues forwards to the end of the file
    (<code>SCI_MARKERNEXT</code>) or backwards to the start of the file
    (<code>SCI_MARKERPREVIOUS</code>). The <code>markerMask</code> argument should have one bit set
    for each marker you wish to find. Set bit 0 to find marker 0, bit 1 for marker 1 and so on. The
    message returns the line number of the first line that contains one of the markers in
    <code>markerMask</code> or -1 if no marker is found.</p>

    <p><b id="SCI_MARKERLINEFROMHANDLE">SCI_MARKERLINEFROMHANDLE(int markerHandle)</b><br />
     The <code>markerHandle</code> argument is an identifier for a marker returned by <a
    class="message" href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a>. This function searches
    the document for the marker with this handle and returns the line number that contains it or -1
    if it is not found.</p>

    <p><b id="SCI_MARKERDELETEHANDLE">SCI_MARKERDELETEHANDLE(int markerHandle)</b><br />
     The <code>markerHandle</code> argument is an identifier for a marker returned by <a
    class="message" href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a>. This function searches
    the document for the marker with this handle and deletes the marker if it is found.</p>

    <h2 id="Indicators">Indicators</h2>

    <p>Indicators are used to display additional information over the top of styling.
    They can be used to show, for example, syntax errors, deprecated names and bad indentation
    by drawing underlines under text or boxes around text. Originally, Scintilla stored indicator information in
    the style bytes but this has proved limiting, so now up to 32 separately stored indicators may be used.
    While style byte indicators currently still work, they will soon be removed so all the bits in each style
    byte can be used for lexical states.</p>

    <p>Indicators may be displayed as simple underlines, squiggly underlines, a
    line of small 'T' shapes, a line of diagonal hatching, a strike-out or a rectangle around the text.</p>

    <p>The <code>SCI_INDIC*</code> messages allow you to get and set the visual appearance of the
    indicators. They all use an <code>indicatorNumber</code> argument in the range 0 to INDIC_MAX(31)
    to set the indicator to style. To prevent interference the set of indicators is divided up into a range for use
    by lexers (0..7) and a range for use by containers
    (8=<code>INDIC_CONTAINER</code> .. 31=<code>INDIC_MAX</code>).</p>

    <code><a class="message" href="#SCI_INDICSETSTYLE">SCI_INDICSETSTYLE(int indicatorNumber, int
    indicatorStyle)</a><br />
     <a class="message" href="#SCI_INDICGETSTYLE">SCI_INDICGETSTYLE(int indicatorNumber)</a><br />
     <a class="message" href="#SCI_INDICSETFORE">SCI_INDICSETFORE(int indicatorNumber, int
    colour)</a><br />
     <a class="message" href="#SCI_INDICGETFORE">SCI_INDICGETFORE(int indicatorNumber)</a><br />
     <a class="message" href="#SCI_INDICSETALPHA">SCI_INDICSETALPHA(int indicatorNumber, int alpha)</a><br />
     <a class="message" href="#SCI_INDICGETALPHA">SCI_INDICGETALPHA(int indicatorNumber)</a><br />
     <a class="message" href="#SCI_INDICSETUNDER">SCI_INDICSETUNDER(int indicatorNumber, bool under)</a><br />
     <a class="message" href="#SCI_INDICGETUNDER">SCI_INDICGETUNDER(int indicatorNumber)</a><br />
    </code>

    <p><b id="SCI_INDICSETSTYLE">SCI_INDICSETSTYLE(int indicatorNumber, int
    indicatorStyle)</b><br />
     <b id="SCI_INDICGETSTYLE">SCI_INDICGETSTYLE(int indicatorNumber)</b><br />
     These two messages set and get the style for a particular indicator. The indicator styles
    currently available are:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Indicators">
      <tbody>
        <tr>
          <th align="left">Symbol</th>

          <th>Value</th>

          <th align="left">Visual effect</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>INDIC_PLAIN</code></td>

          <td align="center">0</td>

          <td>Underlined with a single, straight line.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_SQUIGGLE</code></td>

          <td align="center">1</td>

          <td>A squiggly underline.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_TT</code></td>

          <td align="center">2</td>

          <td>A line of small T shapes.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_DIAGONAL</code></td>

          <td align="center">3</td>

          <td>Diagonal hatching.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_STRIKE</code></td>

          <td align="center">4</td>

          <td>Strike out.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_HIDDEN</code></td>

          <td align="center">5</td>

          <td>An indicator with no visual effect.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_BOX</code></td>

          <td align="center">6</td>

          <td>A rectangle around the text.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_ROUNDBOX</code></td>

          <td align="center">7</td>

          <td>A rectangle with rounded corners around the text using translucent drawing with the
              interior more transparent than the border. You can use
              <a class="message" href="#SCI_INDICSETALPHA">SCI_INDICSETALPHA</a>
              to control the alpha transparency value. The default alpha value is 30.
        </tr>
      </tbody>
    </table>

    <p>The default indicator styles are equivalent to:<br />
     <code>SCI_INDICSETSTYLE(0, INDIC_SQUIGGLE);</code><br />
     <code>SCI_INDICSETSTYLE(1, INDIC_TT);</code><br />
     <code>SCI_INDICSETSTYLE(2, INDIC_PLAIN);</code></p>

    <p><b id="SCI_INDICSETFORE">SCI_INDICSETFORE(int indicatorNumber, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b id="SCI_INDICGETFORE">SCI_INDICGETFORE(int indicatorNumber)</b><br />
     These two messages set and get the colour used to draw an indicator. The default indicator
    colours are equivalent to:<br />
     <code>SCI_INDICSETFORE(0, 0x007f00);</code> (dark green)<br />
     <code>SCI_INDICSETFORE(1, 0xff0000);</code> (light blue)<br />
     <code>SCI_INDICSETFORE(2, 0x0000ff);</code> (light red)</p>

    <p><b id="SCI_INDICSETALPHA">SCI_INDICSETALPHA(int indicatorNumber, int alpha)</b><br />
     <b id="SCI_INDICGETALPHA">SCI_INDICGETALPHA(int indicatorNumber)</b><br />
     These two messages set and get the alpha transparency used for drawing the
     fill color of the INDIC_ROUNDBOX rectangle. The alpha value can range from
     0 (completely transparent) to 100 (no transparency).
     </p>

    <p><b id="SCI_INDICSETUNDER">SCI_INDICSETUNDER(int indicatorNumber, bool under)</b><br />
     <b id="SCI_INDICGETUNDER">SCI_INDICGETUNDER(int indicatorNumber)</b><br />
     These two messages set and get whether an indicator is drawn under text or over(default).
     Drawing under text works only for modern indicators when <a class="message" href="#SCI_SETTWOPHASEDRAW">two phase drawing</a>
     is enabled.</p>

    <h3 id="Modern Indicators">Modern Indicators</h3>

    <p>Modern indicators are stored in a format similar to run length encoding which is efficient in both
    speed and storage for sparse information.</p>
    <p>An indicator may store different values for each range but currently all values are drawn the same.
    In the future, it may be possible to draw different values in different styles.</p>
    <p>
    <b id="SCI_SETINDICATORCURRENT">SCI_SETINDICATORCURRENT(int indicator)</b><br />
    <b id="SCI_GETINDICATORCURRENT">SCI_GETINDICATORCURRENT</b><br />
    These two messages set and get the indicator that will be affected by calls to
    <a class="message" href="#SCI_INDICATORFILLRANGE">SCI_INDICATORFILLRANGE</a> and
    <a class="message" href="#SCI_INDICATORCLEARRANGE">SCI_INDICATORCLEARRANGE</a>.
    </p>

    <p>
    <b id="SCI_SETINDICATORVALUE">SCI_SETINDICATORVALUE(int value)</b><br />
    <b id="SCI_GETINDICATORVALUE">SCI_GETINDICATORVALUE</b><br />
    These two messages set and get the value that will be set by calls to
    <a class="message" href="#SCI_INDICATORFILLRANGE">SCI_INDICATORFILLRANGE</a>.
    </p>

    <p>
    <b id="SCI_INDICATORFILLRANGE">SCI_INDICATORFILLRANGE(int position, int fillLength)</b><br />
    <b id="SCI_INDICATORCLEARRANGE">SCI_INDICATORCLEARRANGE(int position, int clearLength)</b><br />
    These two messages fill or clear a range for the current indicator.
    <code>SCI_INDICATORFILLRANGE</code> fills with the
    the current value.
    </p>

    <p>
    <b id="SCI_INDICATORALLONFOR">SCI_INDICATORALLONFOR(int position)</b><br />
    Retrieve a bitmap value representing which indicators are non-zero at a position.
    </p>

    <p>
    <b id="SCI_INDICATORVALUEAT">SCI_INDICATORVALUEAT(int indicator, int position)</b><br />
    Retrieve the value of a particular indicator at a position.
    </p>

    <p>
    <b id="SCI_INDICATORSTART">SCI_INDICATORSTART(int indicator, int position)</b><br />
    <b id="SCI_INDICATOREND">SCI_INDICATOREND(int indicator, int position)</b><br />
    Find the start or end of a range with one value from a position within the range.
    Can be used to iterate through the document to discover all the indicator positions.
    </p>

    <h3 id="Style Byte Indicators">Style Byte Indicators (deprecated)</h3>
    <p>By default, Scintilla organizes the style byte associated with each text byte as 5 bits of
    style information (for 32 styles) and 3 bits of indicator information for 3 independent
    indicators so that, for example, syntax errors, deprecated names and bad indentation could all
    be displayed at once.</p>

    <p>The indicators are set using <a class="message"
    href="#SCI_STARTSTYLING"><code>SCI_STARTSTYLING</code></a> with a <code>INDICS_MASK</code> mask
    and <a class="message" href="#SCI_SETSTYLING"><code>SCI_SETSTYLING</code></a> with the values
    <code>INDIC0_MASK</code>, <code>INDIC1_MASK</code> and <code>INDIC2_MASK</code>.</p>

          <p>If you are using indicators in a buffer that has a lexer active
          (see <a class="message" href="#SCI_SETLEXER"><code>SCI_SETLEXER</code></a>),
          you must save lexing state information before setting any indicators and restore it afterwards.
          Use <a class="message" href="#SCI_GETENDSTYLED"><code>SCI_GETENDSTYLED</code></a>
          to retrieve the current "styled to" position and
          <a class="message" href="#SCI_STARTSTYLING"><code>SCI_STARTSTYLING</code></a>
        to reset the styling position and mask (<code>0x1f </code> in the default layout of 5 style bits and 3 indicator bits)
        when you are done.</p>

    <p>The number of bits used for styles can be altered with <a class="message"
    href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a> from 0 to 7 bits. The remaining bits
    can be used for indicators, so there can be from 1 to 8 indicators. However, the
    <code>INDIC*_MASK</code> constants defined in <code>Scintilla.h</code> all assume 5 bits of
    styling information and 3 indicators. If you use a different arrangement, you must define your
    own constants.</p>


    <h2 id="Autocompletion">Autocompletion</h2>

    <p>Autocompletion displays a list box showing likely identifiers based upon the user's typing.
    The user chooses the currently selected item by pressing the tab character or another character
    that is a member of the fillup character set defined with <code>SCI_AUTOCSETFILLUPS</code>.
    Autocompletion is triggered by your application. For example, in C if you detect that the user
    has just typed <code>fred.</code> you could look up <code>fred</code>, and if it has a known
    list of members, you could offer them in an autocompletion list. Alternatively, you could
    monitor the user's typing and offer a list of likely items once their typing has narrowed down
    the choice to a reasonable list. As yet another alternative, you could define a key code to
    activate the list.</p>

    <p>When the user makes a selection from the list the container is sent a <code><a class="message"
    href="#SCN_AUTOCSELECTION">SCN_AUTOCSELECTION</a></code> <a class="jump"
    href="#Notifications">notification message</a>. On return from the notification Scintilla will insert
     the selected text unless the autocompletion list has been cancelled, for example by the container sending
     <code><a class="message" href="#SCI_AUTOCCANCEL">SCI_AUTOCCANCEL</a></code>.</p>

    <p>To make use of autocompletion you must monitor each character added to the document. See
    <code>SciTEBase::CharAdded()</code> in SciTEBase.cxx for an example of autocompletion.</p>
    <code><a class="message" href="#SCI_AUTOCSHOW">SCI_AUTOCSHOW(int lenEntered, const char
    *list)</a><br />
     <a class="message" href="#SCI_AUTOCCANCEL">SCI_AUTOCCANCEL</a><br />
     <a class="message" href="#SCI_AUTOCACTIVE">SCI_AUTOCACTIVE</a><br />
     <a class="message" href="#SCI_AUTOCPOSSTART">SCI_AUTOCPOSSTART</a><br />
     <a class="message" href="#SCI_AUTOCCOMPLETE">SCI_AUTOCCOMPLETE</a><br />
     <a class="message" href="#SCI_AUTOCSTOPS">SCI_AUTOCSTOPS(&lt;unused&gt;, const char
    *chars)</a><br />
     <a class="message" href="#SCI_AUTOCSETSEPARATOR">SCI_AUTOCSETSEPARATOR(char
    separator)</a><br />
     <a class="message" href="#SCI_AUTOCGETSEPARATOR">SCI_AUTOCGETSEPARATOR</a><br />
     <a class="message" href="#SCI_AUTOCSELECT">SCI_AUTOCSELECT(&lt;unused&gt;, const char
    *select)</a><br />
     <a class="message" href="#SCI_AUTOCGETCURRENT">SCI_AUTOCGETCURRENT</a><br />
     <a class="message" href="#SCI_AUTOCSETCANCELATSTART">SCI_AUTOCSETCANCELATSTART(bool
    cancel)</a><br />
     <a class="message" href="#SCI_AUTOCGETCANCELATSTART">SCI_AUTOCGETCANCELATSTART</a><br />
     <a class="message" href="#SCI_AUTOCSETFILLUPS">SCI_AUTOCSETFILLUPS(&lt;unused&gt;, const char
    *chars)</a><br />
     <a class="message" href="#SCI_AUTOCSETCHOOSESINGLE">SCI_AUTOCSETCHOOSESINGLE(bool
    chooseSingle)</a><br />
     <a class="message" href="#SCI_AUTOCGETCHOOSESINGLE">SCI_AUTOCGETCHOOSESINGLE</a><br />
     <a class="message" href="#SCI_AUTOCSETIGNORECASE">SCI_AUTOCSETIGNORECASE(bool
    ignoreCase)</a><br />
     <a class="message" href="#SCI_AUTOCGETIGNORECASE">SCI_AUTOCGETIGNORECASE</a><br />
     <a class="message" href="#SCI_AUTOCSETAUTOHIDE">SCI_AUTOCSETAUTOHIDE(bool autoHide)</a><br />
     <a class="message" href="#SCI_AUTOCGETAUTOHIDE">SCI_AUTOCGETAUTOHIDE</a><br />
     <a class="message" href="#SCI_AUTOCSETDROPRESTOFWORD">SCI_AUTOCSETDROPRESTOFWORD(bool
    dropRestOfWord)</a><br />
     <a class="message" href="#SCI_AUTOCGETDROPRESTOFWORD">SCI_AUTOCGETDROPRESTOFWORD</a><br />
     <a class="message" href="#SCI_REGISTERIMAGE">SCI_REGISTERIMAGE</a><br />
     <a class="message" href="#SCI_CLEARREGISTEREDIMAGES">SCI_CLEARREGISTEREDIMAGES</a><br />
     <a class="message" href="#SCI_AUTOCSETTYPESEPARATOR">SCI_AUTOCSETTYPESEPARATOR(char separatorCharacter)</a><br />
     <a class="message" href="#SCI_AUTOCGETTYPESEPARATOR">SCI_AUTOCGETTYPESEPARATOR</a><br />
     <a class="message" href="#SCI_AUTOCSETMAXHEIGHT">SCI_AUTOCSETMAXHEIGHT(int rowCount)</a><br />
     <a class="message" href="#SCI_AUTOCGETMAXHEIGHT">SCI_AUTOCGETMAXHEIGHT</a><br />
     <a class="message" href="#SCI_AUTOCSETMAXWIDTH">SCI_AUTOCSETMAXWIDTH(int characterCount)</a><br />
     <a class="message" href="#SCI_AUTOCGETMAXWIDTH">SCI_AUTOCGETMAXWIDTH</a><br />
    </code>

    <p><b id="SCI_AUTOCSHOW">SCI_AUTOCSHOW(int lenEntered, const char *list)</b><br />
     This message causes a list to be displayed. <code>lenEntered</code> is the number of
    characters of the word already entered and <code>list</code> is the list of words separated by
    separator characters. The initial separator character is a space but this can be set or got
    with <a class="message" href="#SCI_AUTOCSETSEPARATOR"><code>SCI_AUTOCSETSEPARATOR</code></a>
    and <a class="message"
    href="#SCI_AUTOCGETSEPARATOR"><code>SCI_AUTOCGETSEPARATOR</code></a>.</p>

    <p>The list of words should be in sorted order. If set to ignore case mode with <a
    class="message" href="#SCI_AUTOCSETIGNORECASE"><code>SCI_AUTOCSETIGNORECASE</code></a>, then
    strings are matched after being converted to upper case. One result of this is that the list
    should be sorted with the punctuation characters '[', '\', ']', '^', '_', and '`' sorted after
    letters.</p>

    <p><b id="SCI_AUTOCCANCEL">SCI_AUTOCCANCEL</b><br />
     This message cancels any displayed autocompletion list. When in autocompletion mode, the list
    should disappear when the user types a character that can not be part of the autocompletion,
    such as '.', '(' or '[' when typing an identifier. A set of characters that will cancel
    autocompletion can be specified with <a class="message"
    href="#SCI_AUTOCSTOPS"><code>SCI_AUTOCSTOPS</code></a>.</p>

    <p><b id="SCI_AUTOCACTIVE">SCI_AUTOCACTIVE</b><br />
     This message returns non-zero if there is an active autocompletion list and zero if there is
    not.</p>

    <p><b id="SCI_AUTOCPOSSTART">SCI_AUTOCPOSSTART</b><br />
     This returns the value of the current position when <code>SCI_AUTOCSHOW</code> started display
    of the list.</p>

    <p><b id="SCI_AUTOCCOMPLETE">SCI_AUTOCCOMPLETE</b><br />
     This message triggers autocompletion. This has the same effect as the tab key.</p>

    <p><b id="SCI_AUTOCSTOPS">SCI_AUTOCSTOPS(&lt;unused&gt;, const char *chars)</b><br />
     The <code>chars</code> argument is a string containing a list of characters that will
    automatically cancel the autocompletion list. When you start the editor, this list is
    empty.</p>

    <p><b id="SCI_AUTOCSETSEPARATOR">SCI_AUTOCSETSEPARATOR(char separator)</b><br />
     <b id="SCI_AUTOCGETSEPARATOR">SCI_AUTOCGETSEPARATOR</b><br />
     These two messages set and get the separator character used to separate words in the
    <code>SCI_AUTOCSHOW</code> list. The default is the space character.</p>

    <p><b id="SCI_AUTOCSELECT">SCI_AUTOCSELECT(&lt;unused&gt;, const char *select)</b><br />
     <b id="SCI_AUTOCGETCURRENT">SCI_AUTOCGETCURRENT</b><br />
     This message selects an item in the autocompletion list. It searches the list of words for the
    first that matches <code>select</code>. By default, comparisons are case sensitive, but you can
    change this with <a class="message"
    href="#SCI_AUTOCSETIGNORECASE"><code>SCI_AUTOCSETIGNORECASE</code></a>. The match is character
    by character for the length of the <code>select</code> string. That is, if select is "Fred" it
    will match "Frederick" if this is the first item in the list that begins with "Fred". If an
    item is found, it is selected. If the item is not found, the autocompletion list closes if
    auto-hide is true (see <a class="message"
    href="#SCI_AUTOCSETAUTOHIDE"><code>SCI_AUTOCSETAUTOHIDE</code></a>).<br />
    The current selection can be retrieved with <code>SCI_AUTOCGETCURRENT</code>
    </p>

    <p><b id="SCI_AUTOCSETCANCELATSTART">SCI_AUTOCSETCANCELATSTART(bool cancel)</b><br />
     <b id="SCI_AUTOCGETCANCELATSTART">SCI_AUTOCGETCANCELATSTART</b><br />
     The default behavior is for the list to be cancelled if the caret moves before the location it
    was at when the list was displayed. By calling this message with a <code>false</code> argument,
    the list is not cancelled until the caret moves before the first character of the word being
    completed.</p>

    <p><b id="SCI_AUTOCSETFILLUPS">SCI_AUTOCSETFILLUPS(&lt;unused&gt;, const char *chars)</b><br />
     If a fillup character is typed with an autocompletion list active, the currently selected item
    in the list is added into the document, then the fillup character is added. Common fillup
    characters are '(', '[' and '.' but others are possible depending on the language. By default,
    no fillup characters are set.</p>

    <p><b id="SCI_AUTOCSETCHOOSESINGLE">SCI_AUTOCSETCHOOSESINGLE(bool chooseSingle)</b><br />
     <b id="SCI_AUTOCGETCHOOSESINGLE">SCI_AUTOCGETCHOOSESINGLE</b><br />
     If you use <code>SCI_AUTOCSETCHOOSESINGLE(1)</code> and a list has only one item, it is
    automatically added and no list is displayed. The default is to display the list even if there
    is only a single item.</p>

    <p><b id="SCI_AUTOCSETIGNORECASE">SCI_AUTOCSETIGNORECASE(bool ignoreCase)</b><br />
     <b id="SCI_AUTOCGETIGNORECASE">SCI_AUTOCGETIGNORECASE</b><br />
     By default, matching of characters to list members is case sensitive. These messages let you
    set and get case sensitivity.</p>

    <p><b id="SCI_AUTOCSETAUTOHIDE">SCI_AUTOCSETAUTOHIDE(bool autoHide)</b><br />
     <b id="SCI_AUTOCGETAUTOHIDE">SCI_AUTOCGETAUTOHIDE</b><br />
     By default, the list is cancelled if there are no viable matches (the user has typed
    characters that no longer match a list entry). If you want to keep displaying the original
    list, set <code>autoHide</code> to <code>false</code>. This also effects <a class="message"
    href="#SCI_AUTOCSELECT"><code>SCI_AUTOCSELECT</code></a>.</p>

    <p><b id="SCI_AUTOCSETDROPRESTOFWORD">SCI_AUTOCSETDROPRESTOFWORD(bool dropRestOfWord)</b><br />
     <b id="SCI_AUTOCGETDROPRESTOFWORD">SCI_AUTOCGETDROPRESTOFWORD</b><br />
     When an item is selected, any word characters following the caret are first erased if
    <code>dropRestOfWord</code> is set <code>true</code>. The default is <code>false</code>.</p>

    <p>
      <b id="SCI_REGISTERIMAGE">SCI_REGISTERIMAGE(int type, const char *xpmData)</b><br />
      <b id="SCI_CLEARREGISTEREDIMAGES">SCI_CLEARREGISTEREDIMAGES</b><br />
      <b id="SCI_AUTOCSETTYPESEPARATOR">SCI_AUTOCSETTYPESEPARATOR(char separatorCharacter)</b><br />
      <b id="SCI_AUTOCGETTYPESEPARATOR">SCI_AUTOCGETTYPESEPARATOR</b><br />

      Autocompletion list items may display an image as well as text. Each image is first registered with an integer
      type. Then this integer is included in the text of the list separated by a '?' from the text. For example,
      "fclose?2 fopen" displays image 2 before the string "fclose" and no image before "fopen".
      The images are in XPM format as is described for
      <a class="message" href="#SCI_MARKERDEFINEPIXMAP"><code>SCI_MARKERDEFINEPIXMAP</code></a>
      The set of registered images can be cleared with <code>SCI_CLEARREGISTEREDIMAGES</code> and the '?' separator changed
      with <code>SCI_AUTOCSETTYPESEPARATOR</code>.
    </p>

    <p>
      <b id="SCI_AUTOCSETMAXHEIGHT">SCI_AUTOCSETMAXHEIGHT(int rowCount)</b><br />
      <b id="SCI_AUTOCGETMAXHEIGHT">SCI_AUTOCGETMAXHEIGHT</b><br />

      Get or set the maximum number of rows that will be visible in an autocompletion list. If there are more rows in the list, then a vertical
      scrollbar is shown. The default is 5.
     </p>

    <p>
      <b id="SCI_AUTOCSETMAXWIDTH">SCI_AUTOCSETMAXWIDTH(int characterCount)</b><br />
      <b id="SCI_AUTOCGETMAXWIDTH">SCI_AUTOCGETMAXWIDTH</b><br />

      Get or set the maximum width of an autocompletion list expressed as the number of characters in the longest item that will be totally visible.
      If zero (the default) then the list's width is calculated to fit the item with the most characters. Any items that cannot be fully displayed within
      the available width are indicated by the presence of ellipsis.
     </p>

    <h2 id="UserLists">User lists</h2>

    <p>User lists use the same internal mechanisms as autocompletion lists, and all the calls
    listed for autocompletion work on them; you cannot display a user list at the same time as an
    autocompletion list is active. They differ in the following respects:</p>

    <p>o The <code><a class="message"
    href="#SCI_AUTOCSETCHOOSESINGLE">SCI_AUTOCSETCHOOSESINGLE</a></code> message has no
    effect.<br />
     o When the user makes a selection you are sent a <code><a class="message"
    href="#SCN_USERLISTSELECTION">SCN_USERLISTSELECTION</a></code> <a class="jump"
    href="#Notifications">notification message</a> rather than <code><a class="message"
    href="#SCN_AUTOCSELECTION">SCN_AUTOCSELECTION</a></code>.</p>

    <p>BEWARE: if you have set fillup characters or stop characters, these will still be active
    with the user list, and may result in items being selected or the user list cancelled due to
    the user typing into the editor.</p>

    <p><b id="SCI_USERLISTSHOW">SCI_USERLISTSHOW(int listType, const char *list)</b><br />
     The <code>listType</code> parameter is returned to the container as the <code>wParam</code>
    field of the <a class="message" href="#SCNotification"><code>SCNotification</code></a>
    structure. It must be greater than 0 as this is how Scintilla tells the difference between an
    autocompletion list and a user list. If you have different types of list, for example a list of
    buffers and a list of macros, you can use <code>listType</code> to tell which one has returned
    a selection. </p>

    <h2 id="CallTips">Call tips</h2>

    <p>Call tips are small windows displaying the arguments to a function and are displayed after
    the user has typed the name of the function. They normally display characters using the font
    facename, size and character set defined by
    <code><a class="message" href="#StyleDefinition">STYLE_DEFAULT</a></code>. You can choose to
    use <code><a class="message" href="#StyleDefinition">STYLE_CALLTIP</a></code> to define the
    facename, size, foreground and background colours and character set with
    <code><a class="message" href="#SCI_CALLTIPUSESTYLE">SCI_CALLTIPUSESTYLE</a></code>.
    This also enables support for Tab characters.

    There is some interaction between call tips and autocompletion lists in that showing a
    call tip cancels any active autocompletion list, and vice versa.</p>

    <p>Call tips can highlight part of the text within them. You could use this to highlight the
    current argument to a function by counting the number of commas (or whatever separator your
    language uses). See <code>SciTEBase::CharAdded()</code> in <code>SciTEBase.cxx</code> for an
    example of call tip use.</p>

    <p>The mouse may be clicked on call tips and this causes a
    <code><a class="message" href="#SCN_CALLTIPCLICK">SCN_CALLTIPCLICK</a></code>
    notification to be sent to the container. Small up and down arrows may be displayed within
    a call tip by, respectively, including the characters '\001', or '\002'. This is useful
    for showing that there are overloaded variants of one function name and that the user can
    click on the arrows to cycle through the overloads.</p>

    <p>Alternatively, call tips can be displayed when you leave the mouse pointer for a while over
    a word in response to the <code><a class="message"
    href="#SCN_DWELLSTART">SCN_DWELLSTART</a></code> <a class="jump"
    href="#Notifications">notification</a> and cancelled in response to <code><a class="message"
    href="#SCN_DWELLEND">SCN_DWELLEND</a></code>. This method could be used in a debugger to give
    the value of a variable, or during editing to give information about the word under the
    pointer.</p>
    <code><a class="message" href="#SCI_CALLTIPSHOW">SCI_CALLTIPSHOW(int posStart, const char
    *definition)</a><br />
     <a class="message" href="#SCI_CALLTIPCANCEL">SCI_CALLTIPCANCEL</a><br />
     <a class="message" href="#SCI_CALLTIPACTIVE">SCI_CALLTIPACTIVE</a><br />
     <a class="message" href="#SCI_CALLTIPPOSSTART">SCI_CALLTIPPOSSTART</a><br />
     <a class="message" href="#SCI_CALLTIPSETHLT">SCI_CALLTIPSETHLT(int highlightStart, int
    highlightEnd)</a><br />
     <a class="message" href="#SCI_CALLTIPSETBACK">SCI_CALLTIPSETBACK(int colour)</a><br />
     <a class="message" href="#SCI_CALLTIPSETFORE">SCI_CALLTIPSETFORE(int colour)</a><br />
     <a class="message" href="#SCI_CALLTIPSETFOREHLT">SCI_CALLTIPSETFOREHLT(int colour)</a><br />
     <a class="message" href="#SCI_CALLTIPUSESTYLE">SCI_CALLTIPUSESTYLE(int tabsize)</a><br />
    </code>

    <p><b id="SCI_CALLTIPSHOW">SCI_CALLTIPSHOW(int posStart, const char *definition)</b><br />
     This message starts the process by displaying the call tip window. If a call tip is already
    active, this has no effect.<br />
     <code>posStart</code> is the position in the document at which to align the call tip. The call
    tip text is aligned to start 1 line below this character unless you have included up and/or
    down arrows in the call tip text in which case the tip is aligned to the right-hand edge of
    the rightmost arrow. The assumption is that you will start the text with something like
    "\001 1 of 3 \002".<br />
     <code>definition</code> is the call tip text. This can contain multiple lines separated by
    '\n' (Line Feed, ASCII code 10) characters. Do not include '\r' (Carriage Return, ASCII
     code 13), as this will most likely print as an empty box. '\t' (Tab, ASCII code 9) is
     supported if you set a tabsize with
    <code><a class="message" href="#SCI_CALLTIPUSESTYLE">SCI_CALLTIPUSESTYLE</a></code>.<br /></p>

    <p><b id="SCI_CALLTIPCANCEL">SCI_CALLTIPCANCEL</b><br />
     This message cancels any displayed call tip. Scintilla will also cancel call tips for you if
    you use any keyboard commands that are not compatible with editing the argument list of a
    function.</p>

    <p><b id="SCI_CALLTIPACTIVE">SCI_CALLTIPACTIVE</b><br />
     This returns 1 if a call tip is active and 0 if it is not active.</p>

    <p><b id="SCI_CALLTIPPOSSTART">SCI_CALLTIPPOSSTART</b><br />
     This message returns the value of the current position when <code>SCI_CALLTIPSHOW</code>
    started to display the tip.</p>

    <p><b id="SCI_CALLTIPSETHLT">SCI_CALLTIPSETHLT(int hlStart, int hlEnd)</b><br />
     This sets the region of the call tips text to display in a highlighted style.
    <code>hlStart</code> is the zero-based index into the string of the first character to
    highlight and <code>hlEnd</code> is the index of the first character after the highlight.
    <code>hlEnd</code> must be greater than <code>hlStart</code>; <code>hlEnd-hlStart</code> is the
    number of characters to highlight. Highlights can extend over line ends if this is
    required.</p>

    <p>Unhighlighted text is drawn in a mid gray. Selected text is drawn in a dark blue. The
    background is white. These can be changed with
    <code>SCI_CALLTIPSETBACK</code>,
    <code>SCI_CALLTIPSETFORE</code>, and
    <code>SCI_CALLTIPSETFOREHLT</code>.
    </p>

    <p><b id="SCI_CALLTIPSETBACK">SCI_CALLTIPSETBACK(int colour)</b><br />
     The background colour of call tips can be set with this message; the default colour is white.
    It is not a good idea to set a dark colour as the background as the default colour for normal
    calltip text is mid gray and the defaultcolour for highlighted text is dark blue. This also
    sets the background colour of <code>STYLE_CALLTIP</code>.</p>

    <p><b id="SCI_CALLTIPSETFORE">SCI_CALLTIPSETFORE(int colour)</b><br />
     The colour of call tip text can be set with this message; the default colour is mid gray.
    This also sets the foreground colour of <code>STYLE_CALLTIP</code>.</p>

    <p><b id="SCI_CALLTIPSETFOREHLT">SCI_CALLTIPSETFOREHLT(int colour)</b><br />
     The colour of highlighted call tip text can be set with this message; the default colour
    is dark blue.</p>

    <p><b id="SCI_CALLTIPUSESTYLE">SCI_CALLTIPUSESTYLE(int tabsize)</b><br />
     This message changes the style used for call tips from <code>STYLE_DEFAULT</code> to
    <code>STYLE_CALLTIP</code> and sets a tab size in screen pixels. If <code>tabsize</code> is
    less than 1, Tab characters are not treated specially. Once this call has been used, the
    call tip foreground and background colours are also taken from the style.</p>


    <h2 id="KeyboardCommands">Keyboard commands</h2>

    <p>To allow the container application to perform any of the actions available to the user with
    keyboard, all the keyboard actions are messages. They do not take any parameters. These
    commands are also used when redefining the key bindings with the <a class="message"
    href="#SCI_ASSIGNCMDKEY"><code>SCI_ASSIGNCMDKEY</code></a> message.</p>

    <table border="0" summary="Keyboard commands">
      <tbody>
        <tr>
          <td><code>SCI_LINEDOWN</code></td>

          <td><code>SCI_LINEDOWNEXTEND</code></td>

          <td><code>SCI_LINEDOWNRECTEXTEND</code></td>

          <td><code>SCI_LINESCROLLDOWN</code></td>
        </tr>

        <tr>
          <td><code>SCI_LINEUP</code></td>

          <td><code>SCI_LINEUPEXTEND</code></td>

          <td><code>SCI_LINEUPRECTEXTEND</code></td>

          <td><code>SCI_LINESCROLLUP</code></td>
        </tr>

        <tr>
          <td><code>SCI_PARADOWN</code></td>

          <td><code>SCI_PARADOWNEXTEND</code></td>

          <td><code>SCI_PARAUP</code></td>

          <td><code>SCI_PARAUPEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_CHARLEFT</code></td>

          <td><code>SCI_CHARLEFTEXTEND</code></td>

          <td><code>SCI_CHARLEFTRECTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_CHARRIGHT</code></td>

          <td><code>SCI_CHARRIGHTEXTEND</code></td>

          <td><code>SCI_CHARRIGHTRECTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_WORDLEFT</code></td>

          <td><code>SCI_WORDLEFTEXTEND</code></td>

          <td><code>SCI_WORDRIGHT</code></td>

          <td><code>SCI_WORDRIGHTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_WORDLEFTEND</code></td>

          <td><code>SCI_WORDLEFTENDEXTEND</code></td>

          <td><code>SCI_WORDRIGHTEND</code></td>

          <td><code>SCI_WORDRIGHTENDEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_WORDPARTLEFT</code></td>

          <td><code>SCI_WORDPARTLEFTEXTEND</code></td>

          <td><code>SCI_WORDPARTRIGHT</code></td>

          <td><code>SCI_WORDPARTRIGHTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_HOME</code></td>

          <td><code>SCI_HOMEEXTEND</code></td>

          <td><code>[SCI_HOMERECTEXTEND]</code></td>
        </tr>

        <tr>
          <td><code>SCI_HOMEDISPLAY</code></td>

          <td><code>SCI_HOMEDISPLAYEXTEND</code></td>

          <td><code>SCI_HOMEWRAP</code></td>

          <td><code>SCI_HOMEWRAPEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_VCHOME</code></td>

          <td><code>SCI_VCHOMEEXTEND</code></td>

          <td><code>SCI_VCHOMERECTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_VCHOMEWRAP</code></td>

          <td><code>SCI_VCHOMEWRAPEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_LINEEND</code></td>

          <td><code>SCI_LINEENDEXTEND</code></td>

          <td><code>SCI_LINEENDRECTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_LINEENDDISPLAY</code></td>

          <td><code>SCI_LINEENDDISPLAYEXTEND</code></td>

          <td><code>SCI_LINEENDWRAP</code></td>

          <td><code>SCI_LINEENDWRAPEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_DOCUMENTSTART</code></td>

          <td><code>SCI_DOCUMENTSTARTEXTEND</code></td>

          <td><code>SCI_DOCUMENTEND</code></td>

          <td><code>SCI_DOCUMENTENDEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_PAGEUP</code></td>

          <td><code>SCI_PAGEUPEXTEND</code></td>

          <td><code>SCI_PAGEUPRECTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_PAGEDOWN</code></td>

          <td><code>SCI_PAGEDOWNEXTEND</code></td>

          <td><code>SCI_PAGEDOWNRECTEXTEND</code></td>
        </tr>


        <tr>
          <td><code>SCI_STUTTEREDPAGEUP</code></td>

          <td><code>SCI_STUTTEREDPAGEUPEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_STUTTEREDPAGEDOWN</code></td>

          <td><code>SCI_STUTTEREDPAGEDOWNEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_DELETEBACK</code></td>

          <td><code>SCI_DELETEBACKNOTLINE</code></td>
        </tr>

        <tr>
          <td><code>SCI_DELWORDLEFT</code></td>

          <td><code>SCI_DELWORDRIGHT</code></td>

          <td><code>SCI_DELWORDRIGHTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_DELLINELEFT</code></td>

          <td><code>SCI_DELLINERIGHT</code></td>

          <td><code>SCI_LINEDELETE</code></td>
        </tr>

        <tr>
          <td><code>SCI_LINECUT</code></td>

          <td><code>SCI_LINECOPY</code></td>

          <td><code>SCI_LINETRANSPOSE</code></td>

          <td><code>SCI_LINEDUPLICATE</code></td>
        </tr>

        <tr>
          <td><code>SCI_LOWERCASE</code></td>

          <td><code>SCI_UPPERCASE</code></td>

          <td><code>SCI_CANCEL</code></td>

          <td><code>SCI_EDITTOGGLEOVERTYPE</code></td>
        </tr>

        <tr>
          <td><code>SCI_NEWLINE</code></td>

          <td><code>SCI_FORMFEED</code></td>

          <td><code>SCI_TAB</code></td>

          <td><code>SCI_BACKTAB</code></td>
        </tr>

        <tr>
          <td><code>SCI_SELECTIONDUPLICATE</code></td>

        </tr>
     </tbody>
    </table>

    <p>The <code>SCI_*EXTEND</code> messages extend the selection.</p>

    <p>The <code>SCI_*RECTEXTEND</code> messages extend the rectangular selection
    (and convert regular selection to rectangular one, if any).</p>

    <p>The <code>SCI_WORDPART*</code> commands are used to move between word segments marked by
    capitalisation (aCamelCaseIdentifier) or underscores (an_under_bar_ident).</p>

    <p>The <code>SCI_HOME*</code> commands move the caret to the start of the line, while the
    <code>SCI_VCHOME*</code>commands move the caret to the first non-blank character of the line
    (ie. just after the indentation) unless it is already there; in this case, it acts as SCI_HOME*.</p>

    <p>The <code>SCI_[HOME|LINEEND]DISPLAY*</code> commands are used when in line wrap mode to
    allow movement to the start or end of display lines as opposed to the normal
    <code>SCI_[HOME|LINEEND]</code> commands which move to the start or end of document lines.</p>

    <p>The <code>SCI_[[VC]HOME|LINEEND]WRAP*</code> commands are like their namesakes
    <code>SCI_[[VC]HOME|LINEEND]*</code> except they behave differently when word-wrap is enabled:
     They go first to the start / end of the display line, like <code>SCI_[HOME|LINEEND]DISPLAY*</code>,
     but if the cursor is already at the point, it goes on to the start or end of the document line,
     as appropriate for <code>SCI_[[VC]HOME|LINEEND]*</code>.
     </p>

    <h2 id="KeyBindings">Key bindings</h2>

    <p>There is a default binding of keys to commands that is defined in the Scintilla source in
    the file <code>KeyMap.cxx</code> by the constant <code>KeyMap::MapDefault[]</code>. This table
    maps key definitions to <code>SCI_*</code> messages with no parameters (mostly the <a
    class="jump" href="#KeyboardCommands">keyboard commands</a> discussed above, but any Scintilla
    command that has no arguments can be mapped). You can change the mapping to suit your own
    requirements.</p>
    <code><a class="message" href="#SCI_ASSIGNCMDKEY">SCI_ASSIGNCMDKEY(int keyDefinition, int
    sciCommand)</a><br />
     <a class="message" href="#SCI_CLEARCMDKEY">SCI_CLEARCMDKEY(int keyDefinition)</a><br />
     <a class="message" href="#SCI_CLEARALLCMDKEYS">SCI_CLEARALLCMDKEYS</a><br />
     <a class="message" href="#SCI_NULL">SCI_NULL</a><br />
    </code>

    <p><b id="keyDefinition">keyDefinition</b><br />
     A key definition contains the key code in the low 16-bits and the key modifiers in the high
    16-bits. To combine <code>keyCode</code> and <code>keyMod</code> set:<br />
    <br />
     <code>keyDefinition = keyCode + (keyMod &lt;&lt; 16)</code></p>

    <p>The key code is a visible or control character or a key from the <code>SCK_*</code>
    enumeration, which contains:<br />
     <code>SCK_ADD</code>, <code>SCK_BACK</code>, <code>SCK_DELETE</code>, <code>SCK_DIVIDE</code>,
    <code>SCK_DOWN</code>, <code>SCK_END</code>, <code>SCK_ESCAPE</code>, <code>SCK_HOME</code>,
    <code>SCK_INSERT</code>, <code>SCK_LEFT</code>, <code>SCK_MENU</code>, <code>SCK_NEXT</code> (Page Down),
    <code>SCK_PRIOR</code> (Page Up), <code>SCK_RETURN</code>, <code>SCK_RIGHT</code>,
    <code>SCK_RWIN</code>,
    <code>SCK_SUBTRACT</code>, <code>SCK_TAB</code>, <code>SCK_UP</code>, and
    <code>SCK_WIN</code>.</p>

    <p>The modifiers are a combination of zero or more of <code>SCMOD_ALT</code>,
    <code>SCMOD_CTRL</code>, and <code>SCMOD_SHIFT</code>. If you are building a table, you might
    want to use <code>SCMOD_NORM</code>, which has the value 0, to mean no modifiers.</p>

    <p><b id="SCI_ASSIGNCMDKEY">SCI_ASSIGNCMDKEY(int <a class="jump"
    href="#keyDefinition">keyDefinition</a>, int sciCommand)</b><br />
     This assigns the given key definition to a Scintilla command identified by
    <code>sciCommand</code>. <code>sciCommand</code> can be any <code>SCI_*</code> command that has
    no arguments.</p>

    <p><b id="SCI_CLEARCMDKEY">SCI_CLEARCMDKEY(int <a class="jump"
    href="#keyDefinition">keyDefinition</a>)</b><br />
     This makes the given key definition do nothing by assigning the action <code>SCI_NULL</code>
    to it.</p>

    <p><b id="SCI_CLEARALLCMDKEYS">SCI_CLEARALLCMDKEYS</b><br />
     This command removes all keyboard command mapping by setting an empty mapping table.</p>

    <p><b id="SCI_NULL">SCI_NULL</b><br />
     The <code>SCI_NULL</code> does nothing and is the value assigned to keys that perform no
    action. SCI_NULL ensures that keys do not propagate to the parent window as that may
    cause focus to move. If you want the standard platform behaviour use the constant 0 instead.</p>

    <h2 id="PopupEditMenu">Popup edit menu</h2>

    <p><b id="SCI_USEPOPUP">SCI_USEPOPUP(bool bEnablePopup)</b><br />
     Clicking the wrong button on the mouse pops up a short default editing menu. This may be
    turned off with <code>SCI_USEPOPUP(0)</code>. If you turn it off, context menu commands (in
    Windows, <code>WM_CONTEXTMENU</code>) will not be handled by Scintilla, so the parent of the
    Scintilla window will have the opportunity to handle the message.</p>

    <h2 id="MacroRecording">Macro recording</h2>

    <p>Start and stop macro recording mode. In macro recording mode, actions are reported to the
    container through <code><a class="message" href="#SCN_MACRORECORD">SCN_MACRORECORD</a></code>
    <a class="jump" href="#Notifications">notifications</a>. It is then up to the container to
    record these actions for future replay.</p>

    <p><b id="SCI_STARTRECORD">SCI_STARTRECORD</b><br />
     <b id="SCI_STOPRECORD">SCI_STOPRECORD</b><br />
     These two messages turn macro recording on and off.</p>

    <h2 id="Printing">Printing</h2>

    <p>On Windows <code>SCI_FORMATRANGE</code> can be used to draw the text onto a display context
    which can include a printer display context. Printed output shows text styling as on the
    screen, but it hides all margins except a line number margin. All special marker effects are
    removed and the selection and caret are hidden.</p>
    <code><a class="message" href="#SCI_FORMATRANGE">SCI_FORMATRANGE(bool bDraw, RangeToFormat
    *pfr)</a><br />
     <a class="message" href="#SCI_SETPRINTMAGNIFICATION">SCI_SETPRINTMAGNIFICATION(int
    magnification)</a><br />
     <a class="message" href="#SCI_GETPRINTMAGNIFICATION">SCI_GETPRINTMAGNIFICATION</a><br />
     <a class="message" href="#SCI_SETPRINTCOLOURMODE">SCI_SETPRINTCOLOURMODE(int mode)</a><br />
     <a class="message" href="#SCI_GETPRINTCOLOURMODE">SCI_GETPRINTCOLOURMODE</a><br />
     <a class="message" href="#SCI_SETPRINTWRAPMODE">SCI_SETPRINTWRAPMODE</a><br />
     <a class="message" href="#SCI_GETPRINTWRAPMODE">SCI_GETPRINTWRAPMODE</a><br />
    </code>

    <p><b id="SCI_FORMATRANGE">SCI_FORMATRANGE(bool bDraw, RangeToFormat *pfr)</b><br />
     This call allows Windows users to render a range of text into a device context. If you use
    this for printing, you will probably want to arrange a page header and footer; Scintilla does
    not do this for you. See <code>SciTEWin::Print()</code> in <code>SciTEWinDlg.cxx</code> for an
    example. Each use of this message renders a range of text into a rectangular area and returns
    the position in the document of the next character to print.</p>

    <p><code>bDraw</code> controls if any output is done. Set this to false if you are paginating
    (for example, if you use this with MFC you will need to paginate in
    <code>OnBeginPrinting()</code> before you output each page.</p>
<pre>
struct RangeToFormat {
    SurfaceID hdc;        // The HDC (device context) we print to
    SurfaceID hdcTarget;  // The HDC we use for measuring (may be same as hdc)
    PRectangle rc;        // Rectangle in which to print
    PRectangle rcPage;    // Physically printable page size
    CharacterRange chrg;  // Range of characters to print
};
</pre>

    <p><code>hdc</code> and <code>hdcTarget</code> should both be set to the device context handle
    of the output device (usually a printer). If you print to a metafile these will not be the same
    as Windows metafiles (unlike extended metafiles) do not implement the full API for returning
    information. In this case, set <code>hdcTarget</code> to the screen DC.<br />
     <code>rcPage</code> is the rectangle <code>{0, 0, maxX, maxY}</code> where <code>maxX+1</code>
    and <code>maxY+1</code> are the number of physically printable pixels in x and y.<br />
     <code>rc</code> is the rectangle to render the text in (which will, of course, fit within the
    rectangle defined by rcPage).<br />
     <code>chrg.cpMin</code> and <code>chrg.cpMax</code> define the start position and maximum
    position of characters to output. All of each line within this character range is drawn.</p>

    <p>When printing, the most tedious part is always working out what the margins should be to
    allow for the non-printable area of the paper and printing a header and footer. If you look at
    the printing code in SciTE, you will find that most of it is taken up with this. The loop that
    causes Scintilla to render text is quite simple if you strip out all the margin, non-printable
    area, header and footer code.</p>

    <p><b id="SCI_SETPRINTMAGNIFICATION">SCI_SETPRINTMAGNIFICATION(int magnification)</b><br />
     <b id="SCI_GETPRINTMAGNIFICATION">SCI_GETPRINTMAGNIFICATION</b><br />
     <code>SCI_GETPRINTMAGNIFICATION</code> lets you to print at a different size than the screen
    font. <code>magnification</code> is the number of points to add to the size of each screen
    font. A value of -3 or -4 gives reasonably small print. You can get this value with
    <code>SCI_GETPRINTMAGNIFICATION</code>.</p>

    <p><b id="SCI_SETPRINTCOLOURMODE">SCI_SETPRINTCOLOURMODE(int mode)</b><br />
     <b id="SCI_GETPRINTCOLOURMODE">SCI_GETPRINTCOLOURMODE</b><br />
     These two messages set and get the method used to render coloured text on a printer that is
    probably using white paper. It is especially important to consider the treatment of colour if
    you use a dark or black screen background. Printing white on black uses up toner and ink very
    many times faster than the other way around. You can set the mode to one of:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Colour printing modes">
      <tbody>
        <tr>
          <th align="left">Symbol</th>

          <th>Value</th>

          <th align="left">Purpose</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_PRINT_NORMAL</code></td>

          <td align="center">0</td>

          <td>Print using the current screen colours. This is the default.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_INVERTLIGHT</code></td>

          <td align="center">1</td>

          <td>If you use a dark screen background this saves ink by inverting the light value of
          all colours and printing on a white background.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_BLACKONWHITE</code></td>

          <td align="center">2</td>

          <td>Print all text as black on a white background.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_COLOURONWHITE</code></td>

          <td align="center">3</td>

          <td>Everything prints in its own colour on a white background.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_COLOURONWHITEDEFAULTBG</code></td>

          <td align="center">4</td>

          <td>Everything prints in its own colour on a white background except that line numbers
          use their own background colour.</td>
        </tr>
      </tbody>
    </table>

    <p><b id="SCI_SETPRINTWRAPMODE">SCI_SETPRINTWRAPMODE(int wrapMode)</b><br />
     <b id="SCI_GETPRINTWRAPMODE">SCI_GETPRINTWRAPMODE</b><br />
     These two functions get and set the printer wrap mode. <code>wrapMode</code> can be
     set to <code>SC_WRAP_NONE</code> (0), <code>SC_WRAP_WORD</code> (1) or
     <code>SC_WRAP_CHAR</code> (2). The default is
     <code>SC_WRAP_WORD</code>, which wraps printed output so that all characters fit
     into the print rectangle. If you set <code>SC_WRAP_NONE</code>, each line of text
     generates one line of output and the line is truncated if it is too long to fit
     into the print area.<br />
     <code>SC_WRAP_WORD</code> tries to wrap only between words as indicated by
     white space or style changes although if a word is longer than a line, it will be wrapped before
     the line end. <code>SC_WRAP_CHAR</code> is preferred to
     <code>SC_WRAP_WORD</code> for Asian languages where there is no white space
     between words.</p>

    <h2 id="DirectAccess">Direct access</h2>
    <code><a class="message" href="#SCI_GETDIRECTFUNCTION">SCI_GETDIRECTFUNCTION</a><br />
     <a class="message" href="#SCI_GETDIRECTPOINTER">SCI_GETDIRECTPOINTER</a><br />
     <a class="message" href="#SCI_GETCHARACTERPOINTER">SCI_GETCHARACTERPOINTER</a><br />
    </code>

    <p>On Windows, the message-passing scheme used to communicate between the container and
    Scintilla is mediated by the operating system <code>SendMessage</code> function and can lead to
    bad performance when calling intensively. To avoid this overhead, Scintilla provides messages
    that allow you to call the Scintilla message function directly. The code to do this in C/C++ is
    of the form:</p>
<pre>
#include "Scintilla.h"
SciFnDirect pSciMsg = (SciFnDirect)SendMessage(hSciWnd, SCI_GETDIRECTFUNCTION, 0, 0);
sptr_t pSciWndData = (sptr_t)SendMessage(hSciWnd, SCI_GETDIRECTPOINTER, 0, 0);

// now a wrapper to call Scintilla directly
sptr_t CallScintilla(unsigned int iMessage, uptr_t wParam, sptr_t lParam){
    return pSciMsg(pSciWndData, iMessage, wParam, lParam);
}
</pre>

    <p><code>SciFnDirect</code>, <code>sptr_t</code> and <code>uptr_t</code> are declared in
    <code>Scintilla.h</code>. <code>hSciWnd</code> is the window handle returned when you created
    the Scintilla window.</p>

    <p>While faster, this direct calling will cause problems if performed from a different thread
    to the native thread of the Scintilla window in which case <code>SendMessage(hSciWnd, SCI_*,
    wParam, lParam)</code> should be used to synchronize with the window's thread.</p>

    <p>This feature also works on GTK+ but has no significant impact on speed.</p>

    <p>From version 1.47 on Windows, Scintilla exports a function called
    <code>Scintilla_DirectFunction</code> that can be used the same as the function returned by
    <code>SCI_GETDIRECTFUNCTION</code>. This saves you the call to
    <code>SCI_GETDIRECTFUNCTION</code> and the need to call Scintilla indirectly via the function
    pointer.</p>

    <p><b id="SCI_GETDIRECTFUNCTION">SCI_GETDIRECTFUNCTION</b><br />
     This message returns the address of the function to call to handle Scintilla messages without
    the overhead of passing through the Windows messaging system. You need only call this once,
    regardless of the number of Scintilla windows you create.</p>

    <p><b id="SCI_GETDIRECTPOINTER">SCI_GETDIRECTPOINTER</b><br />
     This returns a pointer to data that identifies which Scintilla window is in use. You must call
    this once for each Scintilla window you create. When you call the direct function, you must
    pass in the direct pointer associated with the target window.</p>

    <p><b id="SCI_GETCHARACTERPOINTER">SCI_GETCHARACTERPOINTER</b><br />
     Move the gap within Scintilla so that the text of the document is stored consecutively
     and ensure there is a NUL character after the text, then return a pointer to the first character.
     Applications may then pass this to a function that accepts a character pointer such as a regular
     expression search or a parser. The pointer should <em>not</em> be written to as that may desynchronize
     the internal state of Scintilla.</p>
     <p>Since any action in Scintilla may change its internal state
     this pointer becomes invalid after any call or by allowing user interface activity. The application
     should reacquire the pointer after making any call to Scintilla or performing any user-interface calls such
     as modifying a progress indicator.</p>
     <p>This call takes similar time to inserting a character at the end of the document and this may
     include moving the document contents. Specifically, all the characters after the document gap
     are moved to before the gap. This compacted state should persist over calls and user interface
     actions that do not change the document contents so reacquiring the pointer afterwards is very
     quick. If this call is used to implement a global replace operation, then each replacement will
     move the gap so if <code>SCI_GETCHARACTERPOINTER</code> is called after
     each replacement then the operation will become O(n^2) rather than O(n). Instead, all
     matches should be found and remembered, then all the replacements performed.</p>

    <h2 id="MultipleViews">Multiple views</h2>

    <p>A Scintilla window and the document that it displays are separate entities. When you create
    a new window, you also create a new, empty document. Each document has a reference count that
    is initially set to 1. The document also has a list of the Scintilla windows that are linked to
    it so when any window changes the document, all other windows in which it appears are notified
    to cause them to update. The system is arranged in this way so that you can work with many
    documents in a single Scintilla window and so you can display a single document in multiple
    windows (for use with splitter windows).</p>

    <p>Although these messages use <code>document *pDoc</code>, to ensure compatibility with future
    releases of Scintilla you should treat <code>pDoc</code> as an opaque <code>void*</code>. That
    is, you can use and store the pointer as described in this section but you should not
    dereference it.</p>
    <code><a class="message" href="#SCI_GETDOCPOINTER">SCI_GETDOCPOINTER</a><br />
     <a class="message" href="#SCI_SETDOCPOINTER">SCI_SETDOCPOINTER(&lt;unused&gt;, document
    *pDoc)</a><br />
     <a class="message" href="#SCI_CREATEDOCUMENT">SCI_CREATEDOCUMENT</a><br />
     <a class="message" href="#SCI_ADDREFDOCUMENT">SCI_ADDREFDOCUMENT(&lt;unused&gt;, document
    *pDoc)</a><br />
     <a class="message" href="#SCI_RELEASEDOCUMENT">SCI_RELEASEDOCUMENT(&lt;unused&gt;, document
    *pDoc)</a><br />
    </code>

    <p><b id="SCI_GETDOCPOINTER">SCI_GETDOCPOINTER</b><br />
     This returns a pointer to the document currently in use by the window. It has no other
    effect.</p>

    <p><b id="SCI_SETDOCPOINTER">SCI_SETDOCPOINTER(&lt;unused&gt;, document *pDoc)</b><br />
     This message does the following:<br />
     1. It removes the current window from the list held by the current document.<br />
     2. It reduces the reference count of the current document by 1.<br />
     3. If the reference count reaches 0, the document is deleted.<br />
     4. <code>pDoc</code> is set as the new document for the window.<br />
     5. If <code>pDoc</code> was 0, a new, empty document is created and attached to the
    window.<br />
     6. If <code>pDoc</code> was not 0, its reference count is increased by 1.</p>

    <p><b id="SCI_CREATEDOCUMENT">SCI_CREATEDOCUMENT</b><br />
     This message creates a new, empty document and returns a pointer to it. This document is not
    selected into the editor and starts with a reference count of 1. This means that you have
    ownership of it and must either reduce its reference count by 1 after using
    <code>SCI_SETDOCPOINTER</code> so that the Scintilla window owns it or you must make sure that
    you reduce the reference count by 1 with <code>SCI_RELEASEDOCUMENT</code> before you close the
    application to avoid memory leaks.</p>

    <p><b id="SCI_ADDREFDOCUMENT">SCI_ADDREFDOCUMENT(&lt;unused&gt;, document *pDoc)</b><br />
     This increases the reference count of a document by 1. If you want to replace the current
    document in the Scintilla window and take ownership of the current document, for example if you
    are editing many documents in one window, do the following:<br />
     1. Use <code>SCI_GETDOCPOINTER</code> to get a pointer to the document,
    <code>pDoc</code>.<br />
     2. Use <code>SCI_ADDREFDOCUMENT(0, pDoc)</code> to increment the reference count.<br />
     3. Use <code>SCI_SETDOCPOINTER(0, pNewDoc)</code> to set a different document or
    <code>SCI_SETDOCPOINTER(0, 0)</code> to set a new, empty document.</p>

    <p><b id="SCI_RELEASEDOCUMENT">SCI_RELEASEDOCUMENT(&lt;unused&gt;, document *pDoc)</b><br />
     This message reduces the reference count of the document identified by <code>pDoc</code>. pDoc
    must be the result of <code>SCI_GETDOCPOINTER</code> or <code>SCI_CREATEDOCUMENT</code> and
    must point at a document that still exists. If you call this on a document with a reference
    count of 1 that is still attached to a Scintilla window, bad things will happen. To keep the
    world spinning in its orbit you must balance each call to <code>SCI_CREATEDOCUMENT</code> or
    <code>SCI_ADDREFDOCUMENT</code> with a call to <code>SCI_RELEASEDOCUMENT</code>.</p>

    <h2 id="Folding">Folding</h2>

    <p>The fundamental operation in folding is making lines invisible or visible. Line visibility
    is a property of the view rather than the document so each view may be displaying a different
    set of lines. From the point of view of the user, lines are hidden and displayed using fold
    points. Generally, the fold points of a document are based on the hierarchical structure of the
    document contents. In Python, the hierarchy is determined by indentation and in C++ by brace
    characters. This hierarchy can be represented within a Scintilla document object by attaching a
    numeric "fold level" to each line. The fold level is most easily set by a lexer, but you can
    also set it with messages.</p>

    <p>It is up to your code to set the connection between user actions and folding and unfolding.
    The best way to see how this is done is to search the SciTE source code for the messages used
    in this section of the documentation and see how they are used. You will also need to use
    markers and a folding margin to complete your folding implementation.
    The <code>"fold"</code> property should be set to <code>"1"</code> with
    <code>SCI_SETPROPERTY("fold", "1")</code> to enable folding. </p>
    <code><a class="message" href="#SCI_VISIBLEFROMDOCLINE">SCI_VISIBLEFROMDOCLINE(int
    docLine)</a><br />
     <a class="message" href="#SCI_DOCLINEFROMVISIBLE">SCI_DOCLINEFROMVISIBLE(int
    displayLine)</a><br />
     <a class="message" href="#SCI_SHOWLINES">SCI_SHOWLINES(int lineStart, int lineEnd)</a><br />
     <a class="message" href="#SCI_HIDELINES">SCI_HIDELINES(int lineStart, int lineEnd)</a><br />
     <a class="message" href="#SCI_GETLINEVISIBLE">SCI_GETLINEVISIBLE(int line)</a><br />
     <a class="message" href="#SCI_SETFOLDLEVEL">SCI_SETFOLDLEVEL(int line, int level)</a><br />
     <a class="message" href="#SCI_GETFOLDLEVEL">SCI_GETFOLDLEVEL(int line)</a><br />
     <a class="message" href="#SCI_SETFOLDFLAGS">SCI_SETFOLDFLAGS(int flags)</a><br />
     <a class="message" href="#SCI_GETLASTCHILD">SCI_GETLASTCHILD(int line, int level)</a><br />
     <a class="message" href="#SCI_GETFOLDPARENT">SCI_GETFOLDPARENT(int line)</a><br />
     <a class="message" href="#SCI_SETFOLDEXPANDED">SCI_SETFOLDEXPANDED(int line, bool
    expanded)</a><br />
     <a class="message" href="#SCI_GETFOLDEXPANDED">SCI_GETFOLDEXPANDED(int line)</a><br />
     <a class="message" href="#SCI_TOGGLEFOLD">SCI_TOGGLEFOLD(int line)</a><br />
     <a class="message" href="#SCI_ENSUREVISIBLE">SCI_ENSUREVISIBLE(int line)</a><br />
     <a class="message" href="#SCI_ENSUREVISIBLEENFORCEPOLICY">SCI_ENSUREVISIBLEENFORCEPOLICY(int
    line)</a><br />
    </code>

    <p><b id="SCI_VISIBLEFROMDOCLINE">SCI_VISIBLEFROMDOCLINE(int docLine)</b><br />
     When some lines are folded, then a particular line in the document may be displayed at a
    different position to its document position. If no lines are folded, this message returns
    <code>docLine</code>. Otherwise, this returns the display line (counting the very first visible
    line as 0). The display line of an invisible line is the same as the previous visible line. The
    display line number of the first line in the document is 0. If there is folding and
    <code>docLine</code> is outside the range of lines in the document, the return value is -1.
    Lines can occupy more than one display line if they wrap.</p>

    <p><b id="SCI_DOCLINEFROMVISIBLE">SCI_DOCLINEFROMVISIBLE(int displayLine)</b><br />
     When some lines are hidden, then a particular line in the document may be displayed at a
    different position to its document position. This message returns the document line number that
    corresponds to a display line (counting the display line of the first line in the document as
    0). If <code>displayLine</code> is less than or equal to 0, the result is 0. If
    <code>displayLine</code> is greater than or equal to the number of displayed lines, the result
    is the number of lines in the document.</p>

    <p><b id="SCI_SHOWLINES">SCI_SHOWLINES(int lineStart, int lineEnd)</b><br />
     <b id="SCI_HIDELINES">SCI_HIDELINES(int lineStart, int lineEnd)</b><br />
     <b id="SCI_GETLINEVISIBLE">SCI_GETLINEVISIBLE(int line)</b><br />
     The first two messages mark a range of lines as visible or invisible and then redraw the
    display. The third message reports on the visible state of a line and returns 1 if it is
    visible and 0 if it is not visible. These messages have no effect on fold levels or fold
    flags. The first line can not be hidden.</p>

    <p><b id="SCI_SETFOLDLEVEL">SCI_SETFOLDLEVEL(int line, int level)</b><br />
     <b id="SCI_GETFOLDLEVEL">SCI_GETFOLDLEVEL(int line)</b><br />
     These two messages set and get a 32-bit value that contains the fold level of a line and some
    flags associated with folding. The fold level is a number in the range 0 to
    <code>SC_FOLDLEVELNUMBERMASK</code> (4095). However, the initial fold level is set to
    <code>SC_FOLDLEVELBASE</code> (1024) to allow unsigned arithmetic on folding levels. There are
    two addition flag bits. <code>SC_FOLDLEVELWHITEFLAG</code> indicates that the line is blank and
    allows it to be treated slightly different then its level may indicate. For example, blank
    lines should generally not be fold points and will be considered part of the preceding section even though
    they may have a lesser fold level.
    <code>SC_FOLDLEVELHEADERFLAG</code> indicates that
    the line is a header (fold point).</p>

    <p>Use <code>SCI_GETFOLDLEVEL(line) &amp; SC_FOLDLEVELNUMBERMASK</code> to get the fold level
    of a line. Likewise, use <code>SCI_GETFOLDLEVEL(line) &amp; SC_FOLDLEVEL*FLAG</code> to get the
    state of the flags. To set the fold level you must or in the associated flags. For instance, to
    set the level to <code>thisLevel</code> and mark a line as being a fold point use:
    <code>SCI_SETFOLDLEVEL(line, thisLevel | SC_FOLDLEVELHEADERFLAG)</code>.</p>
    If you use a lexer, you should not need to use <code>SCI_SETFOLDLEVEL</code> as this is far
    better handled by the lexer. You will need to use <code>SCI_GETFOLDLEVEL</code> to decide how
    to handle user folding requests. If you do change the fold levels, the folding margin will
    update to match your changes.

    <p><b id="SCI_SETFOLDFLAGS">SCI_SETFOLDFLAGS(int flags)</b><br />
     In addition to showing markers in the folding margin, you can indicate folds to the user by
    drawing lines in the text area. The lines are drawn in the foreground colour set for <a
    class="message" href="#StyleDefinition"><code>STYLE_DEFAULT</code></a>. Bits set in
    <code>flags</code> determine where folding lines are drawn:<br />
    </p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Fold flags">
      <tbody>
        <tr>
          <th align="center">Value</th>

          <th align="left">Effect</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="center">1</td>

          <td align="left">Experimental - draw boxes if expanded</td>
        </tr>

        <tr>
          <td align="center">2</td>

          <td align="left">Draw above if expanded</td>
        </tr>

        <tr>
          <td align="center">4</td>

          <td align="left">Draw above if not expanded</td>
        </tr>

        <tr>
          <td align="center">8</td>

          <td align="left">Draw below if expanded</td>
        </tr>

        <tr>
          <td align="center">16</td>

          <td align="left">Draw below if not expanded</td>
        </tr>

        <tr>
          <td align="center">64</td>

          <td align="left">display hexadecimal fold levels in line margin to aid debugging of
          folding. This feature needs to be redesigned to be sensible.</td>
        </tr>
      </tbody>
    </table>

    <p>This message causes the display to redraw.</p>

    <p><b id="SCI_GETLASTCHILD">SCI_GETLASTCHILD(int startLine, int level)</b><br />
     This message searches for the next line after <code>startLine</code>, that has a folding level
    that is less than or equal to <code>level</code> and then returns the previous line number. If
    you set <code>level</code> to -1, <code>level</code> is set to the folding level of line
    <code>startLine</code>. If <code>from</code> is a fold point, <code>SCI_GETLASTCHILD(from,
    -1)</code> returns the last line that would be in made visible or hidden by toggling the fold
    state.</p>

    <p><b id="SCI_GETFOLDPARENT">SCI_GETFOLDPARENT(int startLine)</b><br />
     This message returns the line number of the first line before <code>startLine</code> that is
    marked as a fold point with <code>SC_FOLDLEVELHEADERFLAG</code> and has a fold level less than
    the <code>startLine</code>. If no line is found, or if the header flags and fold levels are
    inconsistent, the return value is -1.</p>

    <p><b id="SCI_TOGGLEFOLD">SCI_TOGGLEFOLD(int line)</b><br />
     Each fold point may be either expanded, displaying all its child lines, or contracted, hiding
    all the child lines. This message toggles the folding state of the given line as long as it has
    the <code>SC_FOLDLEVELHEADERFLAG</code> set. This message takes care of folding or expanding
    all the lines that depend on the line. The display updates after this message.</p>

    <p><b id="SCI_SETFOLDEXPANDED">SCI_SETFOLDEXPANDED(int line, bool expanded)</b><br />
     <b id="SCI_GETFOLDEXPANDED">SCI_GETFOLDEXPANDED(int line)</b><br />
     These messages set and get the expanded state of a single line. The set message has no effect
    on the visible state of the line or any lines that depend on it. It does change the markers in
    the folding margin. If you ask for the expansion state of a line that is outside the document,
    the result is <code>false</code> (0).</p>

    <p>If you just want to toggle the fold state of one line and handle all the lines that are
    dependent on it, it is much easier to use <code>SCI_TOGGLEFOLD</code>. You would use the
    <code>SCI_SETFOLDEXPANDED</code> message to process many folds without updating the display
    until you had finished. See <code>SciTEBase::FoldAll()</code> and
    <code>SciTEBase::Expand()</code> for examples of the use of these messages.</p>

    <p><b id="SCI_ENSUREVISIBLE">SCI_ENSUREVISIBLE(int line)</b><br />
     <b id="SCI_ENSUREVISIBLEENFORCEPOLICY">SCI_ENSUREVISIBLEENFORCEPOLICY(int line)</b><br />
     A line may be hidden because more than one of its parent lines is contracted. Both these
    message travels up the fold hierarchy, expanding any contracted folds until they reach the top
    level. The line will then be visible. If you use <code>SCI_ENSUREVISIBLEENFORCEPOLICY</code>,
    the vertical caret policy set by <a class="message"
    href="#SCI_SETVISIBLEPOLICY"><code>SCI_SETVISIBLEPOLICY</code></a> is then applied.</p>

    <h2 id="LineWrapping">Line wrapping</h2>

    <code><a class="message" href="#SCI_SETWRAPMODE">SCI_SETWRAPMODE(int wrapMode)</a><br />
     <a class="message" href="#SCI_GETWRAPMODE">SCI_GETWRAPMODE</a><br />
     <a class="message" href="#SCI_SETWRAPVISUALFLAGS">SCI_SETWRAPVISUALFLAGS(int wrapVisualFlags)</a><br />
     <a class="message" href="#SCI_GETWRAPVISUALFLAGS">SCI_GETWRAPVISUALFLAGS</a><br />
     <a class="message" href="#SCI_SETWRAPVISUALFLAGSLOCATION">SCI_SETWRAPVISUALFLAGSLOCATION(int wrapVisualFlagsLocation)</a><br />
     <a class="message" href="#SCI_GETWRAPVISUALFLAGSLOCATION">SCI_GETWRAPVISUALFLAGSLOCATION</a><br />
     <a class="message" href="#SCI_SETWRAPSTARTINDENT">SCI_SETWRAPSTARTINDENT(int indent)</a><br />
     <a class="message" href="#SCI_GETWRAPSTARTINDENT">SCI_GETWRAPSTARTINDENT</a><br />
     <a class="message" href="#SCI_SETLAYOUTCACHE">SCI_SETLAYOUTCACHE(int cacheMode)</a><br />
     <a class="message" href="#SCI_GETLAYOUTCACHE">SCI_GETLAYOUTCACHE</a><br />
     <a class="message" href="#SCI_SETPOSITIONCACHE">SCI_SETPOSITIONCACHE(int size)</a><br />
     <a class="message" href="#SCI_GETPOSITIONCACHE">SCI_GETPOSITIONCACHE</a><br />
     <a class="message" href="#SCI_LINESSPLIT">SCI_LINESSPLIT(int pixelWidth)</a><br />
     <a class="message" href="#SCI_LINESJOIN">SCI_LINESJOIN</a><br />
     <a class="message" href="#SCI_WRAPCOUNT">SCI_WRAPCOUNT(int docLine)</a><br />
    </code>

    <p>By default, Scintilla does not wrap lines of text. If you enable line wrapping, lines wider
    than the window width are continued on the following lines. Lines are broken after space or tab
    characters or between runs of different styles. If this is not possible because a word in one
    style is wider than the window then the break occurs after the last character that completely
    fits on the line. The horizontal scroll bar does not appear when wrap mode is on.</p>

        <p>For wrapped lines Scintilla can draw visual flags (little arrows) at end of a a subline of a
        wrapped line and at begin of the next subline. These can be enabled individually, but if Scintilla
        draws the visual flag at begin of the next subline this subline will be indented by one char.
        Independent from drawing a visual flag at the begin the subline can have an indention.</p>

    <p>Much of the time used by Scintilla is spent on laying out and drawing text. The same text
    layout calculations may be performed many times even when the data used in these calculations
    does not change. To avoid these unnecessary calculations in some circumstances, the line layout
    cache can store the results of the calculations. The cache is invalidated whenever the
    underlying data, such as the contents or styling of the document changes. Caching the layout of
    the whole document has the most effect, making dynamic line wrap as much as 20 times faster but
    this requires 7 times the memory required by the document contents plus around 80 bytes per
    line.</p>

    <p>Wrapping is not performed immediately there is a change but is delayed until the display
    is redrawn. This delay improves peformance by allowing a set of changes to be performed
    and then wrapped and displayed once. Because of this, some operations may not occur as
    expected. If a file is read and the scroll position moved to a particular line in the text,
    such as occurs when a container tries to restore a previous editing session, then
    the scroll position will have been determined before wrapping so an unexpected range
    of text will be displayed. To scroll to the position correctly, delay the scroll until the
    wrapping has been performed by waiting for an initial
    <a class="message" href="#SCN_PAINTED">SCN_PAINTED</a> notification.</p>

    <p><b id="SCI_SETWRAPMODE">SCI_SETWRAPMODE(int wrapMode)</b><br />
     <b id="SCI_GETWRAPMODE">SCI_GETWRAPMODE</b><br />
     Set wrapMode to <code>SC_WRAP_WORD</code> (1) to enable wrapping
     on word boundaries, <code>SC_WRAP_CHAR</code> (2) to enable wrapping
     between any characters, and to <code>SC_WRAP_NONE</code> (0) to disable line
     wrapping. <code>SC_WRAP_CHAR</code> is preferred to
     <code>SC_WRAP_WORD</code> for Asian languages where there is no white space
     between words.</p>


    <p><b id="SCI_SETWRAPVISUALFLAGS">SCI_SETWRAPVISUALFLAGS(int wrapVisualFlags)</b><br />
     <b id="SCI_GETWRAPVISUALFLAGS">SCI_GETWRAPVISUALFLAGS</b><br />
                You can enable the drawing of visual flags to indicate a line is wrapped. Bits set in
                wrapVisualFlags determine which visual flags are drawn.

    <table cellpadding="1" cellspacing="2" border="0" summary="Wrap visual flags">
      <tbody>
        <tr>
          <th align="left">Symbol</th>
          <th>Value</th>
          <th align="left">Effect</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAG_NONE</code></td>
          <td align="center">0</td>
          <td>No visual flags</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAG_END</code></td>
          <td align="center">1</td>
          <td>Visual flag at end of subline of a wrapped line.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAG_START</code></td>
          <td align="center">2</td>
          <td>Visual flag at begin of subline of a wrapped line.<br />
                                             Subline is indented by at least 1 to make room for the flag.<br />
                                </td>
        </tr>
      </tbody>
    </table>

    <p><b id="SCI_SETWRAPVISUALFLAGSLOCATION">SCI_SETWRAPVISUALFLAGSLOCATION(int wrapVisualFlagsLocation)</b><br />
     <b id="SCI_GETWRAPVISUALFLAGSLOCATION">SCI_GETWRAPVISUALFLAGSLOCATION</b><br />
                You can set wether the visual flags to indicate a line is wrapped are drawn near the border or near the text.
                Bits set in wrapVisualFlagsLocation set the location to near the text for the corresponding visual flag.

    <table cellpadding="1" cellspacing="2" border="0" summary="Wrap visual flags locations">
      <tbody>
        <tr>
          <th align="left">Symbol</th>
          <th>Value</th>
          <th align="left">Effect</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAGLOC_DEFAULT</code></td>
          <td align="center">0</td>
          <td>Visual flags drawn near border</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAGLOC_END_BY_TEXT</code></td>
          <td align="center">1</td>
          <td>Visual flag at end of subline drawn near text</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAGLOC_START_BY_TEXT</code></td>
          <td align="center">2</td>
          <td>Visual flag at begin of subline drawn near text</td>
        </tr>
      </tbody>
    </table>
    </p>

    <p><b id="SCI_SETWRAPSTARTINDENT">SCI_SETWRAPSTARTINDENT(int indent)</b><br />
     <b id="SCI_GETWRAPSTARTINDENT">SCI_GETWRAPSTARTINDENT</b><br />
     <code>SCI_SETWRAPSTARTINDENT</code> sets the size of indentation of sublines for
                 wrapped lines in terms of the width of a space in
                <a class="message" href="#StyleDefinition"><code>STYLE_DEFAULT</code></a>.
                There are no limits on indent sizes, but values        less than 0 or large values may have
                undesirable effects.<br />
                The indention of sublines is independent of visual flags, but if
                <code>SC_WRAPVISUALFLAG_START</code> is set an indent of at least 1 is used.
     </p>

    <p><b id="SCI_SETLAYOUTCACHE">SCI_SETLAYOUTCACHE(int cacheMode)</b><br />
     <b id="SCI_GETLAYOUTCACHE">SCI_GETLAYOUTCACHE</b><br />
     You can set <code>cacheMode</code> to one of the symbols in the table:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Line caching styles">
      <tbody>
        <tr>
          <th align="left">Symbol</th>

          <th>Value</th>

          <th align="left">Layout cached for these lines</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_CACHE_NONE</code></td>

          <td align="center">0</td>

          <td>No lines are cached.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_CACHE_CARET</code></td>

          <td align="center">1</td>

          <td>The line containing the text caret. This is the default.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_CACHE_PAGE</code></td>

          <td align="center">2</td>

          <td>Visible lines plus the line containing the caret.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_CACHE_DOCUMENT</code></td>

          <td align="center">3</td>

          <td>All lines in the document.</td>
        </tr>
      </tbody>
    </table>
    </p>

    <p><b id="SCI_SETPOSITIONCACHE">SCI_SETPOSITIONCACHE(int size)</b><br />
     <b id="SCI_GETPOSITIONCACHE">SCI_GETPOSITIONCACHE</b><br />
     The position cache stores position information for short runs of text
     so that their layout can be determined more quickly if the run recurs.
     The size in entries of this cache can be set with <code>SCI_SETPOSITIONCACHE</code>.</p>

    <p><b id="SCI_LINESSPLIT">SCI_LINESSPLIT(int pixelWidth)</b><br />
     Split a range of lines indicated by the target into lines that are at most pixelWidth wide.
     Splitting occurs on word boundaries wherever possible in a similar manner to line wrapping.
     When <code>pixelWidth</code> is 0 then the width of the window is used.
     </p>

    <p><b id="SCI_LINESJOIN">SCI_LINESJOIN</b><br />
     Join a range of lines indicated by the target into one line by
     removing line end characters.
     Where this would lead to no space between words, an extra space is inserted.
     </p>

    <p><b id="SCI_WRAPCOUNT">SCI_WRAPCOUNT(int docLine)</b><br />
    Document lines can occupy more than one display line if they wrap and this
    returns the number of display lines needed to wrap a document line.</p>

    <h2 id="Zooming">Zooming</h2>

    <p>Scintilla incorporates a "zoom factor" that lets you make all the text in the document
    larger or smaller in steps of one point. The displayed point size never goes below 2, whatever
    zoom factor you set. You can set zoom factors in the range -10 to +20 points.</p>
    <code><a class="message" href="#SCI_ZOOMIN">SCI_ZOOMIN</a><br />
     <a class="message" href="#SCI_ZOOMOUT">SCI_ZOOMOUT</a><br />
     <a class="message" href="#SCI_SETZOOM">SCI_SETZOOM(int zoomInPoints)</a><br />
     <a class="message" href="#SCI_GETZOOM">SCI_GETZOOM</a><br />
    </code>

    <p><b id="SCI_ZOOMIN">SCI_ZOOMIN</b><br />
     <b id="SCI_ZOOMOUT">SCI_ZOOMOUT</b><br />
     <code>SCI_ZOOMIN</code> increases the zoom factor by one point if the current zoom factor is
    less than 20 points. <code>SCI_ZOOMOUT</code> decreases the zoom factor by one point if the
    current zoom factor is greater than -10 points.</p>

    <p><b id="SCI_SETZOOM">SCI_SETZOOM(int zoomInPoints)</b><br />
     <b id="SCI_GETZOOM">SCI_GETZOOM</b><br />
     These messages let you set and get the zoom factor directly. There is no limit set on the
    factors you can set, so limiting yourself to -10 to +20 to match the incremental zoom functions
    is a good idea.</p>

    <h2 id="LongLines">Long lines</h2>

    <p>You can choose to mark lines that exceed a given length by drawing a vertical line or by
    colouring the background of characters that exceed the set length.</p>
    <code><a class="message" href="#SCI_SETEDGEMODE">SCI_SETEDGEMODE(int mode)</a><br />
     <a class="message" href="#SCI_GETEDGEMODE">SCI_GETEDGEMODE</a><br />
     <a class="message" href="#SCI_SETEDGECOLUMN">SCI_SETEDGECOLUMN(int column)</a><br />
     <a class="message" href="#SCI_GETEDGECOLUMN">SCI_GETEDGECOLUMN</a><br />
     <a class="message" href="#SCI_SETEDGECOLOUR">SCI_SETEDGECOLOUR(int colour)</a><br />
     <a class="message" href="#SCI_GETEDGECOLOUR">SCI_GETEDGECOLOUR</a><br />
    </code>

    <p><b id="SCI_SETEDGEMODE">SCI_SETEDGEMODE(int edgeMode)</b><br />
     <b id="SCI_GETEDGEMODE">SCI_GETEDGEMODE</b><br />
     These two messages set and get the mode used to display long lines. You can set one of the
    values in the table:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Long line styles">
      <tbody>
        <tr>
          <th align="left">Symbol</th>

          <th>Value</th>

          <th align="left">Long line display mode</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>EDGE_NONE</code></td>

          <td align="center">0</td>

          <td>Long lines are not marked. This is the default state.</td>
        </tr>

        <tr>
          <td align="left"><code>EDGE_LINE</code></td>

          <td align="center">1</td>

          <td>A vertical line is drawn at the column number set by <code>SCI_SETEDGECOLUMN</code>.
          This works well for monospaced fonts. The line is drawn at a position based on the width
          of a space character in <a class="message"
          href="#StyleDefinition"><code>STYLE_DEFAULT</code></a>, so it may not work very well if
          your styles use proportional fonts or if your style have varied font sizes or you use a
          mixture of bold, italic and normal text.</td>
        </tr>

        <tr>
          <td align="left"><code>EDGE_BACKGROUND</code></td>

          <td align="center">2</td>

          <td>The background colour of characters after the column limit is changed to the colour
          set by <code>SCI_SETEDGECOLOUR</code>. This is recommended for proportional fonts.</td>
        </tr>
      </tbody>
    </table>

    <p><b id="SCI_SETEDGECOLUMN">SCI_SETEDGECOLUMN(int column)</b><br />
     <b id="SCI_GETEDGECOLUMN">SCI_GETEDGECOLUMN</b><br />
     These messages set and get the column number at which to display the long line marker. When
    drawing lines, the column sets a position in units of the width of a space character in
    <code>STYLE_DEFAULT</code>. When setting the background colour, the column is a character count
    (allowing for tabs) into the line.</p>

    <p><b id="SCI_SETEDGECOLOUR">SCI_SETEDGECOLOUR(int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b id="SCI_GETEDGECOLOUR">SCI_GETEDGECOLOUR</b><br />
     These messages set and get the colour of the marker used to show that a line has exceeded the
    length set by <code>SCI_SETEDGECOLUMN</code>.</p>

    <h2 id="Lexer">Lexer</h2>

    <p>If you define the symbol <code>SCI_LEXER</code> when building Scintilla, (this is sometimes
    called the SciLexer version of Scintilla), lexing support for a wide range programming
    languages is included and the messages in this section are supported. If you want to set
    styling and fold points for an unsupported language you can either do this in the container or
    better still, write your own lexer following the pattern of one of the existing ones.</p>

    <p>Scintilla also supports external lexers. These are DLLs (on Windows) or .so modules (on GTK+/Linux) that export four
    functions: <code>GetLexerCount</code>, <code>GetLexerName</code>, <code>Lex</code> and
    <code>Fold</code>. See <code>externalLexer.cxx</code> for more.</p>
    <code><a class="message" href="#SCI_SETLEXER">SCI_SETLEXER(int lexer)</a><br />
     <a class="message" href="#SCI_GETLEXER">SCI_GETLEXER</a><br />
     <a class="message" href="#SCI_SETLEXERLANGUAGE">SCI_SETLEXERLANGUAGE(&lt;unused&gt;, char
    *name)</a><br />
     <a class="message" href="#SCI_LOADLEXERLIBRARY">SCI_LOADLEXERLIBRARY(&lt;unused&gt;, char
    *path)</a><br />
     <a class="message" href="#SCI_COLOURISE">SCI_COLOURISE(int start, int end)</a><br />
     <a class="message" href="#SCI_SETPROPERTY">SCI_SETPROPERTY(const char *key, const char *value)</a><br />
     <a class="message" href="#SCI_GETPROPERTY">SCI_GETPROPERTY(const char *key, char *value)</a><br />
     <a class="message" href="#SCI_GETPROPERTYEXPANDED">SCI_GETPROPERTYEXPANDED(const char *key, char *value)</a><br />
     <a class="message" href="#SCI_GETPROPERTYINT">SCI_GETPROPERTYINT(const char *key, int default)</a><br />
     <a class="message" href="#SCI_SETKEYWORDS">SCI_SETKEYWORDS(int keyWordSet, const char
    *keyWordList)</a><br />
     <a class="message" href="#SCI_GETSTYLEBITSNEEDED">SCI_GETSTYLEBITSNEEDED</a>
    <br />
    </code>

    <p><b id="SCI_SETLEXER">SCI_SETLEXER(int lexer)</b><br />
     <b id="SCI_GETLEXER">SCI_GETLEXER</b><br />
     You can select the lexer to use with an integer code from the <code>SCLEX_*</code> enumeration
    in <code>Scintilla.h</code>. There are two codes in this sequence that do not use lexers:
    <code>SCLEX_NULL</code> to select no lexing action and <code>SCLEX_CONTAINER</code> which sends
    the <code><a class="message" href="#SCN_STYLENEEDED">SCN_STYLENEEDED</a></code> notification to
    the container whenever a range of text needs to be styled. You cannot use the
    <code>SCLEX_AUTOMATIC</code> value; this identifies additional external lexers that Scintilla
    assigns unused lexer numbers to.</p>

    <p><b id="SCI_SETLEXERLANGUAGE">SCI_SETLEXERLANGUAGE(&lt;unused&gt;, const char *name)</b><br />
     This message lets you select a lexer by name, and is the only method if you are using an
    external lexer or if you have written a lexer module for a language of your own and do not wish
    to assign it an explicit lexer number. To select an existing lexer, set <code>name</code> to
    match the (case sensitive) name given to the module, for example "ada" or "python", not "Ada"
    or "Python". To locate the name for the built-in lexers, open the relevant
    <code>Lex*.cxx</code> file and search for <code>LexerModule</code>. The third argument in the
    <code>LexerModule</code> constructor is the name to use.</p>

    <p>To test if your lexer assignment worked, use <a class="message"
    href="#SCI_GETLEXER"><code>SCI_GETLEXER</code></a> before and after setting the new lexer to
    see if the lexer number changed.</p>

    <p><b id="SCI_LOADLEXERLIBRARY">SCI_LOADLEXERLIBRARY(&lt;unused&gt;, const char *path)</b><br />
     Load a lexer implemented in a shared library. This is a .so file on GTK+/Linux or a .DLL file on Windows.
     </p>

    <p><b id="SCI_COLOURISE">SCI_COLOURISE(int startPos, int endPos)</b><br />
     This requests the current lexer or the container (if the lexer is set to
    <code>SCLEX_CONTAINER</code>) to style the document between <code>startPos</code> and
    <code>endPos</code>. If <code>endPos</code> is -1, the document is styled from
    <code>startPos</code> to the end. If the <code>"fold"</code> property is set to
    <code>"1"</code> and your lexer or container supports folding, fold levels are also set. This
    message causes a redraw.</p>

    <p><b id="SCI_SETPROPERTY">SCI_SETPROPERTY(const char *key, const char *value)</b><br />
     You can communicate settings to lexers with keyword:value string pairs. There is no limit to
    the number of keyword pairs you can set, other than available memory. <code>key</code> is a
    case sensitive keyword, <code>value</code> is a string that is associated with the keyword. If
    there is already a value string associated with the keyword, it is replaced. If you pass a zero
    length string, the message does nothing. Both <code>key</code> and <code>value</code> are used
    without modification; extra spaces at the beginning or end of <code>key</code> are
    significant.</p>

    <p>The <code>value</code> string can refer to other keywords. For example,
    <code>SCI_SETPROPERTY("foldTimes10", "$(fold)0")</code> stores the string
    <code>"$(fold)0"</code>, but when this is accessed, the <code>$(fold)</code> is replaced by the
    value of the <code>"fold"</code> keyword (or by nothing if this keyword does not exist).</p>

    <p>Currently the "fold" property is defined for most of the lexers to set the fold structure if
    set to "1". <code>SCLEX_PYTHON</code> understands <code>"tab.timmy.whinge.level"</code> as a
    setting that determines how to indicate bad indentation. Most keywords have values that are
    interpreted as integers. Search the lexer sources for <code>GetPropertyInt</code> to see how
    properties are used.</p>

    <p>There is a convention for naming properties used by lexers so that the set of properties can be found by scripts.
    Property names should start with "lexer.&lt;lexer&gt;." or "fold.&lt;lexer&gt;." when they apply to one
    lexer or start with "lexer." or "fold." if they apply to multiple lexers.</p>

    <p><b id="SCI_GETPROPERTY">SCI_GETPROPERTY(const char *key, char *value)</b><br />
    Lookup a keyword:value pair using the specified key; if found, copy the value to the user-supplied
    buffer and return the length (not including the terminating 0).  If not found, copy an empty string
    to the buffer and return 0.</p>

    <p>Note that  "keyword replacement" as described in <a class="message" href="#SCI_SETPROPERTY">
    <code>SCI_SETPROPERTY</code></a> will not be performed.</p>

    <p>If the value argument is 0 then the length that should be allocated to store the value is returned;
    again, the terminating 0 is not included.</p>

    <p><b id="SCI_GETPROPERTYEXPANDED">SCI_GETPROPERTYEXPANDED(const char *key, char *value)</b><br />
    Lookup a keyword:value pair using the specified key; if found, copy the value to the user-supplied
    buffer and return the length (not including the terminating 0).  If not found, copy an empty string
    to the buffer and return 0.</p>

    <p>Note that  "keyword replacement" as described in <a class="message" href="#SCI_SETPROPERTY">
    <code>SCI_SETPROPERTY</code></a> will be performed.</p>

    <p>If the value argument is 0 then the length that should be allocated to store the value (including any indicated keyword replacement)
    is returned; again, the terminating 0 is not included.</p>

    <p><b id="SCI_GETPROPERTYINT">SCI_GETPROPERTYINT(const char *key, int default)</b><br />
    Lookup a keyword:value pair using the specified key; if found, interpret the value as an integer and return it.
    If not found (or the value is an empty string) then return the supplied default.  If the keyword:value pair is found but is not
    a number, then return 0.</p>

    <p>Note that  "keyword replacement" as described in <a class="message" href="#SCI_SETPROPERTY">
    <code>SCI_SETPROPERTY</code></a> will be performed before any numeric interpretation.</p>

    <p><b id="SCI_SETKEYWORDS">SCI_SETKEYWORDS(int keyWordSet, const char *keyWordList)</b><br />
     You can set up to 9 lists of keywords for use by the current lexer. This was increased from 6
    at revision 1.50. <code>keyWordSet</code> can be 0 to 8 (actually 0 to <code>KEYWORDSET_MAX</code>)
    and selects which keyword list to replace. <code>keyWordList</code> is a list of keywords
    separated by spaces, tabs, <code>"\n"</code> or <code>"\r"</code> or any combination of these.
    It is expected that the keywords will be composed of standard ASCII printing characters,
    but there is nothing to stop you using any non-separator character codes from 1 to 255
    (except common sense).</p>

    <p>How these keywords are used is entirely up to the lexer. Some languages, such as HTML may
    contain embedded languages, VBScript and JavaScript are common for HTML. For HTML, key word set
    0 is for HTML, 1 is for JavaScript and 2 is for VBScript, 3 is for Python, 4 is for PHP and 5
    is for SGML and DTD keywords. Review the lexer code to see examples of keyword list. A fully
    conforming lexer sets the fourth argument of the <code>LexerModule</code> constructor to be a
    list of strings that describe the uses of the keyword lists.</p>

    <p>Alternatively, you might use set 0 for general keywords, set 1 for keywords that cause
    indentation and set 2 for keywords that cause unindentation. Yet again, you might have a simple
    lexer that colours keywords and you could change languages by changing the keywords in set 0.
    There is nothing to stop you building your own keyword lists into the lexer, but this means
    that the lexer must be rebuilt if more keywords are added.</p>

    <p><b id="SCI_GETSTYLEBITSNEEDED">SCI_GETSTYLEBITSNEEDED</b><br />
     Retrieve the number of bits the current lexer needs for styling. This should normally be the argument
     to <a class="message" href="#SCI_SETSTYLEBITS">SCI_SETSTYLEBITS</a>.
     </p>

    <h2 id="Notifications">Notifications</h2>

    <p>Notifications are sent (fired) from the Scintilla control to its container when an event has
    occurred that may interest the container. Notifications are sent using the
    <code>WM_NOTIFY</code> message on Windows and the "notify" signal on GTK+. The container is
    passed a <code>SCNotification</code> structure containing information about the event.</p>
<pre id="SCNotification">
struct NotifyHeader {   // This matches the Win32 NMHDR structure
    void *hwndFrom;     // environment specific window handle/pointer
    uptr_t idFrom;        // CtrlID of the window issuing the notification
    unsigned int code;  // The SCN_* notification code
};

struct SCNotification {
    struct NotifyHeader nmhdr;
    int position;
    // SCN_STYLENEEDED, SCN_DOUBLECLICK, SCN_MODIFIED, SCN_DWELLSTART,
    // SCN_DWELLEND, SCN_CALLTIPCLICK,
    // SCN_HOTSPOTCLICK, SCN_HOTSPOTDOUBLECLICK
    int ch;             // SCN_CHARADDED, SCN_KEY
    int modifiers;      // SCN_KEY, SCN_DOUBLECLICK, SCN_HOTSPOTCLICK, SCN_HOTSPOTDOUBLECLICK
    int modificationType; // SCN_MODIFIED
    const char *text;   // SCN_MODIFIED, SCN_USERLISTSELECTION, SCN_AUTOCSELECTION
    int length;         // SCN_MODIFIED
    int linesAdded;     // SCN_MODIFIED
    int message;        // SCN_MACRORECORD
    uptr_t wParam;      // SCN_MACRORECORD
    sptr_t lParam;      // SCN_MACRORECORD
    int line;           // SCN_MODIFIED, SCN_DOUBLECLICK
    int foldLevelNow;   // SCN_MODIFIED
    int foldLevelPrev;  // SCN_MODIFIED
    int margin;         // SCN_MARGINCLICK
    int listType;       // SCN_USERLISTSELECTION, SCN_AUTOCSELECTION
    int x;              // SCN_DWELLSTART, SCN_DWELLEND
    int y;              // SCN_DWELLSTART, SCN_DWELLEND
};
</pre>

    <p>The notification messages that your container can choose to handle and the messages
    associated with them are:</p>
    <code><a class="message" href="#SCN_STYLENEEDED">SCN_STYLENEEDED</a><br />
     <a class="message" href="#SCN_CHARADDED">SCN_CHARADDED</a><br />
     <a class="message" href="#SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</a><br />
     <a class="message" href="#SCN_SAVEPOINTLEFT">SCN_SAVEPOINTLEFT</a><br />
     <a class="message" href="#SCN_MODIFYATTEMPTRO">SCN_MODIFYATTEMPTRO</a><br />
     <a class="message" href="#SCN_KEY">SCN_KEY</a><br />
     <a class="message" href="#SCN_DOUBLECLICK">SCN_DOUBLECLICK</a><br />
     <a class="message" href="#SCN_UPDATEUI">SCN_UPDATEUI</a><br />
     <a class="message" href="#SCN_MODIFIED">SCN_MODIFIED</a><br />
     <a class="message" href="#SCN_MACRORECORD">SCN_MACRORECORD</a><br />
     <a class="message" href="#SCN_MARGINCLICK">SCN_MARGINCLICK</a><br />
     <a class="message" href="#SCN_NEEDSHOWN">SCN_NEEDSHOWN</a><br />
     <a class="message" href="#SCN_PAINTED">SCN_PAINTED</a><br />
     <a class="message" href="#SCN_USERLISTSELECTION">SCN_USERLISTSELECTION</a><br />
     <a class="message" href="#SCN_URIDROPPED">SCN_URIDROPPED</a><br />
     <a class="message" href="#SCN_DWELLSTART">SCN_DWELLSTART</a><br />
     <a class="message" href="#SCN_DWELLEND">SCN_DWELLEND</a><br />
     <a class="message" href="#SCN_ZOOM">SCN_ZOOM</a><br />
     <a class="message" href="#SCN_HOTSPOTCLICK">SCN_HOTSPOTCLICK</a><br />
     <a class="message" href="#SCN_HOTSPOTDOUBLECLICK">SCN_HOTSPOTDOUBLECLICK</a><br />
     <a class="message" href="#SCN_INDICATORCLICK">SCN_INDICATORCLICK</a><br />
     <a class="message" href="#SCN_INDICATORRELEASE">SCN_INDICATORRELEASE</a><br />
     <a class="message" href="#SCN_CALLTIPCLICK">SCN_CALLTIPCLICK</a><br />
     <a class="message" href="#SCN_AUTOCSELECTION">SCN_AUTOCSELECTION</a><br />
     <a class="message" href="#SCN_AUTOCCANCELLED">SCN_AUTOCCANCELLED</a><br />
     <a class="message" href="#SCN_AUTOCCHARDELETED">SCN_AUTOCCHARDELETED</a><br />
    </code>

    <p>The following <code>SCI_*</code> messages are associated with these notifications:</p>
    <code><a class="message" href="#SCI_SETMODEVENTMASK">SCI_SETMODEVENTMASK(int
    eventMask)</a><br />
     <a class="message" href="#SCI_GETMODEVENTMASK">SCI_GETMODEVENTMASK</a><br />
     <a class="message" href="#SCI_SETMOUSEDWELLTIME">SCI_SETMOUSEDWELLTIME</a><br />
     <a class="message" href="#SCI_GETMOUSEDWELLTIME">SCI_GETMOUSEDWELLTIME</a><br />
    </code>

    <p>The following additional notifications are sent using the <code>WM_COMMAND</code> message on
    Windows and the "Command" signal on GTK+. This emulates the Windows Edit control. Only the lower
    16 bits of the control's ID is passed in these notifications.</p>
    <code><a class="message" href="#SCEN_CHANGE">SCEN_CHANGE</a><br />
     <a class="message" href="#SCEN_SETFOCUS">SCEN_SETFOCUS</a><br />
     <a class="message" href="#SCEN_KILLFOCUS">SCEN_KILLFOCUS</a><br />
    </code>

    <p><b id="SCN_STYLENEEDED">SCN_STYLENEEDED</b><br />
     If you used <code><a class="message"
    href="#SCI_SETLEXER">SCI_SETLEXER</a>(SCLEX_CONTAINER)</code> to make the container act as the
    lexer, you will receive this notification when Scintilla is about to display or print text that
    requires styling. You are required to style the text from the line that contains the position
    returned by <a class="message" href="#SCI_GETENDSTYLED"><code>SCI_GETENDSTYLED</code></a> up to
    the position passed in <code>SCNotification.position</code>. Symbolically, you need code of the
    form:</p>
<pre>
    startPos = <a class="message" href="#SCI_GETENDSTYLED">SCI_GETENDSTYLED</a>()
    lineNumber = <a class="message"
href="#SCI_LINEFROMPOSITION">SCI_LINEFROMPOSITION</a>(startPos);
    startPos = <a class="message"
href="#SCI_POSITIONFROMLINE">SCI_POSITIONFROMLINE</a>(lineNumber);
    MyStyleRoutine(startPos, SCNotification.position);
</pre>

    <p><b id="SCN_CHARADDED">SCN_CHARADDED</b><br />
     This is sent when the user types an ordinary text character (as opposed to a command
    character) that is entered into the text. The container can use this to decide to display a <a
    class="jump" href="#CallTips">call tip</a> or an <a class="jump" href="#Autocompletion">auto
    completion list</a>. The character is in <code>SCNotification.ch</code>.
        This notification is sent before the character has been styled so processing that depends on
        styling should instead be performed in the SCN_UPDATEUI notification.</p>

    <p><b id="SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</b><br />
     <b id="SCN_SAVEPOINTLEFT">SCN_SAVEPOINTLEFT</b><br />
     Sent to the container when the save point is entered or left, allowing the container to
    display a "document dirty" indicator and change its menus.<br />
     See also: <a class="message" href="#SCI_SETSAVEPOINT"><code>SCI_SETSAVEPOINT</code></a>, <a
    class="message" href="#SCI_GETMODIFY"><code>SCI_GETMODIFY</code></a></p>

    <p><b id="SCN_MODIFYATTEMPTRO">SCN_MODIFYATTEMPTRO</b><br />
     When in read-only mode, this notification is sent to the container if the user tries to change
    the text. This can be used to check the document out of a version control system. You can set
    the read-only state of a document with <code><a class="message"
    href="#SCI_SETREADONLY">SCI_SETREADONLY</a></code>.</p>

    <p><b id="SCN_KEY">SCN_KEY</b><br />
     Reports all keys pressed but not consumed by Scintilla. Used on GTK+ because of
     some problems with keyboard focus and is not sent by the Windows version. <code>SCNotification.ch</code> holds the key code and
    <code>SCNotification.modifiers</code> holds the modifiers. This notification is sent if the
    modifiers include <code>SCMOD_ALT</code> or <code>SCMOD_CTRL</code> and the key code is less
    than 256.</p>

    <p><b id="SCN_DOUBLECLICK">SCN_DOUBLECLICK</b><br />
     The mouse button was double clicked in editor. The <code>position</code> field is set to the text position of the
    double click and the <code>line</code> field is set to the line of the double click.</p>

    <p><b id="SCN_UPDATEUI">SCN_UPDATEUI</b><br />
     Either the text or styling of the document has changed or the selection range has changed. Now
    would be a good time to update any container UI elements that depend on document or view state.
    This was previously called <code><a class="message"
    href="#SCN_CHECKBRACE">SCN_CHECKBRACE</a></code> because a common use is to check whether the
    caret is next to a brace and set highlights on this brace and its corresponding matching brace.
    This also replaces <a class="message" href="#SCN_POSCHANGED"><code>SCN_POSCHANGED</code></a>,
    which is now deprecated.</p>

    <p><b id="SCN_MODIFIED">SCN_MODIFIED</b><br />
     This notification is sent when the text or styling of the document changes or is about to
    change. You can set a mask for the notifications that are sent to the container with <a
    class="message" href="#SCI_SETMODEVENTMASK"><code>SCI_SETMODEVENTMASK</code></a>. The
    notification structure contains information about what changed, how the change occurred and
    whether this changed the number of lines in the document. No modifications may be performed
    while in a <code>SCN_MODIFIED</code> event. The <code>SCNotification</code> fields used
    are:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Modify notification types">
      <tbody>
        <tr>
          <th align="left">Field</th>

          <th align="left">Usage</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>modificationType</code></td>

          <td align="left">A set of flags that identify the change(s) made. See the next
          table.</td>
        </tr>

        <tr>
          <td align="left"><code>position</code></td>

          <td align="left">Start position of a text or styling change. Set to 0 if not used.</td>
        </tr>

        <tr>
          <td align="left"><code>length</code></td>

          <td align="left">Length of the change in cells or characters when the text or styling
          changes. Set to 0 if not used.</td>
        </tr>

        <tr>
          <td align="left"><code>linesAdded</code></td>

          <td align="left">Number of added lines. If negative, the number of deleted lines. Set to
          0 if not used or no lines added or deleted.</td>
        </tr>

        <tr>
          <td align="left"><code>text</code></td>

          <td align="left">Valid for text changes, not for style changes. If we are collecting undo
          information this holds a pointer to the text that is handed to the Undo system, otherwise
          it is zero. For user performed SC_MOD_BEFOREDELETE the text field is 0 and
                  for user performed SC_MOD_BEFOREINSERT the text field points to an array of cells,
                   not bytes and the length is the number of cells.</td>
        </tr>

        <tr>
          <td align="left"><code>line</code></td>

          <td align="left">The line number at which a fold level or marker change occurred. This is
          0 if unused and may be -1 if more than one line changed.</td>
        </tr>

        <tr>
          <td align="left"><code>foldLevelNow</code></td>

          <td align="left">The new fold level applied to the line or 0 if this field is
          unused.</td>
        </tr>

        <tr>
          <td align="left"><code>foldLevelPrev</code></td>

          <td align="left">The previous folding level of the line or 0 if this field is
          unused.</td>
        </tr>
      </tbody>
    </table>

    <p>The <code>SCNotification.modificationType</code> field has bits set to tell you what has
    been done. The <code>SC_MOD_*</code> bits correspond to actions. The
    <code>SC_PERFORMED_*</code> bits tell you if the action was done by the user, or the result of
    Undo or Redo of a previous action.</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Modify notification type flags">
      <tbody>
        <tr>
          <th align="left">Symbol</th>

          <th>Value</th>

          <th align="left">Meaning</th>

          <th align="left">SCNotification fields</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_MOD_INSERTTEXT</code></td>

          <td align="center">0x01</td>

          <td>Text has been inserted into the document.</td>

          <td><code>position, length, text, linesAdded</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_DELETETEXT</code></td>

          <td align="center">0x02</td>

          <td>Text has been removed from the document.</td>

          <td><code>position, length, text, linesAdded</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_CHANGESTYLE</code></td>

          <td align="center">0x04</td>

          <td>A style change has occurred.</td>

          <td><code>position, length</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_CHANGEFOLD</code></td>

          <td align="center">0x08</td>

          <td>A folding change has occurred.</td>

          <td><code>line, foldLevelNow, foldLevelPrev</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_PERFORMED_USER</code></td>

          <td align="center">0x10</td>

          <td>Information: the operation was done by the user.</td>

          <td>None</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PERFORMED_UNDO</code></td>

          <td align="center">0x20</td>

          <td>Information: this was the result of an Undo.</td>

          <td>None</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PERFORMED_REDO</code></td>

          <td align="center">0x40</td>

          <td>Information: this was the result of a Redo.</td>

          <td>None</td>
        </tr>

        <tr>
          <td align="left"><code>SC_MULTISTEPUNDOREDO</code></td>

          <td align="center">0x80</td>

          <td>This is part of a multi-step Undo or Redo transaction.</td>

          <td>None</td>
        </tr>

        <tr>
          <td align="left"><code>SC_LASTSTEPINUNDOREDO</code></td>

          <td align="center">0x100</td>

          <td>This is the final step in an Undo or Redo transaction.</td>

          <td>None</td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_CHANGEMARKER</code></td>

          <td align="center">0x200</td>

          <td>One or more markers has changed in a line.</td>

          <td><code>line</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_BEFOREINSERT</code></td>

          <td align="center">0x400</td>

          <td>Text is about to be inserted into the document.</td>

          <td><code>position, if performed by user then text in cells, length in cells</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_BEFOREDELETE</code></td>

          <td align="center">0x800</td>

          <td>Text is about to be deleted from the document.</td>

          <td><code>position, length</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_CHANGEINDICATOR</code></td>

          <td align="center">0x4000</td>

          <td>An indicator has been added or removed from a range of text.</td>

          <td><code>position, length</code></td>
        </tr>

        <tr>
          <td align="left"><code id="SC_MOD_CHANGELINESTATE">SC_MOD_CHANGELINESTATE</code></td>

          <td align="center">0x8000</td>

          <td>A line state has changed because <a class="message" href="#SCI_SETLINESTATE">SCI_SETLINESTATE</a>
          was called.</td>

          <td><code>line</code></td>
        </tr>

        <tr>
          <td align="left"><code id="SC_MOD_CHANGEMARGIN">SC_MOD_CHANGEMARGIN</code></td>

          <td align="center">0x10000</td>

          <td>A text margin has changed.</td>

          <td><code>line</code></td>
        </tr>

        <tr>
          <td align="left"><code id="SC_MOD_CHANGEANNOTATION">SC_MOD_CHANGEANNOTATION</code></td>

          <td align="center">0x20000</td>

          <td>An annotation has changed.</td>

          <td><code>line</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MULTILINEUNDOREDO</code></td>

          <td align="center">0x1000</td>

          <td>This is part of an Undo or Redo with multi-line changes.</td>

          <td>None</td>
        </tr>

        <tr>
          <td align="left"><code>SC_STARTACTION</code></td>

          <td align="center">0x2000</td>

          <td>This is set on a SC_PERFORMED_USER action when it is the
          first or only step in an undo transaction. This can be used to integrate the Scintilla
          undo stack with an undo stack in the container application by adding a Scintilla
          action to the container's stack for the currently opened container transaction or
          to open a new container transaction if there is no open container transaction.
          </td>

          <td>None</td>
        </tr>

        <tr>
          <td align="left"><code id="SC_MOD_CONTAINER">SC_MOD_CONTAINER</code></td>

          <td align="center">0x40000</td>

          <td>This is set on for actions that the container stored into the undo stack with 
	  <a class="message" href="#SCI_ADDUNDOACTION"><code>SCI_ADDUNDOACTION</code></a>.
          </td>

          <td>token</td>
        </tr>

        <tr>
          <td align="left"><code>SC_MODEVENTMASKALL</code></td>

          <td align="center">0x7FFFF</td>

          <td>This is a mask for all valid flags. This is the default mask state set by <a
          class="message" href="#SCI_SETMODEVENTMASK"><code>SCI_SETMODEVENTMASK</code></a>.</td>

          <td>None</td>
        </tr>
      </tbody>
    </table>

    <p><b id="SCEN_CHANGE">SCEN_CHANGE</b><br />
     <code>SCEN_CHANGE</code> (768) is fired when the text (not the style) of the document changes.
    This notification is sent using the <code>WM_COMMAND</code> message on Windows and the
    "Command" signal on GTK+ as this is the behavior of the standard Edit control
    (<code>SCEN_CHANGE</code> has the same value as the Windows Edit control
    <code>EN_CHANGE</code>). No other information is sent. If you need more detailed information
    use <a class="message" href="#SCN_MODIFIED"><code>SCN_MODIFIED</code></a>. You can filter the
    types of changes you are notified about with <a class="message"
    href="#SCI_SETMODEVENTMASK"><code>SCI_SETMODEVENTMASK</code></a>.</p>

    <p><b id="SCI_SETMODEVENTMASK">SCI_SETMODEVENTMASK(int eventMask)</b><br />
     <b id="SCI_GETMODEVENTMASK">SCI_GETMODEVENTMASK</b><br />
     These messages set and get an event mask that determines which document change events are
    notified to the container with <a class="message"
    href="#SCN_MODIFIED"><code>SCN_MODIFIED</code></a> and <a class="message"
    href="#SCEN_CHANGE"><code>SCEN_CHANGE</code></a>. For example, a container may decide to see
    only notifications about changes to text and not styling changes by calling
    <code>SCI_SETMODEVENTMASK(SC_MOD_INSERTTEXT|SC_MOD_DELETETEXT)</code>.</p>

    <p>The possible notification types are the same as the <code>modificationType</code> bit flags
    used by <code>SCN_MODIFIED</code>: <code>SC_MOD_INSERTTEXT</code>,
    <code>SC_MOD_DELETETEXT</code>, <code>SC_MOD_CHANGESTYLE</code>,
    <code>SC_MOD_CHANGEFOLD</code>, <code>SC_PERFORMED_USER</code>, <code>SC_PERFORMED_UNDO</code>,
    <code>SC_PERFORMED_REDO</code>, <code>SC_MULTISTEPUNDOREDO</code>,
    <code>SC_LASTSTEPINUNDOREDO</code>, <code>SC_MOD_CHANGEMARKER</code>,
    <code>SC_MOD_BEFOREINSERT</code>, <code>SC_MOD_BEFOREDELETE</code>,
    <code>SC_MULTILINEUNDOREDO</code>, and <code>SC_MODEVENTMASKALL</code>.</p>

    <p><b id="SCEN_SETFOCUS">SCEN_SETFOCUS</b><br />
     <b id="SCEN_KILLFOCUS">SCEN_KILLFOCUS</b><br />
     <code>SCEN_SETFOCUS</code> (512) is fired when Scintilla receives focus and
    <code>SCEN_KILLFOCUS</code> (256) when it loses focus. These notifications are sent using the
    <code>WM_COMMAND</code> message on Windows and the "Command" signal on GTK+ as this is the
    behavior of the standard Edit control. Unfortunately, these codes do not match the Windows Edit
    notification codes <code>EN_SETFOCUS</code> (256) and <code>EN_KILLFOCUS</code> (512). It is
    now too late to change the Scintilla codes as clients depend on the current values.</p>

    <p><b id="SCN_MACRORECORD">SCN_MACRORECORD</b><br />
     The <code><a class="message" href="#SCI_STARTRECORD">SCI_STARTRECORD</a></code> and <a
    class="message" href="#SCI_STOPRECORD"><code>SCI_STOPRECORD</code></a> messages enable and
    disable macro recording. When enabled, each time a recordable change occurs, the
    <code>SCN_MACRORECORD</code> notification is sent to the container. It is up to the container
    to record the action. To see the complete list of <code>SCI_*</code> messages that are
    recordable, search the Scintilla source <code>Editor.cxx</code> for
    <code>Editor::NotifyMacroRecord</code>. The fields of <code>SCNotification</code> set in this
    notification are:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Macro record notification data">
      <tbody>
        <tr>
          <th align="left">Field</th>

          <th align="left">Usage</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>message</code></td>

          <td align="left">The <code>SCI_*</code> message that caused the notification.</td>
        </tr>

        <tr>
          <td align="left"><code>wParam</code></td>

          <td align="left">The value of <code>wParam</code> in the <code>SCI_*</code> message.</td>
        </tr>

        <tr>
          <td align="left"><code>lParam</code></td>

          <td align="left">The value of <code>lParam</code> in the <code>SCI_*</code> message.</td>
        </tr>
      </tbody>
    </table>

    <p><b id="SCN_MARGINCLICK">SCN_MARGINCLICK</b><br />
     This notification tells the container that the mouse was clicked inside a <a class="jump"
    href="#Margins">margin</a> that was marked as sensitive (see <a class="message"
    href="#SCI_SETMARGINSENSITIVEN"><code>SCI_SETMARGINSENSITIVEN</code></a>). This can be used to
    perform folding or to place breakpoints. The following <code>SCNotification</code> fields are
    used:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Margin click notification">
      <tbody>
        <tr>
          <th align="left">Field</th>

          <th align="left">Usage</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>modifiers</code></td>

          <td align="left">The appropriate combination of <code>SCI_SHIFT</code>,
          <code>SCI_CTRL</code> and <code>SCI_ALT</code> to indicate the keys that were held down
          at the time of the margin click.</td>
        </tr>

        <tr>
          <td align="left"><code>position</code></td>

          <td align="left">The position of the start of the line in the document that corresponds
          to the margin click.</td>
        </tr>

        <tr>
          <td align="left"><code>margin</code></td>

          <td align="left">The margin number that was clicked.</td>
        </tr>
      </tbody>
    </table>

    <p><b id="SCN_NEEDSHOWN">SCN_NEEDSHOWN</b><br />
     Scintilla has determined that a range of lines that is currently invisible should be made
    visible. An example of where this may be needed is if the end of line of a contracted fold
    point is deleted. This message is sent to the container in case it wants to make the line
    visible in some unusual way such as making the whole document visible. Most containers will
    just ensure each line in the range is visible by calling <a class="message"
    href="#SCI_ENSUREVISIBLE"><code>SCI_ENSUREVISIBLE</code></a>. The <code>position</code> and
    <code>length</code> fields of <code>SCNotification</code> indicate the range of the document
    that should be made visible. The container code will be similar to the following code
    skeleton:</p>
<pre>
firstLine = SCI_LINEFROMPOSITION(scn.position)
lastLine = SCI_LINEFROMPOSITION(scn.position+scn.length-1)
for line = lineStart to lineEnd do SCI_ENSUREVISIBLE(line) next
</pre>

    <p><b id="SCN_PAINTED">SCN_PAINTED</b><br />
     Painting has just been done. Useful when you want to update some other widgets based on a
    change in Scintilla, but want to have the paint occur first to appear more responsive. There is
    no other information in <code>SCNotification</code>.</p>

    <p><b id="SCN_USERLISTSELECTION">SCN_USERLISTSELECTION</b><br />
     The user has selected an item in a <a class="jump" href="#UserLists">user list</a>. The
    <code>SCNotification</code> fields used are:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="User list notification">
      <tbody>
        <tr>
          <th align="left">Field</th>

          <th align="left">Usage</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>wParam</code></td>

          <td align="left">This is set to the <code>listType</code> parameter from the <a
          class="message" href="#SCI_USERLISTSHOW"><code>SCI_USERLISTSHOW</code></a> message that
          initiated the list.</td>
        </tr>

        <tr>
          <td align="left"><code>text</code></td>

          <td align="left">The text of the selection.</td>
        </tr>
      </tbody>
    </table>
    <br />
     <br />


    <p><b id="SCN_URIDROPPED">SCN_URIDROPPED</b><br />
     Only on the GTK+ version. Indicates that the user has dragged a URI such as a file name or Web
    address onto Scintilla. The container could interpret this as a request to open the file. The
    <code>text</code> field of <code>SCNotification</code> points at the URI text.</p>

    <p><b id="SCN_DWELLSTART">SCN_DWELLSTART</b><br />
     <b id="SCN_DWELLEND">SCN_DWELLEND</b><br />
     <code>SCN_DWELLSTART</code> is generated when the user keeps the mouse in one position for the
    dwell period (see <code><a class="message"
    href="#SCI_SETMOUSEDWELLTIME">SCI_SETMOUSEDWELLTIME</a></code>). <code>SCN_DWELLEND</code> is
    generated after a <code>SCN_DWELLSTART</code> and the mouse is moved or other activity such as
    key press indicates the dwell is over. Both notifications set the same fields in
    <code>SCNotification</code>:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Mouse dwell notification">
      <tbody>
        <tr>
          <th align="left">Field</th>

          <th align="left">Usage</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>position</code></td>

          <td align="left">This is the nearest position in the document to the position where the
          mouse pointer was lingering.</td>
        </tr>

        <tr>
          <td align="left"><code>x, y</code></td>

          <td align="left">Where the pointer lingered. The <code>position</code> field is set to
          <code><a class="message"
          href="#SCI_POSITIONFROMPOINTCLOSE">SCI_POSITIONFROMPOINTCLOSE</a>(x, y)</code>.</td>
        </tr>
      </tbody>
    </table>
    <br />
     <br />

    <p><b id="SCI_SETMOUSEDWELLTIME">SCI_SETMOUSEDWELLTIME</b><br />
     <b id="SCI_GETMOUSEDWELLTIME">SCI_GETMOUSEDWELLTIME</b><br />
     These two messages set and get the time the mouse must sit still, in milliseconds, to generate
    a <code><a class="message" href="#SCN_DWELLSTART">SCN_DWELLSTART</a></code> notification. If
    set to <code>SC_TIME_FOREVER</code>, the default, no dwell events are generated.</p>

    <p><b id="SCN_ZOOM">SCN_ZOOM</b><br />
     This notification is generated when the user zooms the display using the keyboard or the
    <code><a class="message" href="#SCI_SETZOOM">SCI_SETZOOM</a></code> method is called. This
    notification can be used to recalculate positions, such as the width of the line number margin
    to maintain sizes in terms of characters rather than pixels. <code>SCNotification</code> has no
    additional information.</p>

    <p>
    <b id="SCN_HOTSPOTCLICK">SCN_HOTSPOTCLICK</b><br />
    <b id="SCN_HOTSPOTDOUBLECLICK">SCN_HOTSPOTDOUBLECLICK</b><br />
     These notifications are generated when the user clicks or double clicks on
     text that is in a style with the hotspot attribute set.
    This notification can be used to link to variable definitions or web pages.
    The <code>position</code> field is set the text position of the click or
    double click and the <code>modifiers</code> field set to the key modifiers
    held down in a similar manner to <a class="message" href="#SCN_KEY">SCN_KEY</a>.</p>

    <p>
    <b id="SCN_INDICATORCLICK">SCN_INDICATORCLICK</b><br />
    <b id="SCN_INDICATORRELEASE">SCN_INDICATORRELEASE</b><br />
     These notifications are generated when the user clicks or releases the mouse on
     text that has an indicator.
    The <code>position</code> field is set the text position of the click or
    double click and the <code>modifiers</code> field set to the key modifiers
    held down in a similar manner to <a class="message" href="#SCN_KEY">SCN_KEY</a>.</p>

    <p><b id="SCN_CALLTIPCLICK">SCN_CALLTIPCLICK</b><br />
     This notification is generated when the user clicks on a calltip.
    This notification can be used to display the next function prototype when a
    function name is overloaded with different arguments.
    The <code>position</code> field is set to 1 if the click is in an up arrow,
    2 if in a down arrow, and 0 if elsewhere.</p>

    <p><b id="SCN_AUTOCSELECTION">SCN_AUTOCSELECTION</b><br />
     The user has selected an item in an <a class="jump" href="#Autocompletion">autocompletion list</a>. The
     notification is sent before the selection is inserted. Automatic insertion can be cancelled by sending a
     <code><a class="message" href="#SCI_AUTOCCANCEL">SCI_AUTOCCANCEL</a></code> message
     before returning from the notification. The <code>SCNotification</code> fields used are:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Autocompletion list notification">
      <tbody>
        <tr>
          <th align="left">Field</th>

          <th align="left">Usage</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>lParam</code></td>

          <td align="left">The start position of the word being completed.</td>
        </tr>
        <tr>
          <td align="left"><code>text</code></td>

          <td align="left">The text of the selection.</td>
        </tr>
      </tbody>
    </table>

    <p><b id="SCN_AUTOCCANCELLED">SCN_AUTOCCANCELLED</b><br />
     The user has cancelled an <a class="jump" href="#Autocompletion">autocompletion list</a>.
     There is no other information in SCNotification.</p>

    <p><b id="SCN_AUTOCCHARDELETED">SCN_AUTOCCHARDELETED</b><br />
     The user deleted a character while autocompletion list was active.
     There is no other information in SCNotification.</p>

    <h2 id="GTK">GTK+</h2>
    <p>On GTK+, the following functions create a Scintilla widget, communicate with it and allow
    resources to be released after all Scintilla widgets have been destroyed.</p>
    <code><a class="message" href="#scintilla_new">GtkWidget *scintilla_new()</a><br />
     <a class="message" href="#scintilla_set_id">void scintilla_set_id(ScintillaObject *sci, uptr_t id)</a><br />
     <a class="message" href="#scintilla_send_message">sptr_t scintilla_send_message(ScintillaObject *sci,unsigned int iMessage, uptr_t wParam, sptr_t lParam)</a><br />
     <a class="message" href="#scintilla_release_resources">void scintilla_release_resources()</a><br />
     </code>

    <p><b id="scintilla_new">GtkWidget *scintilla_new()</b></b><br />
    Create a new Scintilla widget. The returned pointer can be added to a container and displayed in the same way as other
    widgets.</p>

    <p><b id="scintilla_set_id">void scintilla_set_id(ScintillaObject *sci, uptr_t id)</b></b><br />
    Set the control ID which will be used in the idFrom field of the NotifyHeader structure of all
    notifications for this instance. When an application creates multiple Scintilla widgets, this allows
    the source of each notification to be found. The value should be small, preferrably less than 16 bits,
    rather than a pointer as some of the functions will only transmit 16 or 32 bits.</p>

    <p><b id="scintilla_send_message">sptr_t scintilla_send_message(ScintillaObject *sci,unsigned int iMessage, uptr_t wParam, sptr_t lParam)</b><br />
    The main entry point allows sending any of the messages described in this document.</p>

    <p><b id="scintilla_release_resources">void scintilla_release_resources()</b><br />
    Call this to free any remaining resources after all the Scintilla widgets have been destroyed.</p>

    <h2 id="DeprecatedMessages">Deprecated messages and notifications</h2>

    <p>The following messages are currently supported to emulate existing Windows controls, but
    they will be removed in future versions of Scintilla. If you use these messages you should
    replace them with the Scintilla equivalent.</p>
<pre>
WM_GETTEXT(int length, char *text)
WM_SETTEXT(&lt;unused&gt;, const char *text)
EM_GETLINE(int line, char *text)
EM_REPLACESEL(&lt;unused&gt;, const char *text)
EM_SETREADONLY
EM_GETTEXTRANGE(&lt;unused&gt;, TEXTRANGE *tr)
WM_CUT
WM_COPY
WM_PASTE
WM_CLEAR
WM_UNDO
EM_CANUNDO
EM_EMPTYUNDOBUFFER
WM_GETTEXTLENGTH
EM_GETFIRSTVISIBLELINE
EM_GETLINECOUNT
EM_GETMODIFY
EM_SETMODIFY(bool isModified)
EM_GETRECT(RECT *rect)
EM_GETSEL(int *start, int *end)
EM_EXGETSEL(&lt;unused&gt;, CHARRANGE *cr)
EM_SETSEL(int start, int end)
EM_EXSETSEL(&lt;unused&gt;, CHARRANGE *cr)
EM_GETSELTEXT(&lt;unused&gt;, char *text)
EM_LINEFROMCHAR(int position)
EM_EXLINEFROMCHAR(int position)
EM_LINEINDEX(int line)
EM_LINELENGTH(int position)
EM_SCROLL(int line)
EM_LINESCROLL(int column, int line)
EM_SCROLLCARET()
EM_CANPASTE
EM_CHARFROMPOS(&lt;unused&gt;, POINT *location)
EM_POSFROMCHAR(int position, POINT *location)
EM_SELECTIONTYPE
EM_HIDESELECTION(bool hide)
EM_FINDTEXT(int flags, FINDTEXTEX *ft)
EM_FINDTEXTEX(int flags, FINDTEXTEX *ft)
EM_GETMARGINS
EM_SETMARGINS(EC_LEFTMARGIN or EC_RIGHTMARGIN or EC_USEFONTINFO, int val)
EM_FORMATRANGE
</pre>

    <p>The following are features that are only included if you define
    <code>INCLUDE_DEPRECATED_FEATURES</code> in <code>Scintilla.h</code>. To ensure future
    compatibility you should change them as indicated.</p>

    <p><b id="SCN_POSCHANGED">SCN_POSCHANGED()</b> Deprecated<br />
     Fired when the user moves the cursor to a different position in the text. Use <a
    class="message" href="#SCN_UPDATEUI"><code>SCN_UPDATEUI</code></a> instead.</p>

    <p><b id="SCN_CHECKBRACE">SCN_CHECKBRACE</b> Deprecated<br />
     Either the text or styling of the document has changed or the selection range has changed.
    This is replaced by <a class="message" href="#SCN_UPDATEUI"><code>SCN_UPDATEUI</code></a>. You
    can also use <code><a class="message" href="#SCN_MODIFIED">SCN_MODIFIED</a></code> for more
    detailed information on text and styling changes,</p>

    <h2 id="EditMessagesNeverSupportedByScintilla">Edit messages never supported by Scintilla</h2>
<pre>
EM_GETWORDBREAKPROC EM_GETWORDBREAKPROCEX
EM_SETWORDBREAKPROC EM_SETWORDBREAKPROCEX
EM_GETWORDWRAPMODE EM_SETWORDWRAPMODE
EM_LIMITTEXT EM_EXLIMITTEXT
EM_SETRECT EM_SETRECTNP
EM_FMTLINES
EM_GETHANDLE EM_SETHANDLE
EM_GETPASSWORDCHAR EM_SETPASSWORDCHAR
EM_SETTABSTOPS
EM_FINDWORDBREAK
EM_GETCHARFORMAT EM_SETCHARFORMAT
EM_GETOLEINTERFACE EM_SETOLEINTERFACE
EM_SETOLECALLBACK
EM_GETPARAFORMAT EM_SETPARAFORMAT
EM_PASTESPECIAL
EM_REQUESTRESIZE
EM_GETBKGNDCOLOR EM_SETBKGNDCOLOR
EM_STREAMIN EM_STREAMOUT
EM_GETIMECOLOR EM_SETIMECOLOR
EM_GETIMEOPTIONS EM_SETIMEOPTIONS
EM_GETOPTIONS EM_SETOPTIONS
EM_GETPUNCTUATION EM_SETPUNCTUATION
EM_GETTHUMB
EM_GETEVENTMASK
EM_SETEVENTMASK
EM_DISPLAYBAND
EM_SETTARGETDEVICE
</pre>

    <p>Scintilla tries to be a superset of the standard windows Edit and RichEdit controls wherever
    that makes sense. As it is not intended for use in a word processor, some edit messages can not
    be sensibly handled. Unsupported messages have no effect.</p>

    <h2 id="BuildingScintilla">Building Scintilla</h2>

    <p>To build Scintilla or SciTE, see the README file present in both the Scintilla and SciTE
    directories. For Windows, GCC 3.2, Borland C++ or Microsoft Visual Studio .NET can be used
    for building. There is a make file for building Scintilla but not SciTE with Visual C++ 6 at
    scintilla/win32/scintilla_vc6.mak. For GTK+, GCC 3.1 should be used. GTK+ 1.2x and 2.0x are
    supported. The version of GTK+ installed should be detected automatically.
    When both GTK+ 1 and GTK+ 2 are present, building for GTK+ 1.x requires defining GTK1
    on the command line.</p>

    <h3>Static linking</h3>

    <p>On Windows, Scintilla is normally used as a dynamic library as a .DLL file. If you want to
    link Scintilla directly into your application .EXE or .DLL file, then the
    <code>STATIC_BUILD</code> preprocessor symbol should be defined and
    <code>Scintilla_RegisterClasses</code> called. <code>STATIC_BUILD</code> prevents compiling the
    <code>DllMain</code> function which will conflict with any <code>DllMain</code> defined in your
    code. <code>Scintilla_RegisterClasses</code> takes the <code>HINSTANCE</code> of your
    application and ensures that the "Scintilla" window class is registered. To make sure that the
    right pointing arrow cursor used in the margin is displayed by Scintilla add the
    <code>scintilla/win32/Margin.cur</code> file to your application's resources with the ID
    <code>IDC_MARGIN</code> which is defined in <code>scintilla/win32/platfromRes.h</code> as
    400.</p>

    <h3>Ensuring lexers are linked into Scintilla</h3>

    <p>Depending on the compiler and linker used, the lexers may be stripped out. This is most
    often caused when building a static library. To ensure the lexers are linked in, the
    <code>Scintilla_LinkLexers()</code> function may be called.</p>

    <h3>Changing set of lexers</h3>

    <p>To change the set of lexers in Scintilla, add and remove lexer source files
    (<code>Lex*.cxx</code>) from the <code>scintilla/src directory</code> and run the
    <code>src/LexGen.py</code> script from the <code>src</code> directory to update the make files
    and <code>KeyWords.cxx</code>. <code>LexGen.py</code> requires Python 2.1 or later. If you do
    not have access to Python, you can hand edit <code>KeyWords.cxx</code> in a simple-minded way,
    following the patterns of other lexers. The important thing is to include
    <code>LINK_LEXER(lmMyLexer);</code> to correspond with the <code>LexerModule
    lmMyLexer(...);</code> in your lexer source code.</p>

    <h3>Building with an alternative Regular Expression implementation</h3>

 <p id="AlternativeRegEx">A simple interface provides support for switching the Regular Expressions engine at
 compile time. You must implement <code>RegexSearchBase</code> for your chosen engine,
 look at the built-in implementation <code>BuiltinRegex</code> to see how this is done.
 You then need to implement the factory method <code>CreateRegexSearch</code>
 to create an instance of your class. You must disable the built-in implementation by defining
 <code>SCI_OWNREGEX</code>.</p>

  </body>
</html>

